import{B as e}from"./main.js";class t extends String{}const r=new Set(["<",">","<=",">="]),n=(e,...s)=>{const o=e.replace(/%[%drscjw]/g,(e=>{if("%%"===e)return"%";if(0===s.length)throw new Error("Unexpected arguments count");const o=s.shift();switch(e){case"%d":if("number"==typeof o)return o;throw new Error("Expected a number");case"%r":if(o instanceof RegExp)return n("new RegExp(%j, %j)",o.source,o.flags);throw new Error("Expected a RegExp instance");case"%s":if(o instanceof t)return o;throw new Error("Expected a safe string");case"%c":if(r.has(o))return o;throw new Error("Expected a compare op");case"%j":return(e=>{if([1/0,-1/0,NaN,void 0,null].includes(e))return`${e}`;if(!["string","boolean","number"].includes(typeof e)){if("object"!=typeof e)throw new Error("Unexpected value type");const t=Object.getPrototypeOf(e);if(!(t===Array.prototype&&Array.isArray(e)||t===Object.prototype))throw new Error("Unexpected object given as value")}return JSON.stringify(e).replace(/([{,])"__proto__":/g,'$1["__proto__"]:').replace(/[^\\]"__proto__":/g,(()=>{throw new Error("Unreachable")})).replace(/[\u2028\u2029]/g,(e=>`\\u${e.charCodeAt(0).toString(16).padStart(4,"0")}`))})(o);case"%w":if(Number.isInteger(o)&&o>=0)return" ".repeat(o);throw new Error("Expected a non-negative integer for indentation")}throw new Error("Unreachable")}));if(0!==s.length)throw new Error("Unexpected arguments count");return new t(o)},s=e=>{if(!/^[a-z][a-z0-9_]*$/i.test(e))throw new Error("Does not look like a safe id");return new t(e)},o=e=>(...r)=>{if(!r.every((e=>e instanceof t)))throw new Error("Unsafe arguments");return new t(e(...r))},i=o(((...e)=>e.some((e=>"true"==`${e}`))?"true":e.join(" || ")||"false")),a=o(((...e)=>e.some((e=>"false"==`${e}`))?"false":e.join(" && ")||"true")),c=e=>"true"==`${e}`?s("false"):"false"==`${e}`?s("true"):n("!%s",(e=>/^[a-z][a-z0-9_().]*$/i.test(e)||/^\([^()]+\)$/i.test(e)?e:n("(%s)",e))(e));var l={format:n,safe:s,safeand:a,safenot:c,safenotor:(...e)=>c(i(...e))};const{safe:u}=l,p=new WeakMap;var d={scopeMethods:e=>{p.has(e)||p.set(e,{sym:new Map,ref:new Map,format:new Map,pattern:new Map});const t=p.get(e),r=e=>{t.sym.get(e)||t.sym.set(e,0);const r=t.sym.get(e);return t.sym.set(e,r+1),u(`${e}${r}`)};t.loop||(t.loop="ijklmnopqrstuvxyz".split(""));return{gensym:r,genpattern:n=>{if(t.pattern.has(n))return t.pattern.get(n);const s=r("pattern");return e[s]=new RegExp(n,"u"),t.pattern.set(n,s),s},genloop:()=>{const e=t.loop.shift();return t.loop.push(`${e}${e[0]}`),u(e)},getref:e=>t.ref.get(e),genref:e=>{const n=r("ref");return t.ref.set(e,n),n},genformat:n=>{let s=t.format.get(n);return s||(s=r("format"),e[s]=n,t.format.set(n,s)),s}}}};const f=(e,t)=>{if(e===t)return!0;if(!e||!t||typeof e!=typeof t)return!1;if(e!==t&&"object"!=typeof e)return!1;const r=Object.getPrototypeOf(e);if(r!==Object.getPrototypeOf(t))return!1;if(r===Array.prototype)return!(!Array.isArray(e)||!Array.isArray(t))&&(e.length===t.length&&e.every(((e,r)=>f(e,t[r]))));if(r===Object.prototype){const[r,n]=[Object.keys(e),Object.keys(t)];if(r.length!==n.length)return!1;return new Set([...r,...n]).size===r.length&&r.every((r=>f(e[r],t[r])))}return!1},m=Function.prototype.call.bind(Object.prototype.hasOwnProperty);m[Symbol.for("toJayString")]="Function.prototype.call.bind(Object.prototype.hasOwnProperty)";const y=e=>/~\//.test(e)?`${e}`.replace(/~/g,"~0").replace(/\//g,"~1"):e;var h={stringLength:e=>/[\uD800-\uDFFF]/.test(e)?[...e].length:e.length,isMultipleOf:(e,t,r,n)=>{if(e%t==0)return!0;let s=e*r;if(s!==1/0&&s!==-1/0||(s=e),s%n==0)return!0;const o=Math.floor(s+.5);return o/r===e&&o%n==0},deepEqual:f,unique:e=>{if(e.length<2)return!0;if(2===e.length)return!f(e[0],e[1]);const t=[],r=e.length>20?new Set:null;let n=0,s=0;for(const o of e){if("object"==typeof o)t.push(o);else if(r){if(r.add(o),r.size!==++n)return!1}else if(-1!==e.indexOf(o,s+1))return!1;s++}for(let e=1;e<t.length;e++)for(let r=0;r<e;r++)if(f(t[e],t[r]))return!1;return!0},deBase64:t=>{if(void 0!==e)return e.from(t,"base64").toString("utf-8");const r=atob(t);return new TextDecoder("utf-8").decode(new Uint8Array(r.length).map(((e,t)=>r.charCodeAt(t))))},hasOwn:m,...{toPointer:e=>0===e.length?"#":`#/${e.map(y).join("/")}`,pointerPart:y,errorMerge:({keywordLocation:e,instanceLocation:t},r,n)=>({keywordLocation:`${r}${e.slice(1)}`,instanceLocation:`${n}${t.slice(1)}`}),propertyIn:(e,[t,r])=>t.includes(!0)||t.some((t=>t===e))||r.some((t=>new RegExp(t,"u").test(e))),dynamicResolve:(e,t)=>(e.filter((e=>e[t]))[0]||{})[t]}};const{format:g,safe:w}=l,{scopeMethods:b}=d,$=h,v=new Map(Object.entries({null:e=>g("%s === null",e),boolean:e=>g('typeof %s === "boolean"',e),array:e=>g("Array.isArray(%s)",e),object:e=>g('typeof %s === "object" && %s && !Array.isArray(%s)',e,e,e),number:e=>g('typeof %s === "number"',e),integer:e=>g("Number.isInteger(%s)",e),string:e=>g('typeof %s === "string"',e)})),j=({name:e,parent:t,keyval:r,keyname:n})=>{if(e){if(t||r||n)throw new Error("name can be used only stand-alone");return e}if(!t)throw new Error("Can not use property of undefined parent!");const s=j(t);if(void 0!==r){if(n)throw new Error("Can not use key value and name together");if(!["string","number"].includes(typeof r))throw new Error("Invalid property path");return/^[a-z][a-z0-9_]*$/i.test(r)?g("%s.%s",s,w(r)):g("%s[%j]",s,r)}if(n)return g("%s[%s]",s,n);throw new Error("Unreachable")},O=new Set([].concat(...[Object,Array,String,Number,Boolean].map((e=>Object.getOwnPropertyNames(e.prototype))))),x=/^\([^)]*\) *=>/,E=/^[^=]*=>/,k=Symbol.for("toJayString");var A={types:v,buildName:j,jsHelpers:(e,t,r,{unmodifiedPrototypes:n,isJSON:s},o)=>{const{gensym:i,genpattern:a,genloop:c}=b(t,r);return{present:e=>{const r=j(e),{parent:o,keyval:i,keyname:a,inKeys:c,checked:l}=e;if(l||c&&s)throw new Error("Unreachable: useless check for undefined");if(c)return g("%s !== undefined",r);if(o&&a){t.hasOwn=$.hasOwn;const e=j(o);return s?g("%s !== undefined && hasOwn(%s, %s)",r,e,a):g("%s in %s && hasOwn(%s, %s)",a,e,e,a)}if(o&&void 0!==i){if(n&&s&&!O.has(`${i}`))return g("%s !== undefined",r);t.hasOwn=$.hasOwn;const e=j(o);return s?g("%s !== undefined && hasOwn(%s, %j)",r,e,i):g("%j in %s && hasOwn(%s, %j)",i,e,e,i)}throw new Error("Unreachable: present() check without parent")},forObjectKeys:(t,n)=>{const s=i("key");e.block(g("for (const %s of Object.keys(%s))",s,j(t)),(()=>{n(r(t,s,!0),s)}))},forArray:(t,s,o)=>{const i=c(),a=j(t);e.block(g("for (let %s = %s; %s < %s.length; %s++)",i,s,i,a,i),(()=>{o(r(t,i,n,!0),i)}))},patternTest:(e,t)=>{const r=e.replace(/[.^$|*+?(){}[\]\\]/gu,"");if(e===`^${r}$`)return g("(%s === %j)",t,e.slice(1,-1));if(o.has(e))return g("true");if([r,`${r}+`,`${r}.*`,`.*${r}.*`].includes(e))return g("%s.includes(%j)",t,r);if([`^${r}`,`^${r}+`,`^${r}.*`].includes(e))return g("%s.startsWith(%j)",t,r);if([`${r}$`,`.*${r}$`].includes(e))return g("%s.endsWith(%j)",t,r);const n=[...r].slice(0,-1).join("");return[`${r}*`,`${r}?`].includes(e)?0===n.length?g("true"):g("%s.includes(%j)",t,n):[`^${r}*`,`^${r}?`].includes(e)?0===n.length?g("true"):g("%s.startsWith(%j)",t,n):g("%s.test(%s)",a(e),t)},compare:(e,r)=>{if(!r||"object"!=typeof r)return g("%s === %j",e,r);let n;const s=e=>e.length<=3&&e.every((e=>!e||"object"!=typeof e));if(Array.isArray(r)){if(n=v.get("array")(e),s(r)){let t=g("%s.length === %d",e,r.length);for(let n=0;n<r.length;n++)t=g("%s && %s[%d] === %j",t,e,n,r[n]);return g("%s && %s",n,t)}}else{n=v.get("object")(e);const[o,i]=[Object.keys(r),Object.values(r)];if(s(i)){let s=g("Object.keys(%s).length === %d",e,o.length);o.length>0&&(t.hasOwn=$.hasOwn);for(const t of o)s=g("%s && hasOwn(%s, %j)",s,e,t);for(const t of o)s=g("%s && %s[%j] === %j",s,e,t,r[t]);return g("%s && %s",n,s)}}return t.deepEqual=$.deepEqual,g("%s && deepEqual(%s, %j)",n,e,r)},propvar:r}},jaystring:function(e){if("function"==typeof e){if(e[k])return e[k];if(Object.getPrototypeOf(e)!==Function.prototype)throw new Error("Can not stringify: a function with unexpected prototype");const t=`${e}`;if(e.prototype){if(!/^function[ (]/.test(t))throw new Error("Unexpected function");return t}if(x.test(t)||E.test(t))return t;throw new Error("Can not stringify: only either normal or arrow functions are supported")}if("object"==typeof e){const t=Object.getPrototypeOf(e);if(e instanceof RegExp&&t===RegExp.prototype)return g("%r",e);throw new Error("Can not stringify: an object with unexpected prototype")}throw new Error("Can not stringify: unknown type "+typeof e)}};const{format:S,safe:z,safenot:M}=l,{jaystring:q}=A,N=/[{[]/,P=/[}\]]/;var I=()=>{const e=[];let t=0;const r=()=>{if(0!==t)throw new Error("Unexpected indent at build()");const r=e.map((e=>S("%w%s",2*e.indent,e.code))).join("\n");return/^[a-z][a-z0-9]*$/i.test(r)?`return ${r}`:`return (${r})`},n=e=>{const t=Object.entries(e);for(const[e,r]of t){if(!/^[a-z][a-z0-9]*$/i.test(e))throw new Error("Unexpected scope key!");if(!("function"==typeof r||r instanceof RegExp))throw new Error("Unexpected scope value!")}return t};return{optimizedOut:!1,size:()=>e.length,write(r,...n){if("string"!=typeof r)throw new Error("Format must be a string!");if(r.includes("\n"))throw new Error("Only single lines are supported");var s;return s=S(r,...n),P.test(s.trim()[0])&&t--,e.push({indent:t,code:s}),N.test(s[s.length-1])&&t++,!0},block(r,n,s=!1){const o=t;this.write("%s {",r);const i=e.length;if(n(),i===e.length)return e.pop(),t=o,!1;if(i===e.length-1&&!s){const{code:n}=e[e.length-1];if(!/^(if|for) /.test(n))return e.length-=2,t=o,this.write("%s %s",r,n)}return this.write("}")},if(e,t,r){"false"==`${e}`?(r&&r(),t&&(this.optimizedOut=!0)):"true"==`${e}`?(t&&t(),r&&(this.optimizedOut=!0)):t&&this.block(S("if (%s)",e),t,!!r)?r&&this.block(S("else"),r):r&&this.if(M(e),r)},makeModule:(e={})=>`(function() {\n'use strict'\n${n(e).map((([e,t])=>`const ${z(e)} = ${q(t)};`)).join("\n")}\n${r()}})()`,makeFunction(e={}){const t=n(e),s=t.map((e=>e[0])),o=t.map((e=>e[1]));return Function(...s,`'use strict'\n${r()}`)(...o)}}};const R=["core","applicator","unevaluated","validation","meta-data","format-annotation","format-assertion","content"];var U={knownKeywords:["$schema","$vocabulary","id","$id","$anchor","$ref","definitions","$defs","$recursiveRef","$recursiveAnchor","$dynamicAnchor","$dynamicRef","type","required","default","enum","const","not","allOf","anyOf","oneOf","if","then","else","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","divisibleBy","items","maxItems","minItems","additionalItems","prefixItems","contains","minContains","maxContains","uniqueItems","maxLength","minLength","format","pattern","contentEncoding","contentMediaType","contentSchema","properties","maxProperties","minProperties","additionalProperties","patternProperties","propertyNames","dependencies","dependentRequired","dependentSchemas","propertyDependencies","unevaluatedProperties","unevaluatedItems","title","description","deprecated","readOnly","writeOnly","examples","$comment","example","discriminator","removeAdditional"],schemaVersions:["draft/next","draft/2020-12","draft/2019-09","draft-07","draft-06","draft-04","draft-03"].map((e=>`https://json-schema.org/${e}/schema`)),knownVocabularies:[...["core","applicator","validation","meta-data","format","content"].map((e=>`https://json-schema.org/draft/2019-09/vocab/${e}`)),...R.map((e=>`https://json-schema.org/draft/2020-12/vocab/${e}`))]};const{knownKeywords:C}=U;function D(e,t,r,n="keys"){if(!e.has(t))return e.set(t,r);if(e.get(t)!==r)throw new Error(`Conflicting duplicate ${n}: ${t}`)}function _(e,t,r){if("object"!=typeof e)throw new Error("Invalid input object");if("string"!=typeof t)throw new Error("Invalid JSON pointer");const n=t.split("/");if(!["","#"].includes(n.shift()))throw new Error("Invalid JSON pointer");if(0===n.length)return e;let s=e;for(const e of n){if("string"!=typeof e)throw new Error("Invalid JSON pointer");r&&r.push(s);const t=(o=e).includes("~")?o.replace(/~[01]/g,(e=>{switch(e){case"~1":return"/";case"~0":return"~"}throw new Error("Unreachable")})):o;if("object"!=typeof s)return;if(!Object.prototype.hasOwnProperty.call(s,t))return;s=s[t]}var o;return s}const L=/^https?:\/\//;function J(e,t){if("string"!=typeof e||"string"!=typeof t)throw new Error("Unexpected path!");if(0===t.length)return e;const r=e.replace(/#.*/,"");return t.startsWith("#")?`${r}${t}`:!r.includes("/")||L.test(t)?t:L.test(r)?`${new URL(t,r)}`:t.startsWith("/")?t:[...r.split("/").slice(0,-1),t].join("/")}function F(e){return e.map((e=>e&&(e.$id||e.id)||"")).filter((e=>e&&"string"==typeof e)).reduce(J,"")}const T=["properties","patternProperties","$defs","definitions"],V=["const","enum","examples","example","comment"],W=Symbol("skip");function K(e,t){const r=(e,n=!1)=>{if(!e||"object"!=typeof e)return;const s=t(e);if(void 0!==s)return s===W?void 0:s;for(const t of Object.keys(e)){if(!n&&!Array.isArray(e)&&!C.includes(t))continue;if(!n&&V.includes(t))continue;const s=r(e[t],!n&&T.includes(t));if(void 0!==s)return s}};return r(e)}const B=(e,t,r=!1)=>{if(!Array.isArray(t))throw new Error("Expected an array of schemas");for(const n of t)K(n,(t=>{const s=t.$id||t.id,o=s&&"string"==typeof s?s.replace(/#$/,""):null;if(o&&o.includes("://")&&!o.includes("#"))D(e,o,t,"schema $id in 'schemas'");else if(t===n&&!r)throw new Error("Schema with missing or invalid $id in 'schemas'")}));return e},H=(e,t)=>{if(t)return B(H(e),t,!0);if(e)switch(Object.getPrototypeOf(e)){case Object.prototype:return new Map(Object.entries(e));case Map.prototype:return new Map(e);case Array.prototype:return B(new Map,e)}throw new Error("Unexpected value for 'schemas' option")};var Z={get:_,joinPath:J,resolveReference:function e(t,r,n,s=""){const o=J(s,n),i=[],[a,c=""]=o.split("#"),l=decodeURI(c),u=(e,r,n=!1,s=!1)=>{if(!e||"object"!=typeof e)return;const c=e.$id||e.id;let p=r;if(c&&"string"==typeof c)if(p=J(p,c),p===o||p===a&&""===l)i.push([e,t,r]);else if(p===a&&"/"===l[0]){const n=[],s=_(e,l,n);void 0!==s&&i.push([s,t,J(r,F(n))])}const d=s?e.$dynamicAnchor:e.$anchor;if(d&&"string"==typeof d){if(d.includes("#"))throw new Error("$anchor can't include '#'");if(d.startsWith("/"))throw new Error("$anchor can't start with '/'");p=J(p,`#${d}`),p===o&&i.push([e,t,r])}for(const t of Object.keys(e))(n||Array.isArray(e)||C.includes(t))&&(!n&&V.includes(t)||u(e[t],p,!n&&T.includes(t)));!s&&e.$dynamicAnchor&&u(e,r,n,!0)};if(u(t,a),a===s.replace(/#$/,"")&&("/"===l[0]||""===l)){const e=[],r=_(t,l,e);void 0!==r&&i.push([r,t,F(e)])}if(r.has(a)&&r.get(a)!==t){const t=e(r.get(a),r,`#${c}`,a);i.push(...t.map((([e,t,r])=>[e,t,J(a,r)])))}return r.has(o)&&i.push([r.get(o),r.get(o),o]),i},getDynamicAnchors:function(e){const t=new Map;return K(e,(r=>{if(r!==e&&(r.$id||r.id))return W;const n=r.$dynamicAnchor;if(n&&"string"==typeof n){if(n.includes("#"))throw new Error("$dynamicAnchor can't include '#'");if(!/^[a-zA-Z0-9_-]+$/.test(n))throw new Error(`Unsupported $dynamicAnchor: ${n}`);D(t,n,r,"$dynamicAnchor")}})),t},hasKeywords:(e,t)=>K(e,(e=>Object.keys(e).some((e=>t.includes(e)))||void 0))||!1,buildSchemas:H};const Y={email:e=>{if(e.length>318)return!1;if(/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(e))return!0;if(!e.includes("@")||/(^\.|^"|\.@|\.\.)/.test(e))return!1;const[t,r,...n]=e.split("@");return!(!t||!r||0!==n.length||t.length>64||r.length>253)&&(!(!/^[a-z0-9.-]+$/i.test(r)||!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(t))&&r.split(".").every((e=>/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(e))))},hostname:e=>{if(e.length>(e.endsWith(".")?254:253))return!1;return/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i.test(e)},date:e=>{if(10!==e.length)return!1;if("0"===e[5]&&"2"===e[6]){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(e))return!0;const t=e.match(/^(\d\d\d\d)-02-29$/);if(!t)return!1;const r=0|t[1];return r%16==0||r%4==0&&r%25!=0}return e.endsWith("31")?/^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(e):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(e)},time:e=>{if(e.length>27)return!1;if(!/^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i.test(e))return!1;if(!/:60/.test(e))return!0;const t=e.match(/([0-9.]+|[^0-9.])/g);let r=60*Number(t[0])+Number(t[2]);return"+"===t[5]?r+=1440-60*Number(t[6]||0)-Number(t[8]||0):"-"===t[5]&&(r+=60*Number(t[6]||0)+Number(t[8]||0)),r%1440==1439},"date-time":e=>{if(e.length>38)return!1;const t="0"===e[5]&&"2"===e[6];if(t&&"3"===e[8]||!/^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i.test(e))return!1;if("6"===e[17]){const t=e.slice(11).match(/([0-9.]+|[^0-9.])/g);let r=60*Number(t[0])+Number(t[2]);if("+"===t[5]?r+=1440-60*Number(t[6]||0)-Number(t[8]||0):"-"===t[5]&&(r+=60*Number(t[6]||0)+Number(t[8]||0)),r%1440!=1439)return!1}if(t){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(e))return!0;const t=e.match(/^(\d\d\d\d)-02-29/);if(!t)return!1;const r=0|t[1];return r%16==0||r%4==0&&r%25!=0}return"3"===e[8]&&"1"===e[9]?/^\d\d\d\d-(?:0[13578]|1[02])-31/.test(e):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(e)},ipv4:e=>e.length<=15&&/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(e),ipv6:e=>{if(e.length>45||e.length<2)return!1;let t=0,r=0,n=0,s=!1,o=!1,i=0,a=!0;for(let c=0;c<e.length;c++){const l=e.charCodeAt(c);if(1===c&&58===i&&58!==l)return!1;if(l>=48&&l<=57){if(++n>4)return!1}else if(46===l){if(t>6||r>=3||0===n||o)return!1;r++,n=0}else if(58===l){if(r>0||t>=7)return!1;if(58===i){if(s)return!1;s=!0}else 0===c&&(a=!1);t++,n=0,o=!1}else{if(!(l>=97&&l<=102||l>=65&&l<=70))return!1;if(r>0)return!1;if(++n>4)return!1;o=!0}i=l}if(t<2||r>0&&(3!==r||0===n))return!1;if(s&&2===e.length)return!0;if(r>0&&!/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(e))return!1;const c=r>0?6:7;return s?(a||n>0)&&t<c:t===c&&a&&n>0},uri:/^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,"json-pointer":/^(?:|\/(?:[^~]|~0|~1)*)$/,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,uuid:/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,duration:e=>e.length>1&&e.length<80&&(/^P\d+([.,]\d+)?W$/.test(e)||/^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(e)&&/^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(e))};var G={core:Y,extra:{alpha:/^[a-zA-Z]+$/,alphanumeric:/^[a-zA-Z0-9]+$/,"hex-digits":/^[0-9a-f]+$/i,"hex-digits-prefixed":/^0x[0-9a-f]+$/i,"hex-bytes":/^([0-9a-f][0-9a-f])+$/i,"hex-bytes-prefixed":/^0x([0-9a-f][0-9a-f])+$/i,base64:e=>e.length%4==0&&/^[a-z0-9+/]*={0,3}$/i.test(e),"json-pointer-uri-fragment":/^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,"host-name":Y.hostname,"ip-address":Y.ipv4,color:/^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/},weak:{regex:e=>{if(e.length>1e5)return!1;if(/[^\\]\\Z/.test(e))return!1;try{return new RegExp(e,"u"),!0}catch(e){return!1}}}};const Q=(e,t)=>[...new Set([...e,...t])].sort(),X=(e,t)=>e.filter((e=>t.includes(e))),ee=e=>(...t)=>re(e(...t.map(re))),te=(e,t)=>e&&!e.includes(t),re=({type:e=null,dyn:t={},...r})=>({type:e?[...e].sort():e,items:te(e,"array")?1/0:r.items||0,properties:te(e,"object")?[!0]:[...r.properties||[]].sort(),patterns:te(e,"object")?[]:[...r.patterns||[]].sort(),required:te(e,"object")?[]:[...r.required||[]].sort(),fullstring:te(e,"string")||r.fullstring||!1,dyn:{item:!te(e,"array")&&(t.item||!1),items:te(e,"array")?0:Math.max(r.items||0,t.items||0),properties:te(e,"object")?[]:Q(r.properties||[],t.properties||[]),patterns:te(e,"object")?[]:Q(r.patterns||[],t.patterns||[])},unknown:r.unknown&&!(te(e,"object")&&te(e,"array"))||!1}),ne=ee(((e,t)=>({type:e.type&&t.type?X(e.type,t.type):e.type||t.type||null,items:Math.max(e.items,t.items),properties:Q(e.properties,t.properties),patterns:Q(e.patterns,t.patterns),required:Q(e.required,t.required),fullstring:e.fullstring||t.fullstring,dyn:{item:e.dyn.item||t.dyn.item,items:Math.max(e.dyn.items,t.dyn.items),properties:Q(e.dyn.properties,t.dyn.properties),patterns:Q(e.dyn.patterns,t.dyn.patterns)},unknown:e.unknown||t.unknown}))),se=(e,t)=>!0!==t&&new RegExp(e,"u").test(t),oe=({properties:e,patterns:t},{properties:r,patterns:n})=>{const s=e.filter((e=>r.includes(e)||r.includes(!0)||n.some((t=>se(t,e))))),o=r.filter((r=>e.includes(r)||e.includes(!0)||t.some((e=>se(e,r))))),i=t.filter((e=>n.includes(e)||r.includes(!0))),a=n.filter((r=>t.includes(r)||e.includes(!0)));return{properties:Q(s,o),patterns:Q(i,a)}},ie=({properties:e,patterns:t},{properties:r,patterns:n})=>r.every((r=>e.includes(r)||e.includes(!0)||t.some((e=>se(e,r)))))&&n.every((r=>t.includes(r)||e.includes(!0))),ae=ee(((e,t)=>({type:e.type&&t.type?Q(e.type,t.type):null,items:Math.min(e.items,t.items),...oe(e,t),required:te(e.type,"object")&&t.required||te(t.type,"object")&&e.required||X(e.required,t.required),fullstring:e.fullstring&&t.fullstring,dyn:{item:e.dyn.item||t.dyn.item,items:Math.max(e.dyn.items,t.dyn.items),properties:Q(e.dyn.properties,t.dyn.properties),patterns:Q(e.dyn.patterns,t.dyn.patterns)},unknown:e.unknown||t.unknown}))),ce=(le=({unknown:e,items:t,dyn:r,...n})=>({items:t!==1/0&&(e||r.items>t||r.item),properties:!n.properties.includes(!0)&&(e||!ie(n,r))}),(...e)=>le(...e.map(re)));var le,ue={initTracing:()=>re({}),andDelta:ne,orDelta:ae,applyDelta:(e,t)=>Object.assign(e,ne(e,t)),isDynamic:ce,inProperties:ie};const{format:pe,safe:de,safeand:fe,safenot:me,safenotor:ye}=l,he=I,{resolveReference:ge,joinPath:we,getDynamicAnchors:be,hasKeywords:$e}=Z,ve=G,{toPointer:je,...Oe}=h,{scopeMethods:xe}=d,{buildName:Ee,types:ke,jsHelpers:Ae}=A,{knownKeywords:Se,schemaVersions:ze,knownVocabularies:Me}=U,{initTracing:qe,andDelta:Ne,orDelta:Pe,applyDelta:Ie,isDynamic:Re,inProperties:Ue}=ue,Ce=new Set(["^[\\s\\S]*$","^[\\S\\s]*$","^[^]*$","",".*","^","$"]),De=["null","boolean","number","integer","string"],_e=new Map(Object.entries({boolean:e=>"boolean"==typeof e,array:e=>Array.isArray(e)&&Object.getPrototypeOf(e)===Array.prototype,object:e=>e&&Object.getPrototypeOf(e)===Object.prototype,finite:e=>Number.isFinite(e),natural:e=>Number.isInteger(e)&&e>=0,string:e=>"string"==typeof e,jsonval:e=>Oe.deepEqual(e,JSON.parse(JSON.stringify(e)))})),Le=_e.get("object"),Je=e=>Le(e)||"boolean"==typeof e,Fe=(e,t)=>ze.indexOf(e)>ze.indexOf(`https://json-schema.org/${t}/schema`),Te=(e,t)=>{const r=`${e}`.replace(/^http:\/\//,"https://").replace(/#$/,"");return!ze.includes(r)||Fe(r,t)},Ve=(e,t,r=!1,n=!1)=>Object.freeze({parent:e,keyname:t,inKeys:r,number:n}),We=Symbol("evaluatedStatic"),Ke=Symbol("optDynamic"),Be=Symbol("optDynAnchors"),He=Symbol("optRecAnchors"),Ze=new Set,Ye=new Map,Ge=(e,t,r,n,s="")=>{const{mode:o="default",useDefaults:i=!1,removeAdditional:a=!1,includeErrors:c=!1,allErrors:l=!1,contentValidation:u,dryRun:p,lint:d=!1,allowUnusedKeywords:f="lax"===r.mode||"spec"===r.mode,allowUnreachable:m="lax"===r.mode||"spec"===r.mode,requireSchema:y="strong"===r.mode,requireValidation:h="strong"===r.mode,requireStringValidation:g="strong"===r.mode,forbidNoopValues:w="strong"===r.mode,complexityChecks:b="strong"===r.mode,unmodifiedPrototypes:$=!1,isJSON:v=!1,$schemaDefault:j=null,formatAssertion:O="spec"!==r.mode||Te(t.$schema,"draft/2019-09"),formats:x={},weakFormats:E="strong"!==r.mode,extraFormats:k=!1,schemas:A,...S}=r,z={...ve.core,...E?ve.weak:{},...k?ve.extra:{},...x};if(0!==Object.keys(S).length)throw new Error(`Unknown options: ${Object.keys(S).join(", ")}`);if(!["strong","lax","default","spec"].includes(o))throw new Error(`Invalid mode: ${o}`);if(!c&&l)throw new Error("allErrors requires includeErrors to be enabled");if(y&&j)throw new Error("requireSchema forbids $schemaDefault");if("strong"===o){const e={...{requireValidation:h,requireStringValidation:g},formatAssertion:O,complexityChecks:b,requireSchema:y},t={weakFormats:E,allowUnusedKeywords:f};for(const[t,r]of Object.entries(e))if(!r)throw new Error(`Strong mode demands ${t}`);for(const[e,r]of Object.entries(t))if(r)throw new Error(`Strong mode forbids ${e}`)}const{gensym:M,getref:q,genref:N,genformat:P}=xe(n),I=N(e);let R=null;const U=(...e)=>{const t=R(...e);return U.errors=R.errors,t};n[I]=U;const C=$e(e,["$ref","$recursiveRef","$dynamicRef"]),D=r[Be]&&C&&$e(e,["$dynamicAnchor"]),_=r[He]?pe(", recursive"):pe(""),L=he();L.write("function validate(data%s%s) {",_,r[Be]?pe(D?", dynAnchors = []":", dynAnchors"):pe("")),c&&L.write("validate.errors = null"),l&&L.write("let errorCount = 0"),r[Ke]&&L.write("validate.evaluatedDynamic = null");let J=r[Be]?pe(", dynAnchors"):pe("");D&&(L.write("const dynLocal = [{}]"),J=pe(", [...dynAnchors, dynLocal[0] || []]"));const F=Ae(L,n,Ve,{unmodifiedPrototypes:$,isJSON:v},Ce),{present:T,forObjectKeys:V,forArray:W,patternTest:K,compare:B}=F,H=[],Z=()=>Ye.get(t),Y=s?[s]:[],G=(p,$,E,k,S,N={},{constProp:R}={})=>{const U=$.length>0&&$[$.length-1].prop===E,C=()=>$.filter((e=>e.prop===E)),_=!E.parent||E.checked||E.inKeys&&v||C().length>0,F=Ee(E),Q=(...e)=>((e,t,r=!1)=>Object.freeze({parent:e,keyval:t,checked:r}))(E,...e),X=({path:e=[],prop:t=E,source:r,suberr:s})=>{const o=je([...S,...e]),i=c?(e=>{const t=[];let r=e;for(;r;)r.name||t.unshift(r),r=r.parent||r.errorParent;if(t.every((e=>void 0!==e.keyval)))return pe("%j",je(t.map((e=>e.keyval))));const s=["#"],o=()=>{const e=s.map(Oe.pointerPart).join("/");return s.length=0,e};let i=null;for(const{keyname:e,keyval:r,number:a}of t)if(e){a||(n.pointerPart=Oe.pointerPart);const t=a?e:pe("pointerPart(%s)",e),r=`${o()}/`;i=i?pe("%s+%j+%s",i,r,t):pe("%j+%s",r,t)}else r&&s.push(r);return s.length>0?pe("%s+%j",i,`/${o()}`):i})(t):null;if(!0===c&&p&&r){n.errorMerge=Oe.errorMerge;const e=[r,o,i];l?(L.write("if (validate.errors === null) validate.errors = []"),L.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))",...e)):L.write("validate.errors = [errorMerge(%s[0], %j, %s)]",...e)}else if(!0===c&&p){const e=pe("{ keywordLocation: %j, instanceLocation: %s }",o,i);l?(L.write("if (%s === null) %s = []",p,p),L.write("%s.push(%s)",p,e)):L.write("%s = [%s]",p,e)}s&&xt(s),l?L.write("errorCount++"):L.write("return false")},ee=(e,t)=>L.if(e,(()=>X(t)));d&&!n.lintErrors&&(n.lintErrors=[]);const te=(t,r)=>{const o=void 0!==r?` ${JSON.stringify(r)}`:"",i=we(s,je(S)),a=`${t}${o} at ${i}`;if(d)return n.lintErrors.push({message:a,keywordLocation:i,schema:e});throw new Error(a)},re=(e,t)=>{try{return K(e,t)}catch(e){return te(e.message),pe("false")}},ne=(e,...t)=>e||te(...t),se=(e,...t)=>ne("lax"===o||"spec"===o||e,...t),oe=(e,t)=>se(!(k[t]<k[e]),`Invalid ${e} / ${t} combination`),ie=(e,t="should be specified")=>ne(!h,`[requireValidation] ${e} ${t}`),ae=(...e)=>[...S,...e],ce=e=>ne(!a&&!i,`[removeAdditional/useDefaults] uncertain: ${e}`),le=(e,t)=>ne(!b,`[complexityChecks] ${e}`,t),ue=e=>((e,t,r,n)=>{if(t){const n=t.replace(/^http:\/\//,"https://").replace(/#$/,"");r(ze.includes(n),"Unexpected schema version:",n),Ye.set(e,{exclusiveRefs:Fe(n,"draft/2019-09"),contentValidation:Fe(n,"draft/2019-09"),dependentUnsupported:Fe(n,"draft/2019-09"),newItemsSyntax:!Fe(n,"draft/2020-12"),containsEvaluates:!Fe(n,"draft/2020-12"),objectContains:!Fe(n,"draft/next"),bookending:Fe(n,"draft/next")})}else r(!n,"[requireSchema] $schema is required"),Ye.set(e,{})})(t,e||j,ne,y),he=qe(),$e=e=>Ie(he,e);if("boolean"==typeof k)return!0===k?(ie("schema = true","is not allowed"),{stat:he}):(ee(!(!_&&!E.inKeys)||T(E),{}),$e({type:[]}),{stat:he});ne(Le(k),"Schema is not an object");for(const e of Object.keys(k))ne(Se.includes(e)||f,"Keyword not supported:",e);if(0===Object.keys(k).length)return ie("empty rules node","is not allowed"),{stat:he};const xe=new Set(Object.keys(k)),Ae=new Set,Te=(e,...t)=>{ne(Ae.has(e)||xe.has(e),"Unexpected double consumption:",e),ne(Oe.hasOwn(k,e),"Is not an own property:",e),ne(t.every((e=>_e.has(e))),"Invalid type used in consume"),ne(t.some((t=>_e.get(t)(k[e]))),"Unexpected type for",e),xe.delete(e)},Ve=(e,...t)=>(void 0!==k[e]&&Te(e,...t),k[e]),Qe=(e,t,r,n={})=>{if(void 0===k[e])return!1;if(Te(e,...t),null!==r)try{const t=r(k[e]);null!==t&&ee(t,{path:[e],...n})}catch(e){if(!d||e.message.startsWith("[opt] "))throw e;te(e.message)}return!0};if(k===t?(ue(Ve("$schema","string")),Qe("$vocabulary",["object"],(e=>{for(const[t,r]of Object.entries(e))!1!==r&&ne(!0===r&&Me.includes(t),"Unknown vocabulary:",t);return null}))):Z()||ue(t.$schema),Z().objectContains)for(const e of["contains","minContains","maxContains"])Ae.add(e);Qe("examples",["array"],null),Qe("example",["jsonval"],null);for(const e of["title","description","$comment"])Qe(e,["string"],null);for(const e of["deprecated","readOnly","writeOnly"])Qe(e,["boolean"],null);Qe("$defs",["object"],null)||Qe("definitions",["object"],null);const Xe=(t,s,o)=>t===e?de("validate"):q(t)||Ge(t,s,r,n,o),et=()=>Y.length>0?Y[Y.length-1]:"",tt=Y.length,rt=e=>(Y.push(we(et(),e)),null);Z().exclusiveRefs&&k.$ref||(Qe("$id",["string"],rt)||Qe("id",["string"],rt),Qe("$anchor",["string"],null),Qe("$dynamicAnchor",["string"],null),!k.$recursiveAnchor&&w||Qe("$recursiveAnchor",["boolean"],(e=>(e&&H.push([k,t,et()]),null))));const nt=D&&(k===e||k.id||k.$id);if(nt){const r=be(k);k!==e&&L.write("dynLocal.unshift({})");for(const[e,n]of r){const r=ge(t,A,`#${e}`,et()),[s,o,i]=r[0]||[];ne(s===n,`Unexpected $dynamicAnchor resolution: ${e}`);const a=Xe(s,o,i);L.write("dynLocal[0][%j] = %s",`#${e}`,a)}}const st=t=>r[Ke]&&(k[t]||!1===k[t]||k===e),ot=Object.freeze({item:st("unevaluatedItems")?M("evaluatedItem"):null,items:st("unevaluatedItems")?M("evaluatedItems"):null,props:st("unevaluatedProperties")?M("evaluatedProps"):null}),it=Object.freeze({item:ot.item||N.item,items:ot.items||N.items,props:ot.props||N.props}),at=()=>(!it.items||he.items===1/0)&&(!it.props||he.properties.includes(!0)),ct=e=>{if(it.item&&e.item&&he.items!==1/0&&L.write("%s.push(%s)",it.item,e.item),it.items&&e.items>he.items&&L.write("%s.push(%d)",it.items,e.items),it.props&&(e.properties||[]).includes(!0)&&!he.properties.includes(!0))L.write("%s[0].push(true)",it.props);else if(it.props){const t=(e,t)=>Ue(he,{properties:e,patterns:t}),r=(e.properties||[]).filter((e=>!t([e],[]))),n=(e.patterns||[]).filter((e=>!t([],[e])));r.length>0&&L.write("%s[0].push(...%j)",it.props,r),n.length>0&&L.write("%s[1].push(...%j)",it.props,n);for(const t of e.propertiesVars||[])L.write("%s[0].push(%s)",it.props,t)}},lt=(e,t,r,n)=>{Re(he).items&&e.item&&t&&L.write("%s.push(...%s)",e.item,t),Re(he).items&&e.items&&r&&L.write("%s.push(...%s)",e.items,r),Re(he).properties&&e.props&&n&&(L.write("%s[0].push(...%s[0])",e.props,n),L.write("%s[1].push(...%s[1])",e.props,n))},ut=(e,t)=>{const s=n[e]&&n[e][We]||{unknown:!0};$e(s);const o=pe("%s(%s%s%s)",e,F,r[He]?0===H.length?pe(", recursive"):pe(", recursive || %s",Xe(...H[0])):pe(""),J);if(!c&&at())return pe("!%s",o);const i=M("res"),a=M("err"),l=M("suberr");return c&&L.write("const %s = validate.errors",a),L.write("const %s = %s",i,o),c&&L.write("const %s = %s.errors",l,e),c&&L.write("validate.errors = %s",a),ee(me(i),{...t,source:l}),L.if(i,(()=>{const t=Re(s).items?pe("%s.evaluatedDynamic[0]",e):null,r=Re(s).items?pe("%s.evaluatedDynamic[1]",e):null,n=Re(s).properties?pe("%s.evaluatedDynamic[2]",e):null;lt(it,t,r,n)})),null},pt=(e,t)=>e&&e.every((e=>t.includes(e))),dt=(e,t)=>t.some((t=>null===e||e.includes(t))),ft=(...e)=>C().some((t=>pt(t.stat.type,e))),mt=(...e)=>dt(he.type,e)&&C().every((t=>dt(t.stat.type,e))),yt=(e,t=k)=>{ne("string"==typeof e,"Invalid pattern:",e),(h||g)&&ne(/^\^.*\$$/.test(e),"Should start with ^ and end with $:",e),/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(e)&&void 0===t.maxLength&&le("maxLength should be specified for pattern:",e)},ht=k.pattern&&!Ce.has(k.pattern),gt=k.uniqueItems||ht||k.patternProperties||k.format,wt=l&&gt?M("prev"):null,bt=(e,t)=>L.if(!e||null===wt||pe("errorCount === %s",wt),t),$t=()=>[...$,{stat:he,prop:E}],vt=(...e)=>G(p,$t(),...e).stat,jt=(e,...t)=>{if(t[0]===E){const e=(e=>"boolean"==typeof e?e:!(!Le(e)||0!==Object.keys(e).length)||void 0)(t[1]);if(!0===e)return{sub:pe("true"),delta:{}};if(!1===e)return{sub:pe("false"),delta:{type:[]}}}const r=M("sub");L.write("const %s = (() => {",r),l&&L.write("let errorCount = 0");const{stat:n}=G(e,$t(),...t);return l?L.write("return errorCount === 0"):L.write("return true"),L.write("})()"),{sub:r,delta:n}},Ot=()=>{const e=c&&l?M("suberr"):null;return e&&L.write("let %s = null",e),e},xt=e=>{null!==p&&null!==e&&L.if(e,(()=>L.write("%s.push(...%s)",p,e)))},Et=()=>{if(!a)return!1;if(!0===a)return!0;if("keyword"===a)return!!k.removeAdditional&&(Te("removeAdditional","boolean"),!0);throw new Error(`Invalid removeAdditional: ${a}`)},kt=(e,t,r)=>{Qe(e,["object","boolean"],(n=>!1===n&&Et()?(L.write("if (%s.length > %s) %s.length = %s",F,t,F,t),null):!1!==n||r?(W(E,t,((t,s)=>(r&&L.write("if (%s) continue",r(s)),vt(t,n,ae(e))))),null):pe("%s.length > %s",F,t)))&&$e({items:1/0})},At=(e,t)=>{Qe(e,["object","boolean"],(r=>(V(E,((n,s)=>{L.if(t(s),(()=>{!1===r&&Et()?L.write("delete %s[%s]",F,s):vt(n,r,ae(e))}))})),null)))&&$e({properties:[!0]})},St=(e,t,r)=>fe(...t.map((t=>pe("%s !== %j",e,t))),...r.map((t=>me(re(t,e))))),zt=(e,t)=>{const r=t.map((e=>new RegExp(e,"u"))),n=t=>e.includes(t)||r.some((e=>e.test(t)));for(const e of he.required)ne(n(e),"Unknown required property:",e)},Mt=[],qt=()=>{const e=(e,t)=>pe("!(%d %c %s)",e,t,F);Number.isFinite(k.exclusiveMinimum)?Qe("exclusiveMinimum",["finite"],(t=>e(t,"<"))):(Qe("minimum",["finite"],(t=>e(t,k.exclusiveMinimum?"<":"<="))),Qe("exclusiveMinimum",["boolean"],null)),Number.isFinite(k.exclusiveMaximum)?(Qe("exclusiveMaximum",["finite"],(t=>e(t,">"))),oe("minimum","exclusiveMaximum"),oe("exclusiveMinimum","exclusiveMaximum")):void 0!==k.maximum&&(Qe("maximum",["finite"],(t=>e(t,k.exclusiveMaximum?">":">="))),Qe("exclusiveMaximum",["boolean"],null),oe("minimum","maximum"),oe("exclusiveMinimum","maximum"));const t=void 0===k.multipleOf?"divisibleBy":"multipleOf";Qe(t,["finite"],(e=>{ne(e>0,`Invalid ${t}:`,e);const[r,s]=`${e}`.split("e-"),o=`${r}.`.split(".")[1].length+(s?Number(s):0);if(Number.isInteger(e*2**o))return pe("%s %% %d !== 0",F,e);n.isMultipleOf=Oe.isMultipleOf;const i=[F,e,o,Math.round(e*Math.pow(10,o))];return pe("!isMultipleOf(%s, %d, 1e%d, %d)",...i)}))},Nt=()=>{Qe("maxLength",["natural"],(e=>(n.stringLength=Oe.stringLength,pe("%s.length > %d && stringLength(%s) > %d",F,e,F,e)))),Qe("minLength",["natural"],(e=>(n.stringLength=Oe.stringLength,pe("%s.length < %d || stringLength(%s) < %d",F,e,F,e)))),oe("minLength","maxLength"),bt(!0,(()=>{const e=(e,t,r=z)=>{const n="string"==typeof e&&Oe.hasOwn(r,e);ne(n,"Unrecognized format used:",e);const s=r[e],o=s instanceof RegExp||"function"==typeof s;return ne(o,"Invalid format used:",e),O?s instanceof RegExp?(Oe.hasOwn(x,e)&&yt(s.source),pe("!%s.test(%s)",P(s),t)):pe("!%s(%s)",P(s),t):null};Qe("format",["string"],(t=>($e({fullstring:!0}),e(t,F)))),Qe("pattern",["string"],(e=>(yt(e),$e({fullstring:!0}),Ce.has(e)?null:me(re(e,F))))),ne(!1!==k.contentSchema,"contentSchema cannot be set to false");const t=void 0===u?Z().contentValidation:u,r=k.contentEncoding||k.contentMediaType||k.contentSchema;if(ne(!r||t||f,'"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)'),r&&t){const t=M("dec");k.contentMediaType&&L.write("let %s = %s",t,F),"base64"===k.contentEncoding?(ee(e("base64",F,ve.extra),{path:["contentEncoding"]}),k.contentMediaType&&(n.deBase64=Oe.deBase64,L.write("try {"),L.write("%s = deBase64(%s)",t,t)),Te("contentEncoding","string")):ne(!k.contentEncoding,"Unknown contentEncoding:",k.contentEncoding);let r=!1;if("application/json"===k.contentMediaType?(L.write("try {"),L.write("%s = JSON.parse(%s)",t,t),r=!0,Te("contentMediaType","string")):ne(!k.contentMediaType,"Unknown contentMediaType:",k.contentMediaType),k.contentSchema){ne(r,"contentSchema requires contentMediaType application/json");const e=Object.freeze({name:t,errorParent:E});vt(e,k.contentSchema,ae("contentSchema")),Te("contentSchema","object","array"),$e({fullstring:!0})}k.contentMediaType&&(L.write("} catch (e) {"),X({path:["contentMediaType"]}),L.write("}"),k.contentEncoding&&(L.write("} catch (e) {"),X({path:["contentEncoding"]}),L.write("}")))}}))},Pt=()=>{Qe("maxItems",["natural"],(e=>{const t=Z().newItemsSyntax?"prefixItems":"items";return Array.isArray(k[t])&&k[t].length>e&&te(`Invalid maxItems: ${e} is less than ${t} array length`),pe("%s.length > %d",F,e)})),Qe("minItems",["natural"],(e=>pe("%s.length < %d",F,e))),oe("minItems","maxItems");const e=e=>{for(let t=0;t<e.length;t++)vt(Q(t),e[t],ae(`${t}`));return $e({items:e.length}),null};Z().newItemsSyntax?(Qe("prefixItems",["array"],e),kt("items",pe("%d",(k.prefixItems||[]).length))):Array.isArray(k.items)?(Qe("items",["array"],e),kt("additionalItems",pe("%d",k.items.length))):Qe("items",["object","boolean"],(e=>(W(E,pe("0"),(t=>vt(t,e,ae("items")))),$e({items:1/0}),null))),Ut((e=>{W(E,pe("0"),((t,r)=>{e(t,(()=>{$e({dyn:{item:!0}}),ct({item:r})}))}))}));const r=e=>{if(!Le(e))return!1;if(e.enum||Oe.hasOwn(e,"const"))return!0;if(e.type){if((Array.isArray(e.type)?e.type:[e.type]).every((e=>De.includes(e))))return!0}if(e.$ref){const[n]=ge(t,A,e.$ref,et())[0]||[];if(r(n))return!0}return!1},s=e=>!1===e||r(e);bt(!0,(()=>{Qe("uniqueItems",["boolean"],(e=>!1===e?null:(void 0!==k.maxItems||s(k.items)||Array.isArray(k.items)&&s(k.additionalItems)||le("maxItems should be specified for non-primitive uniqueItems"),Object.assign(n,{unique:Oe.unique,deepEqual:Oe.deepEqual}),pe("!unique(%s)",F))))}))},It=e=>!l&&(he.required.includes(e)||C().some((t=>t.stat.required.includes(e)))),Rt=()=>{const e=pe("Object.keys(%s).length",F);Qe("maxProperties",["natural"],(t=>pe("%s > %d",e,t))),Qe("minProperties",["natural"],(t=>pe("%s < %d",e,t))),oe("minProperties","maxProperties"),Qe("propertyNames",["object","boolean"],(e=>(V(E,((t,r)=>{const n="object"!=typeof e||e.$ref?e:{type:"string",...e},s=Object.freeze({name:r,errorParent:t,type:"string"});vt(s,n,ae("propertyNames"))})),null))),Qe("required",["array"],(e=>{for(const t of e){if(It(t))continue;const e=Q(t);ee(me(T(e)),{path:["required"],prop:e})}return $e({required:e}),null}));for(const e of["dependencies","dependentRequired","dependentSchemas"])"dependencies"!==e&&Z().dependentUnsupported||Qe(e,["object"],(t=>{for(const r of Object.keys(t)){const n="string"==typeof t[r]?[t[r]]:t[r],s=Q(r,It(r));if(Array.isArray(n)&&"dependentSchemas"!==e){const t=n.filter((e=>!It(e))).map((e=>T(Q(e)))),o=me(fe(...t)),i={path:[e,r]};0===t.length||(s.checked?(ee(o,i),$e({required:n})):ee(fe(T(s),o),i))}else Je(n)&&"dependentRequired"!==e?(ce(e),L.if(!!s.checked||T(s),(()=>{const t=vt(E,n,ae(e,r),it);$e(Pe({},t)),ct(t)}))):te(`Unexpected ${e} entry`)}return null}));Qe("propertyDependencies",["object"],(e=>{for(const[t,r]of Object.entries(e)){ne(Le(r),"propertyDependencies must be an object"),ce("propertyDependencies");const e=Q(t,It(t));L.if(!!e.checked||T(e),(()=>{for(const[n,s]of Object.entries(r))ne(Je(s),"propertyDependencies must contain schemas"),L.if(B(Ee(e),n),(()=>{const e=vt(E,s,ae("propertyDependencies",t,n),it);$e(Pe({},e)),ct(e)}))}))}return null})),Qe("properties",["object"],(e=>{for(const t of Object.keys(e))R!==t&&vt(Q(t,It(t)),e[t],ae("properties",t));return $e({properties:Object.keys(e)}),null})),bt(k.patternProperties,(()=>{if(Qe("patternProperties",["object"],(e=>(V(E,((t,r)=>{for(const n of Object.keys(e))yt(n,k.propertyNames||{}),L.if(re(n,r),(()=>{vt(t,e[n],ae("patternProperties",n))}))})),$e({patterns:Object.keys(e)}),null))),k.additionalProperties||!1===k.additionalProperties){const e=Object.keys(k.properties||{}),t=Object.keys(k.patternProperties||{});!1===k.additionalProperties&&Mt.push((()=>zt(e,t)));At("additionalProperties",(r=>St(r,e,t)))}})),Z().objectContains&&Ut((e=>{V(E,((t,r)=>{e(t,(()=>{$e({dyn:{properties:[!0]}}),ct({propertiesVars:[r]})}))}))}))},Ut=e=>{Qe("contains",["object","boolean"],(()=>{ce("contains"),Z().objectContains&&mt("array")&&mt("object")&&ie("possible type confusion in 'contains',","forbid 'object' or 'array'");const t=M("passes");L.write("let %s = 0",t);const r=Ot();return e(((e,n)=>{const{sub:s}=jt(r,e,k.contains,ae("contains"));L.if(s,(()=>{L.write("%s++",t),Z().containsEvaluates&&(ne(!a,'Can\'t use removeAdditional with draft2020+ "contains"'),n())}))})),Qe("minContains",["natural"],(e=>pe("%s < %d",t,e)),{suberr:r})||ee(pe("%s < 1",t),{path:["contains"],suberr:r}),Qe("maxContains",["natural"],(e=>pe("%s > %d",t,e))),oe("minContains","maxContains"),null}))},Ct=()=>{Qe("not",["object","boolean"],(e=>jt(null,E,e,ae("not")).sub)),k.not&&ce("not");(k.then||!1===k.then||k.else||!1===k.else||f)&&Qe("if",["object","boolean"],(e=>{ce("if/then/else");const{sub:t,delta:r}=jt(null,E,e,ae("if"),it);let n,s,o,i;var a;return Qe("else",["object","boolean"],(e=>(n=()=>{o=vt(E,e,ae("else"),it),ct(o)},null))),Qe("then",["object","boolean"],(e=>(s=()=>{i=vt(E,e,ae("then"),it),ct(Ne(r,i))},null))),s||(a=r,Oe.deepEqual(a,{type:[]}))||(s=()=>ct(r)),L.if(t,s,n),$e(Pe(o||{},Ne(r,i||{}))),null}));const e=(e,t="allOf")=>{ne(e.length>0,`${t} cannot be empty`);for(const[r,n]of Object.entries(e))$e(vt(E,n,ae(t,r),it));return null};Qe("allOf",["array"],(t=>e(t)));let r=null;Qe("discriminator",["object"],(e=>{const n=new Set,s=(e,t,r)=>ne(e,`[discriminator]: ${t}`,r),{propertyName:o,mapping:i,...a}=e,c=Q(o);s(o&&!k.oneOf!=!k.anyOf,"need propertyName, oneOf OR anyOf"),s(0===Object.keys(a).length,'only "propertyName" and "mapping" are supported');return r=(e,r)=>{const a=()=>{let a;L.write("switch (%s) {",Ee(c));for(const[c,l]of Object.entries(e)){const{const:e,enum:u,...p}=(l.properties||{})[o]||{};let d=void 0!==e?[e]:u;if(!d&&l.$ref){const[e]=ge(t,A,l.$ref,et())[0]||[];ne(Le(e),"failed to resolve $ref:",l.$ref);const r=(e.properties||{})[o]||{};d=void 0!==r.const?[r.const]:r.enum}const f=Array.isArray(d)&&d.length>0;s(f,"branches should have unique string const or enum values for [propertyName]");const m=!(0!==Object.keys(p).length||e&&u);s(m,"only const OR enum rules are allowed on [propertyName] in branches");for(const e of d){const t=!i||Oe.hasOwn(i,e)&&i[e]===l.$ref;s(t,"mismatching mapping for",e);const r="string"==typeof e&&!n.has(e);s(r,"const/enum values for [propertyName] should be unique strings"),n.add(e),L.write("case %j:",e)}const y=vt(E,l,ae(r,c),it,{constProp:o});ct(y),a=a?Pe(a,y):y,L.write("break")}var l;s(void 0===i||(Le(l=i)?Object.keys(l).length:null)===n.size,"mismatching mapping size"),$e(a),L.write("default:"),X({path:[r]}),L.write("}")},u=()=>{if(It(o))a();else{const e=["discriminator","propertyName"];L.if(T(c),a,(()=>X({path:e,prop:c})))}};return l||!Oe.deepEqual(he.type,["object"])?L.if(ke.get("object")(F),u,(()=>X({path:["discriminator"]}))):u(),s(Oe.deepEqual(he.type,["object"]),"has to be checked for type:","object"),s(he.required.includes(o),"propertyName should be placed in required:",o),null},null}));const n=(e,t)=>{const r=t.map((e=>e.type||(Array.isArray(e.const)?"array":typeof e.const))),n=r.filter((e=>!De.includes(e)&&"array"!==e)).length,s=r.filter((e=>!De.includes(e)&&"object"!==e)).length;(n>1||s>1)&&ce(`${e}, use discriminator to make it certain`)};Qe("anyOf",["array"],(t=>{if(ne(t.length>0,"anyOf cannot be empty"),1===t.length)return e(t);if(r)return r(t,"anyOf");const s=Ot();if(!at()){n("anyOf",t);const e=Object.entries(t).map((([e,t])=>jt(s,E,t,ae("anyOf",e),it)));$e(e.map((e=>e.delta)).reduce(((e,t)=>Pe(e,t)))),ee(ye(...e.map((({sub:e})=>e))),{path:["anyOf"],suberr:s});for(const{delta:t,sub:r}of e)L.if(r,(()=>ct(t)));return null}const o=t.filter((e=>Oe.hasOwn(e,"const"))),i=t.filter((e=>!Oe.hasOwn(e,"const")));n("anyOf",i);const a=[...o,...i];let c;if(Z().exclusiveRefs){let e=()=>X({path:["anyOf"],suberr:s});for(const[t,r]of Object.entries(a).reverse()){const n=e;e=()=>{const{sub:e,delta:o}=jt(s,E,r,ae("anyOf",t));L.if(me(e),n),c=c?Pe(c,o):o}}e()}else{const e=Object.entries(t).map((([e,t])=>jt(s,E,t,ae("anyOf",e),it)));c=e.map((e=>e.delta)).reduce(((e,t)=>Pe(e,t))),ee(ye(...e.map((({sub:e})=>e))),{path:["anyOf"],suberr:s})}return $e(c),null})),Qe("oneOf",["array"],(t=>{if(ne(t.length>0,"oneOf cannot be empty"),1===t.length)return e(t);if(r)return r(t,"oneOf");n("oneOf",t);const s=M("passes");L.write("let %s = 0",s);const o=Ot();let i,a=0;const l=Object.entries(t).map((([e,t])=>{!c&&a++>1&&ee(pe("%s > 1",s),{path:["oneOf"]});const r=jt(o,E,t,ae("oneOf",e),it);return L.if(r.sub,(()=>L.write("%s++",s))),i=i?Pe(i,r.delta):r.delta,r}));$e(i),ee(pe("%s !== 1",s),{path:["oneOf"]}),L.if(pe("%s === 0",s),(()=>xt(o)));for(const e of l)L.if(e.sub,(()=>ct(e.delta)));return null}))},Dt=(e,t,r)=>{const[n,s]=[L.size(),xe.size];L.if(!!((...e)=>pt(he.type,e)||ft(...e))(...t)||r,e),n===L.size()&&s===xe.size||ne(mt(...t),"Unexpected rules in type",k.type)},_t=()=>{if(he.items===1/0)!1===k.unevaluatedItems&&Te("unevaluatedItems","boolean");else if(k.unevaluatedItems||!1===k.unevaluatedItems)if(Re(he).items){if(!r[Ke])throw new Error("[opt] Dynamic unevaluated tracing not enabled");const e=pe("Math.max(%d, ...%s)",he.items,it.items),t=e=>pe("%s.includes(%s)",it.item,e);kt("unevaluatedItems",e,Z().containsEvaluates?t:null)}else kt("unevaluatedItems",pe("%d",he.items))},Lt=()=>{bt(he.patterns.length>0||he.dyn.patterns.length>0||he.unknown,(()=>{if(he.properties.includes(!0))!1===k.unevaluatedProperties&&Te("unevaluatedProperties","boolean");else if(k.unevaluatedProperties||!1===k.unevaluatedProperties){const e=e=>St(e,he.properties,he.patterns);if(Re(he).properties){if(!r[Ke])throw new Error("[opt] Dynamic unevaluated tracing not enabled");n.propertyIn=Oe.propertyIn;const t=e=>pe("!propertyIn(%s, %s)",e,it.props);At("unevaluatedProperties",(r=>fe(e(r),t(r))))}else!1===k.unevaluatedProperties&&zt(he.properties,he.patterns),At("unevaluatedProperties",e)}}))},Jt=()=>{if(null!==wt&&L.write("const %s = errorCount",wt),(()=>{const e=Qe("const",["jsonval"],(e=>me(B(F,e))));if(e&&!f)return!0;const t=Qe("enum",["array"],(e=>{const t=e.filter((e=>e&&"object"==typeof e)),r=e.filter((e=>!(e&&"object"==typeof e)));return ye(...[...r,...t].map((e=>B(F,e))))}));return e||t})()){const e=[...ke.keys()];if($e({properties:[!0],items:1/0,type:e,fullstring:!0}),!f)return void ne(0===xe.size,"Unexpected keywords mixed with const or enum:",[...xe])}Dt(qt,["number","integer"],ke.get("number")(F)),Dt(Nt,["string"],ke.get("string")(F)),Dt(Pt,["array"],ke.get("array")(F)),Dt(Rt,["object"],ke.get("object")(F)),Ct(),Dt(_t,["array"],ke.get("array")(F)),Dt(Lt,["object"],ke.get("object")(F));for(const e of Mt)e();lt(N,ot.item,ot.items,ot.props)},Ft=()=>{if(ot.item&&L.write("const %s = []",ot.item),ot.items&&L.write("const %s = [0]",ot.items),ot.props&&L.write("const %s = [[], []]",ot.props),Qe("$ref",["string"],(r=>{const s=ge(t,A,r,et()),[o,i,a]=s[0]||[];if(!o&&!1!==o&&(te("failed to resolve $ref:",r),d))return null;const c=Xe(o,i,a),l=o===e?I:c;if(!n[l])throw new Error("Unexpected: coherence check failed");if(!n[l][We]&&o.type){const e=Array.isArray(o.type)?o.type:[o.type];$e({type:e}),h&&(Ze.add(l),e.includes("array")&&$e({items:1/0}),e.includes("object")&&$e({properties:[!0]})),g&&e.includes("string")&&(Ze.add(l),$e({fullstring:!0}))}return ut(c,{path:["$ref"]})})),Z().exclusiveRefs&&(ne(!r[Ke],"unevaluated* is supported only on draft2019-09 and above"),k.$ref))return;Qe("$recursiveRef",["string"],(e=>{if(!r[He])throw new Error("[opt] Recursive anchors are not enabled");ne("#"===e,'Behavior of $recursiveRef is defined only for "#"');const n=ge(t,A,"#",et()),[s,o,i]=n[0];se(s.$recursiveAnchor,"$recursiveRef without $recursiveAnchor");const a=Xe(s,o,i),c=s.$recursiveAnchor?pe("(recursive || %s)",a):a;return ut(c,{path:["$recursiveRef"]})})),Qe("$dynamicRef",["string"],(e=>{if(!r[Be])throw new Error("[opt] Dynamic anchors are not enabled");se(/^[^#]*#[a-zA-Z0-9_-]+$/.test(e),"Unsupported $dynamicRef format");const s=e.replace(/^[^#]+/,""),o=ge(t,A,e,et());if(!o[0]&&!Z().bookending){se(!1,"$dynamicRef bookending resolution failed (even though not required)"),n.dynamicResolve=Oe.dynamicResolve;const e=pe("dynamicResolve(dynAnchors || [], %j)",s);return ut(e,{path:["$dynamicRef"]})}ne(o[0],"$dynamicRef bookending resolution failed",e);const[i,a,c]=o[0],l=i.$dynamicAnchor&&`#${i.$dynamicAnchor}`===s;se(l,"$dynamicRef without $dynamicAnchor in the same scope");const u=Xe(i,a,c);n.dynamicResolve=Oe.dynamicResolve;const p=l?pe("(dynamicResolve(dynAnchors || [], %j) || %s)",s,u):u;return ut(p,{path:["$dynamicRef"]})}));let s=null;Qe("type",["string","array"],(e=>{const t=Array.isArray(e)?e:[e];for(const e of t)ne("string"==typeof e&&ke.has(e),"Unknown type:",e);if(E.type)return ne(Oe.deepEqual(t,[E.type]),"One type allowed:",E.type),$e({type:[E.type]}),null;if(ft(...t))return null;const r=t.filter((e=>mt(e)));return 0===r.length&&te("No valid types possible"),$e({type:t}),s=ye(...r.map((e=>ke.get(e)(F)))),null})),s&&l?L.if(s,(()=>X({path:["type"]})),Jt):(s&&ee(s,{path:["type"]}),Jt()),he.items<1/0&&k.maxItems<=he.items&&$e({items:1/0})};if(void 0!==k.default&&i){_&&te("Can not apply default value here (e.g. at root)");const e=Ve("default","jsonval");L.if(T(E),Ft,(()=>L.write("%s = %j",F,e)))}else Qe("default",["jsonval"],null),L.if(!!_||T(E),Ft);if(Y.length=tt,H[0]&&H[H.length-1][0]===k&&H.pop(),nt&&k!==e&&L.write("dynLocal.shift()"),m||ne(!L.optimizedOut,"some checks are never reachable"),U){const e=["not","if","then","else"].includes(S[S.length-1]),t=["oneOf","anyOf","allOf"].includes(S[S.length-2]),r=["dependencies","dependentSchemas"].includes(S[S.length-2]),n=["propertyDependencies"].includes(S[S.length-3]);ne(e||t||r||n,"Unexpected logical path")}else if(!S.includes("not")){if((!(e!==t&&k===e)||Ze.has(I))&&(Ze.delete(I),he.type||ie("type"),mt("array")&&he.items!==1/0&&ie(k.items?"additionalItems or unevaluatedItems":"items rule"),mt("object")&&!he.properties.includes(!0)&&ie("additionalProperties or unevaluatedProperties"),!he.fullstring&&g)){te(`[requireStringValidation] ${"pattern, format or contentSchema should be specified for strings"}, use pattern: ^[\\s\\S]*$ to opt-out`)}if("object"!=typeof k.propertyNames)for(const e of["additionalProperties","unevaluatedProperties"])k[e]&&ie(`wild-card ${e}`,"requires propertyNames")}return k.properties&&!k.required&&ie("if properties is used, required"),ne(0===xe.size||f,"Unprocessed keywords:",[...xe]),{stat:he,local:ot}},{stat:Q,local:X}=G(pe("validate.errors"),[],{name:de("data")},e,[]);if(Ze.has(I))throw new Error("Unexpected: unvalidated cyclic ref");if(r[Ke]&&(Re(Q).items||Re(Q).properties)){if(!X)throw new Error("Failed to trace dynamic properties");L.write("validate.evaluatedDynamic = [%s, %s, %s]",X.item,X.items,X.props)}return l?L.write("return errorCount === 0"):L.write("return true"),L.write("}"),d||(R=L.makeFunction(n),delete n[I],n[I]=R),n[I][We]=Q,I},Qe=(e,t)=>{if(!Array.isArray(e))throw new Error("Expected an array of schemas");try{const r=Object.create(null),{getref:n}=xe(r);Ze.clear(),Ye.clear();const s=e.map((e=>n(e)||Ge(e,e,t,r)));if(0!==Ze.size)throw new Error("Unexpected: not all refs are validated");return{scope:r,refs:s}}catch(r){if(!t[Ke]&&"[opt] Dynamic unevaluated tracing not enabled"===r.message)return Qe(e,{...t,[Ke]:!0});if(!t[Be]&&"[opt] Dynamic anchors are not enabled"===r.message)return Qe(e,{...t,[Be]:!0});if(!t[He]&&"[opt] Recursive anchors are not enabled"===r.message)return Qe(e,{...t,[He]:!0});throw r}finally{Ze.clear(),Ye.clear()}};var Xe={compile:Qe};const et=I,{buildSchemas:tt}=Z,{compile:rt}=Xe,{deepEqual:nt}=h,st=e=>function t(r){if(!nt(r,JSON.parse(JSON.stringify(r))))return t.errors=[{instanceLocation:"#",error:"not JSON compatible"}],!1;const n=e(r);return t.errors=e.errors,n},ot=e=>t=>nt(t,JSON.parse(JSON.stringify(t)))&&e(t),it=(e,{parse:t=!1,multi:r=!1,jsonCheck:n=!1,isJSON:s=!1,schemas:o=[],...i}={})=>{if(n&&s)throw new Error("Can not specify both isJSON and jsonCheck options");if(t&&(n||s))throw new Error("jsonCheck and isJSON options are not applicable in parser mode");const a=s||n||t,c=r?e:[e],l={mode:t?"strong":"default",...i,schemas:tt(o,c),isJSON:a},{scope:u,refs:p}=rt(c,l);if(i.dryRun)return;if(i.lint)return u.lintErrors;const d=et();if(t?u.parseWrap=i.includeErrors?at:ct:n&&(u.deepEqual=nt,u.jsonCheckWrap=i.includeErrors?st:ot),r){d.write("[");for(const e of p.slice(0,-1))d.write("%s,",e);p.length>0&&d.write("%s",p[p.length-1]),d.write("]"),t?d.write(".map(parseWrap)"):n&&d.write(".map(jsonCheckWrap)")}else t?d.write("parseWrap(%s)",p[0]):n?d.write("jsonCheckWrap(%s)",p[0]):d.write("%s",p[0]);const f=d.makeFunction(u);return f.toModule=({semi:e=!0}={})=>d.makeModule(u)+(e?";":""),f.toJSON=()=>e,f},at=e=>t=>{if("string"!=typeof t)return{valid:!1,error:"Input is not a string"};try{const r=JSON.parse(t);if(!e(r)){const{keywordLocation:t,instanceLocation:r}=e.errors[0],n=t.slice(t.lastIndexOf("/")+1);return{valid:!1,error:`JSON validation failed for ${n} at ${r}`,errors:e.errors}}return{valid:!0,value:r}}catch({message:e}){return{valid:!1,error:e}}},ct=e=>t=>{if("string"!=typeof t)return{valid:!1};try{const r=JSON.parse(t);return e(r)?{valid:!0,value:r}:{valid:!1}}catch(e){return{valid:!1}}};var lt={validator:it,parser:function(e,{parse:t=!0,...r}={}){if(!t)throw new Error("can not disable parse in parser");return it(e,{parse:t,...r})},lint:function(e,{lint:t=!0,...r}={}){if(!t)throw new Error("can not disable lint option in lint()");return it(e,{lint:t,...r})}};export{lt as s};
