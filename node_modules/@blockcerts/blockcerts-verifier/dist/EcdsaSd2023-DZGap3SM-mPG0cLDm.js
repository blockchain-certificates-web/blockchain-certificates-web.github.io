import{d as e,f as t,V as r}from"./main.js";import{j as n,e as o,d as i}from"./index-Chj6rFU_-DwRdQV-L.js";import{j as a}from"./jsonld-CkyvX_Vg-C61cS9xX.js";import{d as s,e as u}from"./base64url-Cy03LJLt-vkTPfQOh.js";import{f as c}from"./index-ByRXJxEU-CtZ_5kyD.js";import{S as f}from"./Suite-B7Vy9AuU-D1ucdMDB.js";import"./pako.esm-DnD5dZGi-Bw1vqMku.js";import"./sha256-Dr-8c5iF-C1PUWFZm.js";import"./index-CgNQmXGo-Dgus2xdV.js";import{r as d}from"./retrieveVerificationMethodPublicKey-Dz3Z2B9t-C2YmGxIc.js";import"./elliptic-Bf4jfo3V-BRLTdj5Y.js";
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */
const l=globalThis.crypto;
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */function h({algorithm:e="sha256"}={}){if("sha256"!==e)throw new Error(`Unsupported algorithm "${e}".`);return{hash:async e=>new Uint8Array(await l.subtle.digest("SHA-256",e))}}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */const p=new TextEncoder;function y(e){return p.encode(e)}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */async function g({document:e,labelMapFactoryFunction:t,options:r}={}){const{nquads:n}=await async function({document:e,nquads:t,labelMapFactoryFunction:r,options:n}={}){let o,i=new Map;o=e?await w(e,{...n,canonicalIdMap:i}):await w(t.join(""),{...n,inputFormat:"application/n-quads",canonicalIdMap:i});i=function(e){let t=!1;const r=new Map;for(const[n,o]of e){if(!t&&(t=!0,!n.startsWith("_:")))return e;r.set(n.slice(2),o.slice(2))}return r}(i);const a=await r({canonicalIdMap:i}),s=new Map;for(const[e,t]of a)s.set(i.get(e),t);const u=(e,t,r)=>"_:"+s.get(r);return{nquads:o.split("\n").slice(0,-1).map((e=>e.replace(/(_:([^\s]+))/g,u)+"\n")).sort(),labelMap:a}}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */({document:e,labelMapFactoryFunction:t,options:r});return n}async function w(e,t){if(!t||"object"!=typeof t)throw new TypeError('"options" must be an object.');return a.canonize(e,{algorithm:"URDNA2015",format:"application/n-quads",safe:!0,...t})}async function m({document:e,proof:t,options:r,hasher:n}={}){n||(n=h());const o=await async function({document:e,proof:t,options:r}={}){return delete(t={"@context":e["@context"],...t}).proofValue,w(t,r)}({document:e,proof:t,options:r});return n.hash(y(o))}const b=["string","number","bigint","symbol"],v=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function E(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(b.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";const r=function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(v.includes(t))return t;return}(e);return r||"Object"}class A{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}A.uint=new A(0,"uint",!0),A.negint=new A(1,"negint",!0),A.bytes=new A(2,"bytes",!0),A.string=new A(3,"string",!0),A.array=new A(4,"array",!1),A.map=new A(5,"map",!1),A.tag=new A(6,"tag",!1),A.float=new A(7,"float",!0),A.false=new A(7,"false",!0),A.true=new A(7,"true",!0),A.null=new A(7,"null",!0),A.undefined=new A(7,"undefined",!0),A.break=new A(7,"break",!0);class S{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const $=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,T=new TextDecoder,M=new TextEncoder;function U(e){return $&&globalThis.Buffer.isBuffer(e)}const V=$?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):x(e,t,r):(e,t,r)=>r-t>64?T.decode(e.subarray(t,r)):x(e,t,r),I=$?e=>e.length>64?globalThis.Buffer.from(e):k(e):e=>e.length>64?M.encode(e):k(e),j=$?(e,t,r)=>U(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r);function k(e){const t=[];let r=0;for(let n=0;n<e.length;n++){let o=e.charCodeAt(n);o<128?t[r++]=o:o<2048?(t[r++]=o>>6|192,t[r++]=63&o|128):55296==(64512&o)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++n)),t[r++]=o>>18|240,t[r++]=o>>12&63|128,t[r++]=o>>6&63|128,t[r++]=63&o|128):(t[r++]=o>>12|224,t[r++]=o>>6&63|128,t[r++]=63&o|128)}return t}function x(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,a=o>239?4:o>223?3:o>191?2:1;if(t+a<=r){let r,n,s,u;switch(a){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(u=(31&o)<<6|63&r,u>127&&(i=u));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(u=(15&o)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(i=u));break;case 4:r=e[t+1],n=e[t+2],s=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&s)&&(u=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&s,u>65535&&u<1114112&&(i=u))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=a}return function(e){const t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=B));return r}(n)}const B=4096;const D="CBOR decode error:",P="CBOR encode error:";function N(e,t,r){if(e.length-t<r)throw new Error(`${D} not enough data for type`)}const L=[24,256,65536,4294967296,BigInt("18446744073709551616")];function C(e,t,r){N(e,t,1);const n=e[t];if(!0===r.strict&&n<L[0])throw new Error(`${D} integer encoded in more bytes than necessary (strict decode)`);return n}function _(e,t,r){N(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<L[1])throw new Error(`${D} integer encoded in more bytes than necessary (strict decode)`);return n}function K(e,t,r){N(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<L[2])throw new Error(`${D} integer encoded in more bytes than necessary (strict decode)`);return n}function F(e,t,r){N(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<L[3])throw new Error(`${D} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${D} integers outside of the safe integer range are not supported`)}function z(e,t){return q(e,0,t.value)}function q(e,t,r){if(r<L[0]){const n=Number(r);e.push([t|n])}else if(r<L[1]){const n=Number(r);e.push([24|t,n])}else if(r<L[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<L[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<L[4]))throw new Error(`${D} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}z.encodedSize=function(e){return q.encodedSize(e.value)},q.encodedSize=function(e){return e<L[0]?1:e<L[1]?2:e<L[2]?3:e<L[3]?5:9},z.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const O=BigInt(-1),H=BigInt(1);function G(e,t){const r=t.value,n="bigint"==typeof r?r*O-H:-1*r-1;q(e,t.type.majorEncoded,n)}function R(e,t,r,n){N(e,t,r+n);const o=j(e,t+r,t+r+n);return new S(A.bytes,o,r+n)}function J(e,t,r,n){return R(e,t,1,r)}function W(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===A.string?I(e.value):e.value),e.encodedBytes}function X(e,t){const r=W(t);q(e,t.type.majorEncoded,r.length),e.push(r)}function Z(e,t,r,n,o){const i=r+n;N(e,t,i);const a=new S(A.string,V(e,t+r,t+i),i);return!0===o.retainStringBytes&&(a.byteValue=j(e,t+r,t+i)),a}function Q(e,t,r,n){return Z(e,t,1,r,n)}G.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*O-H:-1*t-1;return r<L[0]?1:r<L[1]?2:r<L[2]?3:r<L[3]?5:9},G.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},X.encodedSize=function(e){const t=W(e);return q.encodedSize(t.length)+t.length},X.compareTokens=function(e,t){return r=W(e),n=W(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(U(e)&&U(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const Y=X;function ee(e,t,r,n){return new S(A.array,n,r)}function te(e,t,r,n){return ee(0,0,1,r)}function re(e,t){q(e,A.array.majorEncoded,t.value)}function ne(e,t,r,n){return new S(A.map,n,r)}function oe(e,t,r,n){return ne(0,0,1,r)}function ie(e,t){q(e,A.map.majorEncoded,t.value)}function ae(e,t,r,n){return new S(A.tag,r,1)}function se(e,t){q(e,A.tag.majorEncoded,t.value)}re.compareTokens=z.compareTokens,re.encodedSize=function(e){return q.encodedSize(e.value)},ie.compareTokens=z.compareTokens,ie.encodedSize=function(e){return q.encodedSize(e.value)},se.compareTokens=z.compareTokens,se.encodedSize=function(e){return q.encodedSize(e.value)};function ue(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${D} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${D} Infinity values are not supported`)}return new S(A.float,e,t)}function ce(e,t,r){const n=t.value;if(!1===n)e.push([20|A.float.majorEncoded]);else if(!0===n)e.push([21|A.float.majorEncoded]);else if(null===n)e.push([22|A.float.majorEncoded]);else if(void 0===n)e.push([23|A.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(he(n),t=pe(le,1),n===t||Number.isNaN(n)?(le[0]=249,e.push(le.slice(0,3)),i=!0):(ye(n),t=ge(le,1),n===t&&(le[0]=250,e.push(le.slice(0,5)),i=!0))),i||(o=n,de.setFloat64(0,o,!1),t=we(le,1),le[0]=251,e.push(le.slice(0,9)))}var o}ce.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){he(r);let e=pe(le,1);if(r===e||Number.isNaN(r))return 3;if(ye(r),e=ge(le,1),r===e)return 5}return 9};const fe=new ArrayBuffer(9),de=new DataView(fe,1),le=new Uint8Array(fe,0);function he(e){if(e===1/0)de.setUint16(0,31744,!1);else if(e===-1/0)de.setUint16(0,64512,!1);else if(Number.isNaN(e))de.setUint16(0,32256,!1);else{de.setFloat32(0,e);const t=de.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)de.setUint16(0,31744,!1);else if(0===r)de.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?de.setUint16(0,0):e<-14?de.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):de.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function pe(e,t){if(e.length-t<2)throw new Error(`${D} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function ye(e){de.setFloat32(0,e,!1)}function ge(e,t){if(e.length-t<4)throw new Error(`${D} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function we(e,t){if(e.length-t<8)throw new Error(`${D} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function me(e,t,r){throw new Error(`${D} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function be(e){return()=>{throw new Error(`${D} ${e}`)}}ce.compareTokens=z.compareTokens;const ve=[];for(let e=0;e<=23;e++)ve[e]=me;ve[24]=function(e,t,r,n){return new S(A.uint,C(e,t+1,n),2)},ve[25]=function(e,t,r,n){return new S(A.uint,_(e,t+1,n),3)},ve[26]=function(e,t,r,n){return new S(A.uint,K(e,t+1,n),5)},ve[27]=function(e,t,r,n){return new S(A.uint,F(e,t+1,n),9)},ve[28]=me,ve[29]=me,ve[30]=me,ve[31]=me;for(let e=32;e<=55;e++)ve[e]=me;ve[56]=function(e,t,r,n){return new S(A.negint,-1-C(e,t+1,n),2)},ve[57]=function(e,t,r,n){return new S(A.negint,-1-_(e,t+1,n),3)},ve[58]=function(e,t,r,n){return new S(A.negint,-1-K(e,t+1,n),5)},ve[59]=function(e,t,r,n){const o=F(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new S(A.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${D} integers outside of the safe integer range are not supported`);return new S(A.negint,O-BigInt(o),9)},ve[60]=me,ve[61]=me,ve[62]=me,ve[63]=me;for(let e=64;e<=87;e++)ve[e]=J;ve[88]=function(e,t,r,n){return R(e,t,2,C(e,t+1,n))},ve[89]=function(e,t,r,n){return R(e,t,3,_(e,t+1,n))},ve[90]=function(e,t,r,n){return R(e,t,5,K(e,t+1,n))},ve[91]=function(e,t,r,n){const o=F(e,t+1,n);if("bigint"==typeof o)throw new Error(`${D} 64-bit integer bytes lengths not supported`);return R(e,t,9,o)},ve[92]=me,ve[93]=me,ve[94]=me,ve[95]=be("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)ve[e]=Q;ve[120]=function(e,t,r,n){return Z(e,t,2,C(e,t+1,n),n)},ve[121]=function(e,t,r,n){return Z(e,t,3,_(e,t+1,n),n)},ve[122]=function(e,t,r,n){return Z(e,t,5,K(e,t+1,n),n)},ve[123]=function(e,t,r,n){const o=F(e,t+1,n);if("bigint"==typeof o)throw new Error(`${D} 64-bit integer string lengths not supported`);return Z(e,t,9,o,n)},ve[124]=me,ve[125]=me,ve[126]=me,ve[127]=be("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)ve[e]=te;ve[152]=function(e,t,r,n){return ee(0,0,2,C(e,t+1,n))},ve[153]=function(e,t,r,n){return ee(0,0,3,_(e,t+1,n))},ve[154]=function(e,t,r,n){return ee(0,0,5,K(e,t+1,n))},ve[155]=function(e,t,r,n){const o=F(e,t+1,n);if("bigint"==typeof o)throw new Error(`${D} 64-bit integer array lengths not supported`);return ee(0,0,9,o)},ve[156]=me,ve[157]=me,ve[158]=me,ve[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${D} indefinite length items not allowed`);return ee(0,0,1,1/0)};for(let e=160;e<=183;e++)ve[e]=oe;ve[184]=function(e,t,r,n){return ne(0,0,2,C(e,t+1,n))},ve[185]=function(e,t,r,n){return ne(0,0,3,_(e,t+1,n))},ve[186]=function(e,t,r,n){return ne(0,0,5,K(e,t+1,n))},ve[187]=function(e,t,r,n){const o=F(e,t+1,n);if("bigint"==typeof o)throw new Error(`${D} 64-bit integer map lengths not supported`);return ne(0,0,9,o)},ve[188]=me,ve[189]=me,ve[190]=me,ve[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${D} indefinite length items not allowed`);return ne(0,0,1,1/0)};for(let e=192;e<=215;e++)ve[e]=ae;ve[216]=function(e,t,r,n){return new S(A.tag,C(e,t+1,n),2)},ve[217]=function(e,t,r,n){return new S(A.tag,_(e,t+1,n),3)},ve[218]=function(e,t,r,n){return new S(A.tag,K(e,t+1,n),5)},ve[219]=function(e,t,r,n){return new S(A.tag,F(e,t+1,n),9)},ve[220]=me,ve[221]=me,ve[222]=me,ve[223]=me;for(let e=224;e<=243;e++)ve[e]=be("simple values are not supported");ve[244]=me,ve[245]=me,ve[246]=me,ve[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${D} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new S(A.null,null,1):new S(A.undefined,void 0,1)},ve[248]=be("simple values are not supported"),ve[249]=function(e,t,r,n){return ue(pe(e,t+1),3,n)},ve[250]=function(e,t,r,n){return ue(ge(e,t+1),5,n)},ve[251]=function(e,t,r,n){return ue(we(e,t+1),9,n)},ve[252]=me,ve[253]=me,ve[254]=me,ve[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${D} indefinite length items not allowed`);return new S(A.break,void 0,1)};const Ee=[];for(let e=0;e<24;e++)Ee[e]=new S(A.uint,e,1);for(let e=-1;e>=-24;e--)Ee[31-e]=new S(A.negint,e,1);Ee[64]=new S(A.bytes,new Uint8Array(0),1),Ee[96]=new S(A.string,"",1),Ee[128]=new S(A.array,0,1),Ee[160]=new S(A.map,0,1),Ee[244]=new S(A.false,!1,1),Ee[245]=new S(A.true,!0,1),Ee[246]=new S(A.null,null,1),function(){const e=[];e[A.uint.major]=z,e[A.negint.major]=G,e[A.bytes.major]=X,e[A.string.major]=Y,e[A.array.major]=re,e[A.map.major]=ie,e[A.tag.major]=se,e[A.float.major]=ce}();class Ae{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${P} object contains circular references`);return new Ae(t,e)}}const Se={null:new S(A.null,null),undefined:new S(A.undefined,void 0),true:new S(A.true,!0),false:new S(A.false,!1),emptyArray:new S(A.array,0),emptyMap:new S(A.map,0)},$e={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new S(e>=0?A.uint:A.negint,e):new S(A.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new S(A.uint,e):new S(A.negint,e),Uint8Array:(e,t,r,n)=>new S(A.bytes,e),string:(e,t,r,n)=>new S(A.string,e),boolean:(e,t,r,n)=>e?Se.true:Se.false,null:(e,t,r,n)=>Se.null,undefined:(e,t,r,n)=>Se.undefined,ArrayBuffer:(e,t,r,n)=>new S(A.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new S(A.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[Se.emptyArray,new S(A.break)]:Se.emptyArray;n=Ae.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=Te(t,r,n);return r.addBreakTokens?[new S(A.array,e.length),o,new S(A.break)]:[new S(A.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),a=o?e.size:i.length;if(!a)return!0===r.addBreakTokens?[Se.emptyMap,new S(A.break)]:Se.emptyMap;n=Ae.createCheck(n,e);const s=[];let u=0;for(const t of i)s[u++]=[Te(t,r,n),Te(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(s,r),r.addBreakTokens?[new S(A.map,a),s,new S(A.break)]:[new S(A.map,a),s]}};$e.Map=$e.Object,$e.Buffer=$e.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))$e[`${e}Array`]=$e.DataView;function Te(e,t={},r){const n=E(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||$e[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=$e[n];if(!i)throw new Error(`${P} unsupported type: ${n}`);return i(e,n,t,r)}const Me={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Ue{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=Ee[e];if(void 0===t){const r=ve[e];if(!r)throw new Error(`${D} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const n=31&e;t=r(this.data,this._pos,n,this.options)}return this._pos+=t.encodedLength,t}}const Ve=Symbol.for("DONE"),Ie=Symbol.for("BREAK");function je(e,t){if(e.done())return Ve;const r=e.next();if(r.type===A.break)return Ie;if(r.type.terminal)return r.value;if(r.type===A.array)return function(e,t,r){const n=[];for(let o=0;o<e.value;o++){const i=je(t,r);if(i===Ie){if(e.value===1/0)break;throw new Error(`${D} got unexpected break to lengthed array`)}if(i===Ve)throw new Error(`${D} found array but not enough entries (got ${o}, expected ${e.value})`);n[o]=i}return n}(r,e,t);if(r.type===A.map)return function(e,t,r){const n=!0===r.useMaps,o=n?void 0:{},i=n?new Map:void 0;for(let a=0;a<e.value;a++){const s=je(t,r);if(s===Ie){if(e.value===1/0)break;throw new Error(`${D} got unexpected break to lengthed map`)}if(s===Ve)throw new Error(`${D} found map but not enough entries (got ${a} [no key], expected ${e.value})`);if(!0!==n&&"string"!=typeof s)throw new Error(`${D} non-string keys not supported (got ${typeof s})`);if(!0===r.rejectDuplicateMapKeys&&(n&&i.has(s)||!n&&s in o))throw new Error(`${D} found repeat map key "${s}"`);const u=je(t,r);if(u===Ve)throw new Error(`${D} found map but not enough entries (got ${a} [no value], expected ${e.value})`);n?i.set(s,u):o[s]=u}return n?i:o}(r,e,t);if(r.type===A.tag){if(t.tags&&"function"==typeof t.tags[r.value]){const n=je(e,t);return t.tags[r.value](n)}throw new Error(`${D} tag not supported (${r.value})`)}throw new Error("unsupported")}function ke(e,t){const[r,n]=function(e,t){if(!(e instanceof Uint8Array))throw new Error(`${D} data to decode must be a Uint8Array`);const r=(t=Object.assign({},Me,t)).tokenizer||new Ue(e,t),n=je(r,t);if(n===Ve)throw new Error(`${D} did not find any content to decode`);if(n===Ie)throw new Error(`${D} got unexpected break`);return[n,e.subarray(r.pos())]}(e,t);if(n.length>0)throw new Error(`${D} too many terminals, data makes no sense`);return r}
/*!
 * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.
 */const xe=new Uint8Array([217,93,1]),Be=[];function De({proof:e}={}){try{if("string"!=typeof e?.proofValue)throw new TypeError('"proof.proofValue" must be a string.');if("u"!==e.proofValue[0])throw new Error("Only base64url multibase encoding is supported.");const t=s(e.proofValue.slice(1));if(!function(e,t){for(let r=0;r<t.length;++r)if(e[r]!==t[r])return!1;return!0}(t,xe))throw new TypeError('"proof.proofValue" must be a derived proof.');const r=t.subarray(xe.length),[n,o,i,a,c]=ke(r,{useMaps:!0,tags:Be}),f=function(e){const t=new Map;for(const[r,n]of e.entries())t.set(`c14n${r}`,`u${u(n)}`);return t}(a),d={baseSignature:n,publicKey:o,signatures:i,labelMap:f,mandatoryIndexes:c};return function({baseSignature:e,publicKey:t,signatures:r,labelMap:n,mandatoryIndexes:o}){if(!(e instanceof Uint8Array&&64===e.length))throw new TypeError('"baseSignature" must be a Uint8Array of length 64.');if(!(t instanceof Uint8Array&&35===t.length))throw new TypeError('"publicKey" must be a Uint8Array of length 35.');if(!Array.isArray(r)||!r.every((e=>e instanceof Uint8Array)))throw new TypeError('"signatures" must be an array of Uint8Arrays.');if(!(n instanceof Map&&[...n.entries()].every((([e,t])=>"string"==typeof e&&"string"==typeof t))))throw new TypeError('"labelMap" must be a Map of strings to strings.');if(!Array.isArray(o)||!o.every(Number.isInteger))throw new TypeError('"mandatoryIndexes" must be an array of integers.')}(d),d}catch(e){const t=new TypeError('The proof does not include a valid "proofValue" property.');throw t.cause=e,t}}function Pe({proofHash:e,publicKey:t,mandatoryHash:r}={}){!function({proofHash:e,publicKey:t,mandatoryHash:r}){if(!(e instanceof Uint8Array&&32===e.length))throw new TypeError('"proofHash" must be a Uint8Array of length 32.');if(!(t instanceof Uint8Array&&35===t.length))throw new TypeError('"publicKey" must be a Uint8Array of length 35.');if(!(r instanceof Uint8Array&&32===r.length))throw new TypeError('"mandatoryHash" must be a Uint8Array of length 32.')}({proofHash:e,publicKey:t,mandatoryHash:r});return function(e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;for(const n of e)t.set(n,r),r+=n.length;return t}([e,t,r])}Be[64]=function(e){return e}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */;const Ne="ecdsa-sd-2023";
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */
function Le({requiredAlgorithm:e="P-256"}={}){return{name:Ne,requiredAlgorithm:e,createVerifier:Ce,createVerifyData:_e}}async function Ce({verificationMethod:e}){const t=(await c(e)).verifier();return{algorithm:t.algorithm,id:t.id,verify:async({data:e})=>async function({verifier:e,data:t}={}){const{baseSignature:r,proofHash:n,publicKey:i,signatures:a,nonMandatory:s,mandatoryHash:u}=t,f="z"+o(i),d=await c({publicKeyMultibase:f});if(a.length!==s.length)throw new Error(`Signature count (${a.length}) does not match non-mandatory message count (${s.length}).`);const{verify:l}=d.verifier();if((await Promise.all(a.map(((e,t)=>l({data:y(s[t]),signature:e}))))).some((e=>!e)))return!1;const h=await Pe({proofHash:n,publicKey:i,mandatoryHash:u});return e.verify({data:h,signature:r})}
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */({verifier:t,data:e})}}async function _e({cryptosuite:e,document:t,proof:r,documentLoader:n}){if(e?.name!==Ne)throw new TypeError(`"cryptosuite.name" must be "${Ne}".`);const o={documentLoader:n},i=m({document:t,proof:r,options:o}).catch((e=>e)),{baseSignature:a,publicKey:s,signatures:u,labelMap:c,mandatoryIndexes:f}=await De({proof:r}),d=await function({labelMap:e}={}){return async({canonicalIdMap:t})=>{const r=new Map;for(const[n,o]of t)r.set(n,e.get(o));return r}}({labelMap:c}),l=await g({document:t,labelMapFactoryFunction:d,options:o}),p=[],w=[];for(const[e,t]of l.entries())f.includes(e)?p.push(t):w.push(t);const{mandatoryHash:b}=await async function({mandatory:e,hasher:t}={}){return t||(t=h()),{mandatoryHash:await t.hash(y(e.join("")))}}({mandatory:p}),v=await i;if(v instanceof Error)throw v;return{baseSignature:a,proofHash:v,publicKey:s,signatures:u,nonMandatory:w,mandatoryHash:b}}const Ke=self&&(self.crypto||self.msCrypto);async function Fe({string:e}){const t=(new TextEncoder).encode(e);return new Uint8Array(await Ke.subtle.digest("SHA-256",t))}
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */const{suites:{LinkedDataProof:ze}}=n;class qe extends ze{constructor({signer:e,date:t,cryptosuite:r,legacyContext:n=!1}={}){super({type:"DataIntegrityProof"});const{canonize:o,createVerifier:i,name:a,requiredAlgorithm:s,derive:u,createProofValue:c,createVerifyData:f}=r;if(!i||"function"!=typeof i)throw new TypeError('"cryptosuite.createVerifier" must be a function.');if(u&&"function"!=typeof u)throw new TypeError('"cryptosuite.derive" must be a function.');if(c&&"function"!=typeof c)throw new TypeError('"cryptosuite.createProofValue" must be a function.');if(f&&"function"!=typeof f)throw new TypeError('"cryptosuite.createVerifyData" must be a function.');if(this.contextUrl="https://w3id.org/security/data-integrity/v2",n&&(this.contextUrl="https://w3id.org/security/data-integrity/v1"),this.canonize=o,this.createVerifier=i,this.cryptosuite=a,this._cryptosuite=r,this.requiredAlgorithm=s,t){if(this.date=new Date(t),isNaN(this.date))throw TypeError(`"date" "${t}" is not a valid date.`)}else null===t&&(this.date=null);const d=function({signer:e,requiredAlgorithm:t}){const r={verificationMethod:void 0,signer:void 0};if(!e)return r;if("function"!=typeof e.sign)throw new TypeError("A signer API has not been specified.");const n=Array.isArray(t)?t.includes(e.algorithm):t===e.algorithm;if(!n){const r=Array.isArray(t)?t.join(", "):t,n=Array.isArray(t)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${r}".`:`does not match the required algorithm for the cryptosuite "${r}".`,o=`The signer's algorithm "${e.algorithm}" ${n}`;throw new Error(o)}return r.signer=e,r.verificationMethod=e.id,r}({signer:e,requiredAlgorithm:s});this.verificationMethod=d.verificationMethod,this.signer=d.signer}async sign({verifyData:e,proof:t}){if(!this.signer||"function"!=typeof this.signer.sign)throw new Error("A signer API has not been specified.");const r=await this.signer.sign({data:e});return t.proofValue="z"+o(r),t}async verifySignature({verifyData:e,verificationMethod:t,proof:r}){const n=await this.createVerifier({verificationMethod:t});if(!(Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.includes(n.algorithm):this.requiredAlgorithm===n.algorithm)){const e=Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.join(", "):this.requiredAlgorithm,t=Array.isArray(this.requiredAlgorithm)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${e}".`:`does not match the required algorithm for the cryptosuite "${e}".`,r=`The verifier's algorithm "${n.algorithm}" ${t}`;throw new Error(r)}const{proofValue:o}=r;if(!o||"string"!=typeof o)throw new TypeError('The proof does not include a valid "proofValue" property.');const a=o[0];let u;if("z"===a)u=i(o.slice(1));else{if("u"!==a)throw new Error("Only base58btc or base64url multibase encoding is supported.");u=s(o.slice(1))}return n.verify({data:e,signature:u})}async createProof({document:e,purpose:t,proofSet:r,documentLoader:n}){let o;o=this.proof?{...this.proof}:{},o.type=this.type;let i,a=this.date;return void 0===o.created&&void 0===a&&(a=new Date),a&&"string"!=typeof a&&(a=(e=>(null==e?e=new Date:"number"!=typeof e&&"string"!=typeof e||(e=new Date(e)),e.toISOString().slice(0,-5)+"Z"))(a)),a&&(o.created=a),o.verificationMethod=this.verificationMethod,o.cryptosuite=this.cryptosuite,o=await this.updateProof({document:e,proof:o,purpose:t,proofSet:r,documentLoader:n}),o=await t.update(o,{document:e,suite:this,documentLoader:n}),i=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:e,proof:o,proofSet:r,documentLoader:n,dataIntegrityProof:this}):await this.createVerifyData({document:e,proof:o,proofSet:r,documentLoader:n}),this._cryptosuite.createProofValue?o.proofValue=await this._cryptosuite.createProofValue({cryptosuite:this._cryptosuite,verifyData:i,document:e,proof:o,proofSet:r,documentLoader:n,dataIntegrityProof:this}):o=await this.sign({verifyData:i,document:e,proof:o,proofSet:r,documentLoader:n}),o}async derive({document:e,purpose:t,proofSet:r,documentLoader:n}){if(!this._cryptosuite.derive)throw new Error('"cryptosuite.derive" not provided.');return this._cryptosuite.derive({cryptosuite:this._cryptosuite,document:e,purpose:t,proofSet:r,documentLoader:n,dataIntegrityProof:this})}async updateProof({proof:e}){return e}async verifyProof({proof:e,proofSet:t,document:r,documentLoader:n}){try{let o;o=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:r,proof:e,proofSet:t,documentLoader:n,dataIntegrityProof:this}):await this.createVerifyData({document:r,proof:e,proofSet:t,documentLoader:n});const i=await this.getVerificationMethod({proof:e,documentLoader:n});if(!await this.verifySignature({verifyData:o,verificationMethod:i,proof:e}))throw new Error("Invalid signature.");return{verified:!0,verificationMethod:i}}catch(e){return{verified:!1,error:e}}}async createVerifyData({document:e,proof:t,documentLoader:r}){let n;const{_hashCache:o}=this;o&&o.document===e?n=o.hash:this._hashCache={document:e,hash:n=this.canonize(e,{documentLoader:r}).then((e=>Fe({string:e})))};const[i,a]=await Promise.all([this.canonizeProof(t,{document:e,documentLoader:r}).then((e=>Fe({string:e}))),n]);return((e,t)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),r})(i,a)}async getVerificationMethod({proof:e,documentLoader:t}){let{verificationMethod:r}=e;if("object"==typeof r&&(r=r.id),!r)throw new Error('No "verificationMethod" found in proof.');const n=await t(r);if(!n)throw new Error(`Unable to load verification method "${r}".`);const{document:o}=n;return r="string"==typeof o?JSON.parse(o):o,r}async canonizeProof(e,{documentLoader:t,document:r}){return e={"@context":r["@context"],...e},this.ensureSuiteContext({document:e,addSuiteContext:!0}),delete e.proofValue,this.canonize(e,{documentLoader:t,skipExpansion:!1})}async matchProof({proof:e}){const{type:t,cryptosuite:r}=e;return t===this.type&&r===this.cryptosuite}ensureSuiteContext({document:e,addSuiteContext:t}){const{contextUrl:r}=this;if(Oe({document:e,contextUrl:r})||Oe({document:e,contextUrl:"https://www.w3.org/ns/credentials/v2"}))return;if(!t)throw new TypeError(`The document to be signed must contain this suite's @context, "${r}".`);const n=e["@context"]||[];e["@context"]=Array.isArray(n)?[...n,r]:[n,r]}}function Oe({document:e,contextUrl:t}){const r=e["@context"];return r===t||Array.isArray(r)&&r.includes(t)}const{purposes:{AssertionProofPurpose:He}}=n;var Ge;!function(e){e.retrieveVerificationMethodPublicKey="retrieveVerificationMethodPublicKey",e.checkDocumentSignature="checkDocumentSignature"}(Ge||(Ge={}));class Re extends f{verificationProcess=[Ge.retrieveVerificationMethodPublicKey,Ge.checkDocumentSignature];documentToVerify;issuer;proof;type="EcdsaSd2023";cryptosuite="ecdsa-sd-2023";publicKey;verificationKey;constructor(e){super(e),e.executeStep&&(this.executeStep=e.executeStep),this.documentToVerify=e.document,this.issuer=e.issuer,this.proof=e.proof,this.validateProofType()}async init(){}async verifyProof(){for(const e of this.verificationProcess){if(!this[e])return void console.error("verification logic for",e,"not implemented");await this[e]()}}async verifyIdentity(){}getProofVerificationSteps(t){return this.verificationProcess.map((r=>e.verifier.convertToVerificationSubsteps(t,r)))}getIdentityVerificationSteps(){return[]}getIssuerPublicKey(){return this.publicKey}getIssuerName(){return this.issuer.name??""}getIssuerProfileDomain(){try{return new URL(this.getIssuerProfileUrl()).hostname??""}catch(e){return""}}getIssuerProfileUrl(){return this.issuer.id??""}getSigningDate(){return this.proof.created}async executeStep(e,t,r){throw new Error("doAction method needs to be overwritten by injecting from CVJS")}validateProofType(){const e=this.proof.type;if("DataIntegrityProof"!==e){if(e!==this.type)throw new Error(`Incompatible proof type passed. Expected: ${this.type}, Got: ${e}`)}else{const e=this.proof.cryptosuite;if(!e)throw new Error(`Malformed proof passed. With DataIntegrityProof a cryptosuite must be defined. Expected: ${this.cryptosuite}`);if(e!==this.cryptosuite)throw new Error(`Incompatible proof cryptosuite passed. Expected: ${this.cryptosuite}, Got: ${e}`)}}generateDocumentLoader(e=[]){e.forEach((e=>{t[e.url]=e.value})),t[this.documentToVerify.issuer]=this.getTargetVerificationMethodContainer();return function(e){return e in t?{contextUrl:null,document:t[e],documentUrl:e}:a.documentLoader(e)}}getErrorMessage(e){return e.results[0].error.cause.message}getTargetVerificationMethodContainer(){return this.issuer.didDocument??this.issuer}async retrieveVerificationMethodPublicKey(){this.verificationKey=await this.executeStep(Ge.retrieveVerificationMethodPublicKey,(async()=>{const e=d(this.getTargetVerificationMethodContainer(),this.proof.verificationMethod);if(!e)throw new r(Ge.retrieveVerificationMethodPublicKey,"Could not derive the verification key");if(e.revoked)throw new r(Ge.retrieveVerificationMethodPublicKey,"The verification key has been revoked");return e}),this.type)}async checkDocumentSignature(){await this.executeStep(Ge.checkDocumentSignature,(async()=>{const e=new qe({cryptosuite:Le({requiredAlgorithm:"K-256"})}),t=this.documentToVerify.proof.verificationMethod,o=await n.verify(this.documentToVerify,{suite:e,purpose:new He,documentLoader:this.generateDocumentLoader([{url:t,value:this.verificationKey}])});if(!o.verified)throw console.error(JSON.stringify(o,null,2)),new r(Ge.checkDocumentSignature,`The document's ${this.type} signature could not be confirmed: ${this.getErrorMessage(o)}`);console.log(`Credential ${this.type} signature successfully verified`)}),this.type)}}export{Re as default};
