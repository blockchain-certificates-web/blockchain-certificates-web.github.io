import{d as e,f as t,V as r}from"./main.js";import{j as n,r as o}from"./jsonld-signatures-ZtLxJmqT-B0W14Jb0.js";import{j as i}from"./jsonld-CMQE_cGn-899pOqB6.js";import{d as a,e as s}from"./base64url-Cy03LJLt-vkTPfQOh.js";import{f as u}from"./index-BJkS6Wwm-C8oVP6LM.js";import{e as c,d as f}from"./index-DZLKRa_V-D_IQzjvG.js";import{S as d}from"./Suite-BmP2Qu19-D1ucdMDB.js";import"./pako.esm-BGRKTPxS-UdHShO7y.js";import"./sha256-CN3v2fAD-C1PUWFZm.js";import"./index-BcfLkJHS-Dgus2xdV.js";import{r as l}from"./retrieveVerificationMethodPublicKey-nmb3CCVx-DA6ovQri.js";import"./elliptic-HXNc7riQ-DrFZxkx3.js";var h=o();
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */const p=globalThis.crypto;
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */function y({algorithm:e="sha256"}={}){if("sha256"!==e)throw new Error(`Unsupported algorithm "${e}".`);return{hash:async e=>new Uint8Array(await p.subtle.digest("SHA-256",e))}}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */const g=new TextEncoder;function w(e){return g.encode(e)}
/*!
 * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.
 */async function m({document:e,labelMapFactoryFunction:t,options:r}={}){const{nquads:n}=await async function({document:e,nquads:t,labelMapFactoryFunction:r,options:n}={}){let o,i=new Map;o=e?await b(e,{...n,canonicalIdMap:i}):await b(t.join(""),{...n,inputFormat:"application/n-quads",canonicalIdMap:i});i=function(e){let t=!1,r=!1,n=!1;const o=new Map;for(const[i,a]of e){if(!t&&(t=!0,r=i.startsWith("_:"),n=a.startsWith("_:"),!r&&!n))return e;o.set(r?i.slice(2):i,n?a.slice(2):a)}return o}(i);const a=await r({canonicalIdMap:i}),s=new Map;for(const[e,t]of a)s.set(i.get(e),t);const u=(e,t,r)=>"_:"+s.get(r);return{nquads:o.split("\n").slice(0,-1).map((e=>e.replace(/(_:([^\s]+))/g,u)+"\n")).sort(),labelMap:a}}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */({document:e,labelMapFactoryFunction:t,options:r});return n}async function b(e,t){if(!t||"object"!=typeof t)throw new TypeError('"options" must be an object.');if(t={algorithm:"RDFC-1.0",format:"application/n-quads",base:null,safe:!0,...t},"string"!=typeof e){const r={rdfDirection:"i18n-datatype",...t,produceGeneralizedRdf:!1};delete r.format,e=await i.toRDF(e,r)}return h.canonize(e,t)}async function v({document:e,proof:t,options:r,hasher:n}={}){n||(n=y());const o=await async function({document:e,proof:t,options:r}={}){return delete(t={"@context":e["@context"],...t}).proofValue,b(t,r)}({document:e,proof:t,options:r});return n.hash(w(o))}const E=["string","number","bigint","symbol"],A=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function M(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(E.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";const r=function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(A.includes(t))return t;return}(e);return r||"Object"}class S{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}S.uint=new S(0,"uint",!0),S.negint=new S(1,"negint",!0),S.bytes=new S(2,"bytes",!0),S.string=new S(3,"string",!0),S.array=new S(4,"array",!1),S.map=new S(5,"map",!1),S.tag=new S(6,"tag",!1),S.float=new S(7,"float",!0),S.false=new S(7,"false",!0),S.true=new S(7,"true",!0),S.null=new S(7,"null",!0),S.undefined=new S(7,"undefined",!0),S.break=new S(7,"break",!0);class ${constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const T=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,V=new TextDecoder,k=new TextEncoder;function x(e){return T&&globalThis.Buffer.isBuffer(e)}const I=T?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):P(e,t,r):(e,t,r)=>r-t>64?V.decode(e.subarray(t,r)):P(e,t,r),j=T?e=>e.length>64?globalThis.Buffer.from(e):D(e):e=>e.length>64?k.encode(e):D(e),U=T?(e,t,r)=>x(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r);function D(e){const t=[];let r=0;for(let n=0;n<e.length;n++){let o=e.charCodeAt(n);o<128?t[r++]=o:o<2048?(t[r++]=o>>6|192,t[r++]=63&o|128):55296==(64512&o)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++n)),t[r++]=o>>18|240,t[r++]=o>>12&63|128,t[r++]=o>>6&63|128,t[r++]=63&o|128):(t[r++]=o>>12|224,t[r++]=o>>6&63|128,t[r++]=63&o|128)}return t}function P(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,a=o>239?4:o>223?3:o>191?2:1;if(t+a<=r){let r,n,s,u;switch(a){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(u=(31&o)<<6|63&r,u>127&&(i=u));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(u=(15&o)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(i=u));break;case 4:r=e[t+1],n=e[t+2],s=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&s)&&(u=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&s,u>65535&&u<1114112&&(i=u))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=a}return function(e){const t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=B));return r}(n)}const B=4096;const N="CBOR decode error:",L="CBOR encode error:";function C(e,t,r){if(e.length-t<r)throw new Error(`${N} not enough data for type`)}const K=[24,256,65536,4294967296,BigInt("18446744073709551616")];function _(e,t,r){C(e,t,1);const n=e[t];if(!0===r.strict&&n<K[0])throw new Error(`${N} integer encoded in more bytes than necessary (strict decode)`);return n}function F(e,t,r){C(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<K[1])throw new Error(`${N} integer encoded in more bytes than necessary (strict decode)`);return n}function z(e,t,r){C(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<K[2])throw new Error(`${N} integer encoded in more bytes than necessary (strict decode)`);return n}function q(e,t,r){C(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<K[3])throw new Error(`${N} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${N} integers outside of the safe integer range are not supported`)}function H(e,t){return O(e,0,t.value)}function O(e,t,r){if(r<K[0]){const n=Number(r);e.push([t|n])}else if(r<K[1]){const n=Number(r);e.push([24|t,n])}else if(r<K[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<K[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<K[4]))throw new Error(`${N} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}H.encodedSize=function(e){return O.encodedSize(e.value)},O.encodedSize=function(e){return e<K[0]?1:e<K[1]?2:e<K[2]?3:e<K[3]?5:9},H.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const R=BigInt(-1),G=BigInt(1);function J(e,t){const r=t.value,n="bigint"==typeof r?r*R-G:-1*r-1;O(e,t.type.majorEncoded,n)}function W(e,t,r,n){C(e,t,r+n);const o=U(e,t+r,t+r+n);return new $(S.bytes,o,r+n)}function X(e,t,r,n){return W(e,t,1,r)}function Z(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===S.string?j(e.value):e.value),e.encodedBytes}function Q(e,t){const r=Z(t);O(e,t.type.majorEncoded,r.length),e.push(r)}function Y(e,t,r,n,o){const i=r+n;C(e,t,i);const a=new $(S.string,I(e,t+r,t+i),i);return!0===o.retainStringBytes&&(a.byteValue=U(e,t+r,t+i)),a}function ee(e,t,r,n){return Y(e,t,1,r,n)}J.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*R-G:-1*t-1;return r<K[0]?1:r<K[1]?2:r<K[2]?3:r<K[3]?5:9},J.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},Q.encodedSize=function(e){const t=Z(e);return O.encodedSize(t.length)+t.length},Q.compareTokens=function(e,t){return r=Z(e),n=Z(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(x(e)&&x(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const te=Q;function re(e,t,r,n){return new $(S.array,n,r)}function ne(e,t,r,n){return re(0,0,1,r)}function oe(e,t){O(e,S.array.majorEncoded,t.value)}function ie(e,t,r,n){return new $(S.map,n,r)}function ae(e,t,r,n){return ie(0,0,1,r)}function se(e,t){O(e,S.map.majorEncoded,t.value)}function ue(e,t,r,n){return new $(S.tag,r,1)}function ce(e,t){O(e,S.tag.majorEncoded,t.value)}oe.compareTokens=H.compareTokens,oe.encodedSize=function(e){return O.encodedSize(e.value)},se.compareTokens=H.compareTokens,se.encodedSize=function(e){return O.encodedSize(e.value)},ce.compareTokens=H.compareTokens,ce.encodedSize=function(e){return O.encodedSize(e.value)};function fe(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${N} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${N} Infinity values are not supported`)}return new $(S.float,e,t)}function de(e,t,r){const n=t.value;if(!1===n)e.push([20|S.float.majorEncoded]);else if(!0===n)e.push([21|S.float.majorEncoded]);else if(null===n)e.push([22|S.float.majorEncoded]);else if(void 0===n)e.push([23|S.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(ye(n),t=ge(pe,1),n===t||Number.isNaN(n)?(pe[0]=249,e.push(pe.slice(0,3)),i=!0):(we(n),t=me(pe,1),n===t&&(pe[0]=250,e.push(pe.slice(0,5)),i=!0))),i||(o=n,he.setFloat64(0,o,!1),t=be(pe,1),pe[0]=251,e.push(pe.slice(0,9)))}var o}de.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){ye(r);let e=ge(pe,1);if(r===e||Number.isNaN(r))return 3;if(we(r),e=me(pe,1),r===e)return 5}return 9};const le=new ArrayBuffer(9),he=new DataView(le,1),pe=new Uint8Array(le,0);function ye(e){if(e===1/0)he.setUint16(0,31744,!1);else if(e===-1/0)he.setUint16(0,64512,!1);else if(Number.isNaN(e))he.setUint16(0,32256,!1);else{he.setFloat32(0,e);const t=he.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)he.setUint16(0,31744,!1);else if(0===r)he.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?he.setUint16(0,0):e<-14?he.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):he.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function ge(e,t){if(e.length-t<2)throw new Error(`${N} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function we(e){he.setFloat32(0,e,!1)}function me(e,t){if(e.length-t<4)throw new Error(`${N} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function be(e,t){if(e.length-t<8)throw new Error(`${N} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function ve(e,t,r){throw new Error(`${N} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function Ee(e){return()=>{throw new Error(`${N} ${e}`)}}de.compareTokens=H.compareTokens;const Ae=[];for(let e=0;e<=23;e++)Ae[e]=ve;Ae[24]=function(e,t,r,n){return new $(S.uint,_(e,t+1,n),2)},Ae[25]=function(e,t,r,n){return new $(S.uint,F(e,t+1,n),3)},Ae[26]=function(e,t,r,n){return new $(S.uint,z(e,t+1,n),5)},Ae[27]=function(e,t,r,n){return new $(S.uint,q(e,t+1,n),9)},Ae[28]=ve,Ae[29]=ve,Ae[30]=ve,Ae[31]=ve;for(let e=32;e<=55;e++)Ae[e]=ve;Ae[56]=function(e,t,r,n){return new $(S.negint,-1-_(e,t+1,n),2)},Ae[57]=function(e,t,r,n){return new $(S.negint,-1-F(e,t+1,n),3)},Ae[58]=function(e,t,r,n){return new $(S.negint,-1-z(e,t+1,n),5)},Ae[59]=function(e,t,r,n){const o=q(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new $(S.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${N} integers outside of the safe integer range are not supported`);return new $(S.negint,R-BigInt(o),9)},Ae[60]=ve,Ae[61]=ve,Ae[62]=ve,Ae[63]=ve;for(let e=64;e<=87;e++)Ae[e]=X;Ae[88]=function(e,t,r,n){return W(e,t,2,_(e,t+1,n))},Ae[89]=function(e,t,r,n){return W(e,t,3,F(e,t+1,n))},Ae[90]=function(e,t,r,n){return W(e,t,5,z(e,t+1,n))},Ae[91]=function(e,t,r,n){const o=q(e,t+1,n);if("bigint"==typeof o)throw new Error(`${N} 64-bit integer bytes lengths not supported`);return W(e,t,9,o)},Ae[92]=ve,Ae[93]=ve,Ae[94]=ve,Ae[95]=Ee("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Ae[e]=ee;Ae[120]=function(e,t,r,n){return Y(e,t,2,_(e,t+1,n),n)},Ae[121]=function(e,t,r,n){return Y(e,t,3,F(e,t+1,n),n)},Ae[122]=function(e,t,r,n){return Y(e,t,5,z(e,t+1,n),n)},Ae[123]=function(e,t,r,n){const o=q(e,t+1,n);if("bigint"==typeof o)throw new Error(`${N} 64-bit integer string lengths not supported`);return Y(e,t,9,o,n)},Ae[124]=ve,Ae[125]=ve,Ae[126]=ve,Ae[127]=Ee("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Ae[e]=ne;Ae[152]=function(e,t,r,n){return re(0,0,2,_(e,t+1,n))},Ae[153]=function(e,t,r,n){return re(0,0,3,F(e,t+1,n))},Ae[154]=function(e,t,r,n){return re(0,0,5,z(e,t+1,n))},Ae[155]=function(e,t,r,n){const o=q(e,t+1,n);if("bigint"==typeof o)throw new Error(`${N} 64-bit integer array lengths not supported`);return re(0,0,9,o)},Ae[156]=ve,Ae[157]=ve,Ae[158]=ve,Ae[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${N} indefinite length items not allowed`);return re(0,0,1,1/0)};for(let e=160;e<=183;e++)Ae[e]=ae;Ae[184]=function(e,t,r,n){return ie(0,0,2,_(e,t+1,n))},Ae[185]=function(e,t,r,n){return ie(0,0,3,F(e,t+1,n))},Ae[186]=function(e,t,r,n){return ie(0,0,5,z(e,t+1,n))},Ae[187]=function(e,t,r,n){const o=q(e,t+1,n);if("bigint"==typeof o)throw new Error(`${N} 64-bit integer map lengths not supported`);return ie(0,0,9,o)},Ae[188]=ve,Ae[189]=ve,Ae[190]=ve,Ae[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${N} indefinite length items not allowed`);return ie(0,0,1,1/0)};for(let e=192;e<=215;e++)Ae[e]=ue;Ae[216]=function(e,t,r,n){return new $(S.tag,_(e,t+1,n),2)},Ae[217]=function(e,t,r,n){return new $(S.tag,F(e,t+1,n),3)},Ae[218]=function(e,t,r,n){return new $(S.tag,z(e,t+1,n),5)},Ae[219]=function(e,t,r,n){return new $(S.tag,q(e,t+1,n),9)},Ae[220]=ve,Ae[221]=ve,Ae[222]=ve,Ae[223]=ve;for(let e=224;e<=243;e++)Ae[e]=Ee("simple values are not supported");Ae[244]=ve,Ae[245]=ve,Ae[246]=ve,Ae[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${N} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new $(S.null,null,1):new $(S.undefined,void 0,1)},Ae[248]=Ee("simple values are not supported"),Ae[249]=function(e,t,r,n){return fe(ge(e,t+1),3,n)},Ae[250]=function(e,t,r,n){return fe(me(e,t+1),5,n)},Ae[251]=function(e,t,r,n){return fe(be(e,t+1),9,n)},Ae[252]=ve,Ae[253]=ve,Ae[254]=ve,Ae[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${N} indefinite length items not allowed`);return new $(S.break,void 0,1)};const Me=[];for(let e=0;e<24;e++)Me[e]=new $(S.uint,e,1);for(let e=-1;e>=-24;e--)Me[31-e]=new $(S.negint,e,1);Me[64]=new $(S.bytes,new Uint8Array(0),1),Me[96]=new $(S.string,"",1),Me[128]=new $(S.array,0,1),Me[160]=new $(S.map,0,1),Me[244]=new $(S.false,!1,1),Me[245]=new $(S.true,!0,1),Me[246]=new $(S.null,null,1),function(){const e=[];e[S.uint.major]=H,e[S.negint.major]=J,e[S.bytes.major]=Q,e[S.string.major]=te,e[S.array.major]=oe,e[S.map.major]=se,e[S.tag.major]=ce,e[S.float.major]=de}();class Se{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${L} object contains circular references`);return new Se(t,e)}}const $e={null:new $(S.null,null),undefined:new $(S.undefined,void 0),true:new $(S.true,!0),false:new $(S.false,!1),emptyArray:new $(S.array,0),emptyMap:new $(S.map,0)},Te={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new $(e>=0?S.uint:S.negint,e):new $(S.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new $(S.uint,e):new $(S.negint,e),Uint8Array:(e,t,r,n)=>new $(S.bytes,e),string:(e,t,r,n)=>new $(S.string,e),boolean:(e,t,r,n)=>e?$e.true:$e.false,null:(e,t,r,n)=>$e.null,undefined:(e,t,r,n)=>$e.undefined,ArrayBuffer:(e,t,r,n)=>new $(S.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new $(S.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[$e.emptyArray,new $(S.break)]:$e.emptyArray;n=Se.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=Ve(t,r,n);return r.addBreakTokens?[new $(S.array,e.length),o,new $(S.break)]:[new $(S.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),a=o?e.size:i.length;if(!a)return!0===r.addBreakTokens?[$e.emptyMap,new $(S.break)]:$e.emptyMap;n=Se.createCheck(n,e);const s=[];let u=0;for(const t of i)s[u++]=[Ve(t,r,n),Ve(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(s,r),r.addBreakTokens?[new $(S.map,a),s,new $(S.break)]:[new $(S.map,a),s]}};Te.Map=Te.Object,Te.Buffer=Te.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Te[`${e}Array`]=Te.DataView;function Ve(e,t={},r){const n=M(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||Te[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=Te[n];if(!i)throw new Error(`${L} unsupported type: ${n}`);return i(e,n,t,r)}const ke={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class xe{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=Me[e];if(void 0===t){const r=Ae[e];if(!r)throw new Error(`${N} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const n=31&e;t=r(this.data,this._pos,n,this.options)}return this._pos+=t.encodedLength,t}}const Ie=Symbol.for("DONE"),je=Symbol.for("BREAK");function Ue(e,t){if(e.done())return Ie;const r=e.next();if(r.type===S.break)return je;if(r.type.terminal)return r.value;if(r.type===S.array)return function(e,t,r){const n=[];for(let o=0;o<e.value;o++){const i=Ue(t,r);if(i===je){if(e.value===1/0)break;throw new Error(`${N} got unexpected break to lengthed array`)}if(i===Ie)throw new Error(`${N} found array but not enough entries (got ${o}, expected ${e.value})`);n[o]=i}return n}(r,e,t);if(r.type===S.map)return function(e,t,r){const n=!0===r.useMaps,o=n?void 0:{},i=n?new Map:void 0;for(let a=0;a<e.value;a++){const s=Ue(t,r);if(s===je){if(e.value===1/0)break;throw new Error(`${N} got unexpected break to lengthed map`)}if(s===Ie)throw new Error(`${N} found map but not enough entries (got ${a} [no key], expected ${e.value})`);if(!0!==n&&"string"!=typeof s)throw new Error(`${N} non-string keys not supported (got ${typeof s})`);if(!0===r.rejectDuplicateMapKeys&&(n&&i.has(s)||!n&&s in o))throw new Error(`${N} found repeat map key "${s}"`);const u=Ue(t,r);if(u===Ie)throw new Error(`${N} found map but not enough entries (got ${a} [no value], expected ${e.value})`);n?i.set(s,u):o[s]=u}return n?i:o}(r,e,t);if(r.type===S.tag){if(t.tags&&"function"==typeof t.tags[r.value]){const n=Ue(e,t);return t.tags[r.value](n)}throw new Error(`${N} tag not supported (${r.value})`)}throw new Error("unsupported")}function De(e,t){const[r,n]=function(e,t){if(!(e instanceof Uint8Array))throw new Error(`${N} data to decode must be a Uint8Array`);const r=(t=Object.assign({},ke,t)).tokenizer||new xe(e,t),n=Ue(r,t);if(n===Ie)throw new Error(`${N} did not find any content to decode`);if(n===je)throw new Error(`${N} got unexpected break`);return[n,e.subarray(r.pos())]}(e,t);if(n.length>0)throw new Error(`${N} too many terminals, data makes no sense`);return r}
/*!
 * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.
 */const Pe=new Uint8Array([217,93,1]),Be=[];function Ne({proof:e}={}){try{if("string"!=typeof e?.proofValue)throw new TypeError('"proof.proofValue" must be a string.');if("u"!==e.proofValue[0])throw new Error("Only base64url multibase encoding is supported.");const t=a(e.proofValue.slice(1));if(!function(e,t){for(let r=0;r<t.length;++r)if(e[r]!==t[r])return!1;return!0}(t,Pe))throw new TypeError('"proof.proofValue" must be a derived proof.');const r=t.subarray(Pe.length),[n,o,i,u,c]=De(r,{useMaps:!0,tags:Be}),f=function(e){const t=new Map;for(const[r,n]of e.entries())t.set(`c14n${r}`,`u${s(n)}`);return t}(u),d={baseSignature:n,publicKey:o,signatures:i,labelMap:f,mandatoryIndexes:c};return function({baseSignature:e,publicKey:t,signatures:r,labelMap:n,mandatoryIndexes:o}){if(!(e instanceof Uint8Array&&64===e.length))throw new TypeError('"baseSignature" must be a Uint8Array of length 64.');if(!(t instanceof Uint8Array&&35===t.length))throw new TypeError('"publicKey" must be a Uint8Array of length 35.');if(!Array.isArray(r)||!r.every((e=>e instanceof Uint8Array)))throw new TypeError('"signatures" must be an array of Uint8Arrays.');if(!(n instanceof Map&&[...n.entries()].every((([e,t])=>"string"==typeof e&&"string"==typeof t))))throw new TypeError('"labelMap" must be a Map of strings to strings.');if(!Array.isArray(o)||!o.every(Number.isInteger))throw new TypeError('"mandatoryIndexes" must be an array of integers.')}(d),d}catch(e){const t=new TypeError('The proof does not include a valid "proofValue" property.');throw t.cause=e,t}}function Le({proofHash:e,publicKey:t,mandatoryHash:r}={}){!function({proofHash:e,publicKey:t,mandatoryHash:r}){if(!(e instanceof Uint8Array&&32===e.length))throw new TypeError('"proofHash" must be a Uint8Array of length 32.');if(!(t instanceof Uint8Array&&35===t.length))throw new TypeError('"publicKey" must be a Uint8Array of length 35.');if(!(r instanceof Uint8Array&&32===r.length))throw new TypeError('"mandatoryHash" must be a Uint8Array of length 32.')}({proofHash:e,publicKey:t,mandatoryHash:r});return function(e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;for(const n of e)t.set(n,r),r+=n.length;return t}([e,t,r])}Be[64]=function(e){return e}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */;const Ce="ecdsa-sd-2023";
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */
function Ke({requiredAlgorithm:e="P-256"}={}){return{name:Ce,requiredAlgorithm:e,createVerifier:_e,createVerifyData:Fe}}async function _e({verificationMethod:e}){const t=(await u(e)).verifier();return{algorithm:t.algorithm,id:t.id,verify:async({data:e})=>async function({verifier:e,data:t}={}){const{baseSignature:r,proofHash:n,publicKey:o,signatures:i,nonMandatory:a,mandatoryHash:s}=t,f="z"+c(o),d=await u({publicKeyMultibase:f});if(i.length!==a.length)throw new Error(`Signature count (${i.length}) does not match non-mandatory message count (${a.length}).`);const{verify:l}=d.verifier();if((await Promise.all(i.map(((e,t)=>l({data:w(a[t]),signature:e}))))).some((e=>!e)))return!1;const h=await Le({proofHash:n,publicKey:o,mandatoryHash:s});return e.verify({data:h,signature:r})}
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */({verifier:t,data:e})}}async function Fe({cryptosuite:e,document:t,proof:r,documentLoader:n}){if(e?.name!==Ce)throw new TypeError(`"cryptosuite.name" must be "${Ce}".`);const o={documentLoader:n},i=v({document:t,proof:r,options:o}).catch((e=>e)),{baseSignature:a,publicKey:s,signatures:u,labelMap:c,mandatoryIndexes:f}=await Ne({proof:r}),d=await function({labelMap:e}={}){return async({canonicalIdMap:t})=>{const r=new Map;for(const[n,o]of t)r.set(n,e.get(o));return r}}({labelMap:c}),l=await m({document:t,labelMapFactoryFunction:d,options:o}),h=[],p=[];for(const[e,t]of l.entries())f.includes(e)?h.push(t):p.push(t);const{mandatoryHash:g}=await async function({mandatory:e,hasher:t}={}){return t||(t=y()),{mandatoryHash:await t.hash(w(e.join("")))}}({mandatory:h}),b=await i;if(b instanceof Error)throw b;return{baseSignature:a,proofHash:b,publicKey:s,signatures:u,nonMandatory:p,mandatoryHash:g}}const ze=new RegExp("-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](.[0-9]+)?|(24:00:00(.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"),qe=e=>ze.test(e),He=self&&(self.crypto||self.msCrypto);async function Oe({string:e}){const t=(new TextEncoder).encode(e);return new Uint8Array(await He.subtle.digest("SHA-256",t))}
/*!
 * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.
 */const{suites:{LinkedDataProof:Re}}=n;class Ge extends Re{constructor({signer:e,date:t,cryptosuite:r,legacyContext:n=!1}={}){super({type:"DataIntegrityProof"});const{canonize:o,createVerifier:i,name:a,requiredAlgorithm:s,derive:u,createProofValue:c,createVerifyData:f}=r;if(!i||"function"!=typeof i)throw new TypeError('"cryptosuite.createVerifier" must be a function.');if(u&&"function"!=typeof u)throw new TypeError('"cryptosuite.derive" must be a function.');if(c&&"function"!=typeof c)throw new TypeError('"cryptosuite.createProofValue" must be a function.');if(f&&"function"!=typeof f)throw new TypeError('"cryptosuite.createVerifyData" must be a function.');if(this.contextUrl="https://w3id.org/security/data-integrity/v2",n&&(this.contextUrl="https://w3id.org/security/data-integrity/v1"),this.canonize=o,this.createVerifier=i,this.cryptosuite=a,this._cryptosuite=r,this.requiredAlgorithm=s,t){if(this.date=new Date(t),isNaN(this.date))throw TypeError(`"date" "${t}" is not a valid date.`)}else null===t&&(this.date=null);const d=function({signer:e,requiredAlgorithm:t}){const r={verificationMethod:void 0,signer:void 0};if(!e)return r;if("function"!=typeof e.sign)throw new TypeError("A signer API has not been specified.");const n=Array.isArray(t)?t.includes(e.algorithm):t===e.algorithm;if(!n){const r=Array.isArray(t)?t.join(", "):t,n=Array.isArray(t)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${r}".`:`does not match the required algorithm for the cryptosuite "${r}".`,o=`The signer's algorithm "${e.algorithm}" ${n}`;throw new Error(o)}return r.signer=e,r.verificationMethod=e.id,r}({signer:e,requiredAlgorithm:s});this.verificationMethod=d.verificationMethod,this.signer=d.signer}async sign({verifyData:e,proof:t}){if(!this.signer||"function"!=typeof this.signer.sign)throw new Error("A signer API has not been specified.");const r=await this.signer.sign({data:e});return t.proofValue="z"+c(r),t}async verifySignature({verifyData:e,verificationMethod:t,proof:r}){const n=await this.createVerifier({verificationMethod:t});if(!(Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.includes(n.algorithm):this.requiredAlgorithm===n.algorithm)){const e=Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.join(", "):this.requiredAlgorithm,t=Array.isArray(this.requiredAlgorithm)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${e}".`:`does not match the required algorithm for the cryptosuite "${e}".`,r=`The verifier's algorithm "${n.algorithm}" ${t}`;throw new Error(r)}const{proofValue:o}=r;if(!o||"string"!=typeof o)throw new TypeError('The proof does not include a valid "proofValue" property.');const i=o[0];let s;if("z"===i)s=f(o.slice(1));else{if("u"!==i)throw new Error("Only base58btc or base64url multibase encoding is supported.");s=a(o.slice(1))}return n.verify({data:e,signature:s})}async createProof({document:e,purpose:t,proofSet:r,documentLoader:n}){let o;o=this.proof?{...this.proof}:{},o.type=this.type;let i,a=this.date;return void 0===o.created&&void 0===a&&(a=new Date),a&&"string"!=typeof a&&(a=(e=>(null==e?e=new Date:"number"!=typeof e&&"string"!=typeof e||(e=new Date(e)),e.toISOString().slice(0,-5)+"Z"))(a)),a&&(o.created=a),o.verificationMethod=this.verificationMethod,o.cryptosuite=this.cryptosuite,o=await this.updateProof({document:e,proof:o,purpose:t,proofSet:r,documentLoader:n}),o=await t.update(o,{document:e,suite:this,documentLoader:n}),i=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:e,proof:o,proofSet:r,documentLoader:n,dataIntegrityProof:this}):await this.createVerifyData({document:e,proof:o,proofSet:r,documentLoader:n}),this._cryptosuite.createProofValue?o.proofValue=await this._cryptosuite.createProofValue({cryptosuite:this._cryptosuite,verifyData:i,document:e,proof:o,proofSet:r,documentLoader:n,dataIntegrityProof:this}):o=await this.sign({verifyData:i,document:e,proof:o,proofSet:r,documentLoader:n}),o}async derive({document:e,purpose:t,proofSet:r,documentLoader:n}){if(!this._cryptosuite.derive)throw new Error('"cryptosuite.derive" not provided.');return this._cryptosuite.derive({cryptosuite:this._cryptosuite,document:e,purpose:t,proofSet:r,documentLoader:n,dataIntegrityProof:this})}async updateProof({proof:e}){return e}async verifyProof({proof:e,proofSet:t,document:r,documentLoader:n}){try{const o=await this.getVerificationMethod({proof:e,documentLoader:n});let i;i=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:r,proof:e,proofSet:t,documentLoader:n,dataIntegrityProof:this,verificationMethod:o}):await this.createVerifyData({document:r,proof:e,proofSet:t,documentLoader:n,verificationMethod:o});if(!await this.verifySignature({verifyData:i,verificationMethod:o,proof:e}))throw new Error("Invalid signature.");if(void 0!==e.created&&!qe(e.created))throw new Error(`"proof.created" ("${e.created}") must be an XSD dateTimeStamp.`);if(void 0!==e.expires&&!qe(e.expires))throw new Error(`"proof.expires" ("${e.expires}") must be an XSD dateTimeStamp.`);return{verified:!0,verificationMethod:o}}catch(e){return{verified:!1,error:e}}}async createVerifyData({document:e,proof:t,documentLoader:r}){let n;const{_hashCache:o}=this;o&&o.document===e?n=o.hash:this._hashCache={document:e,hash:n=this.canonize(e,{documentLoader:r,base:null,safe:!0}).then((e=>Oe({string:e})))};const[i,a]=await Promise.all([this.canonizeProof(t,{document:e,documentLoader:r}).then((e=>Oe({string:e}))),n]);return((e,t)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),r})(i,a)}async getVerificationMethod({proof:e,documentLoader:t}){let{verificationMethod:r}=e;if("object"==typeof r&&(r=r.id),!r)throw new Error('No "verificationMethod" found in proof.');const n=await t(r);if(!n)throw new Error(`Unable to load verification method "${r}".`);const{document:o}=n;return r="string"==typeof o?JSON.parse(o):o,r}async canonizeProof(e,{documentLoader:t,document:r}){return e={"@context":r["@context"],...e},this.ensureSuiteContext({document:e,addSuiteContext:!0}),delete e.proofValue,this.canonize(e,{documentLoader:t,safe:!0,base:null,skipExpansion:!1})}async matchProof({proof:e}){const{type:t,cryptosuite:r}=e;return t===this.type&&r===this.cryptosuite}ensureSuiteContext({document:e,addSuiteContext:t}){const{contextUrl:r}=this;if(Je({document:e,contextUrl:r})||Je({document:e,contextUrl:"https://www.w3.org/ns/credentials/v2"}))return;if(!t)throw new TypeError(`The document to be signed must contain this suite's @context, "${r}".`);const n=e["@context"]||[];e["@context"]=Array.isArray(n)?[...n,r]:[n,r]}}function Je({document:e,contextUrl:t}){const r=e["@context"];return r===t||Array.isArray(r)&&r.includes(t)}const{purposes:{AssertionProofPurpose:We,AuthenticationProofPurpose:Xe}}=n;var Ze;!function(e){e.retrieveVerificationMethodPublicKey="retrieveVerificationMethodPublicKey",e.ensureVerificationMethodValidity="ensureVerificationMethodValidity",e.checkDocumentSignature="checkDocumentSignature"}(Ze||(Ze={}));class Qe extends d{verificationProcess=[Ze.retrieveVerificationMethodPublicKey,Ze.ensureVerificationMethodValidity,Ze.checkDocumentSignature];documentToVerify;issuer;proof;type="EcdsaSd2023";cryptosuite="ecdsa-sd-2023";publicKey;verificationKey;verificationMethod;proofPurpose;challenge;domain;proofPurposeMap;constructor(e){super(e),e.executeStep&&(this.executeStep=e.executeStep),this.documentToVerify=e.document,this.issuer=e.issuer,this.proof=e.proof,this.proofPurpose=e.proofPurpose??"assertionMethod",this.challenge=e.proofChallenge??"",this.domain=e.proofDomain,this.proofPurposeMap={authentication:Xe,assertionMethod:We},this.validateProofType()}async init(){}async verifyProof(){for(const e of this.verificationProcess){if(!this[e])return void console.error("verification logic for",e,"not implemented");await this[e]()}}async verifyIdentity(){}getProofVerificationSteps(t){return this.verificationProcess.map((r=>e.verifier.convertToVerificationSubsteps(t,r)))}getIdentityVerificationSteps(){return[]}getIssuerPublicKey(){return this.publicKey}getIssuerName(){return this.issuer.name??""}getIssuerProfileDomain(){try{return new URL(this.getIssuerProfileUrl()).hostname??""}catch(e){return""}}getIssuerProfileUrl(){return this.issuer.id??""}getSigningDate(){return this.proof.created}async executeStep(e,t,r){throw new Error("doAction method needs to be overwritten by injecting from CVJS")}validateProofType(){const e=this.proof.type;if("DataIntegrityProof"!==e){if(e!==this.type)throw new Error(`Incompatible proof type passed. Expected: ${this.type}, Got: ${e}`)}else{const e=this.proof.cryptosuite;if(!e)throw new Error(`Malformed proof passed. With DataIntegrityProof a cryptosuite must be defined. Expected: ${this.cryptosuite}`);if(e!==this.cryptosuite)throw new Error(`Incompatible proof cryptosuite passed. Expected: ${this.cryptosuite}, Got: ${e}`)}}generateDocumentLoader(e=[]){e.forEach((e=>{t[e.url]=e.value})),t[this.documentToVerify.issuer]=this.getTargetVerificationMethodContainer();return function(e){return e in t?{contextUrl:null,document:t[e],documentUrl:e}:i.documentLoader(e)}}getErrorMessage(e){return e.error.errors[0].message}getTargetVerificationMethodContainer(){if(this.issuer.didDocument){if(this.findVerificationMethod(this.issuer.didDocument.verificationMethod,this.issuer.didDocument.id))return this.issuer.didDocument}const e={...this.issuer};return delete e.didDocument,e}findVerificationMethod(e,t){return e.find((e=>e.id===this.proof.verificationMethod||t+e.id===this.proof.verificationMethod))??null}async retrieveVerificationMethodPublicKey(){this.verificationKey=await this.executeStep(Ze.retrieveVerificationMethodPublicKey,(async()=>{if(this.verificationMethod=l(this.getTargetVerificationMethodContainer(),this.proof.verificationMethod),!this.verificationMethod)throw new r(Ze.retrieveVerificationMethodPublicKey,"Could not derive the verification key");if(this.verificationMethod.revoked)throw new r(Ze.retrieveVerificationMethodPublicKey,"The verification key has been revoked");return this.verificationMethod}),this.type)}async ensureVerificationMethodValidity(){await this.executeStep(Ze.ensureVerificationMethodValidity,(async()=>{if(this.verificationMethod.expires){if(new Date(this.verificationMethod.expires).getTime()<Date.now())throw new r(Ze.ensureVerificationMethodValidity,"The verification key has expired")}if(this.verificationMethod.revoked)throw new r(Ze.ensureVerificationMethodValidity,"The verification key has been revoked")}),this.type)}async checkDocumentSignature(){await this.executeStep(Ze.checkDocumentSignature,(async()=>{const e=new Ge({cryptosuite:Ke({requiredAlgorithm:"K-256"})}),t=this.documentToVerify.proof.verificationMethod;"authentication"!==this.proofPurpose||this.proof.challenge||(this.proof.challenge="");const o=await n.verify(this.documentToVerify,{suite:e,purpose:new this.proofPurposeMap[this.proofPurpose]({controller:this.getTargetVerificationMethodContainer(),challenge:this.challenge,domain:this.domain}),documentLoader:this.generateDocumentLoader([{url:t,value:this.verificationKey}])});if(!o.verified)throw console.error(JSON.stringify(o,null,2)),new r(Ze.checkDocumentSignature,`The document's ${this.type} signature could not be confirmed: ${this.getErrorMessage(o)}`);console.log(`Credential ${this.type} signature successfully verified`)}),this.type)}}export{Qe as default};
