import{B as e}from"./main.js";var t,r,n,s,o,i,a,c,l,u,p,d,f,m,y,h,g,w,b,$,v,j;function O(){if(r)return t;r=1;class e extends String{}const n=new Set(["<",">","<=",">="]),s=(t,...r)=>{const o=t.replace(/%[%drscjw]/g,(t=>{if("%%"===t)return"%";if(0===r.length)throw new Error("Unexpected arguments count");const o=r.shift();switch(t){case"%d":if("number"==typeof o)return o;throw new Error("Expected a number");case"%r":if(o instanceof RegExp)return s("new RegExp(%j, %j)",o.source,o.flags);throw new Error("Expected a RegExp instance");case"%s":if(o instanceof e)return o;throw new Error("Expected a safe string");case"%c":if(n.has(o))return o;throw new Error("Expected a compare op");case"%j":return(e=>{if([1/0,-1/0,NaN,void 0,null].includes(e))return`${e}`;if(!["string","boolean","number"].includes(typeof e)){if("object"!=typeof e)throw new Error("Unexpected value type");const t=Object.getPrototypeOf(e);if(!(t===Array.prototype&&Array.isArray(e)||t===Object.prototype))throw new Error("Unexpected object given as value")}return JSON.stringify(e).replace(/([{,])"__proto__":/g,'$1["__proto__"]:').replace(/[^\\]"__proto__":/g,(()=>{throw new Error("Unreachable")})).replace(/[\u2028\u2029]/g,(e=>`\\u${e.charCodeAt(0).toString(16).padStart(4,"0")}`))})(o);case"%w":if(Number.isInteger(o)&&o>=0)return" ".repeat(o);throw new Error("Expected a non-negative integer for indentation")}throw new Error("Unreachable")}));if(0!==r.length)throw new Error("Unexpected arguments count");return new e(o)},o=t=>{if(!/^[a-z][a-z0-9_]*$/i.test(t))throw new Error("Does not look like a safe id");return new e(t)},i=t=>(...r)=>{if(!r.every((t=>t instanceof e)))throw new Error("Unsafe arguments");return new e(t(...r))},a=i(((...e)=>e.some((e=>"true"==`${e}`))?"true":e.join(" || ")||"false")),c=i(((...e)=>e.some((e=>"false"==`${e}`))?"false":e.join(" && ")||"true")),l=e=>"true"==`${e}`?o("false"):"false"==`${e}`?o("true"):s("!%s",(e=>/^[a-z][a-z0-9_().]*$/i.test(e)||/^\([^()]+\)$/i.test(e)?e:s("(%s)",e))(e));return t={format:s,safe:o,safeand:c,safenot:l,safenotor:(...e)=>l(a(...e))}}function x(){if(s)return n;s=1;const{safe:e}=O(),t=new WeakMap;return n={scopeMethods:r=>{t.has(r)||t.set(r,{sym:new Map,ref:new Map,format:new Map,pattern:new Map});const n=t.get(r),s=t=>{n.sym.get(t)||n.sym.set(t,0);const r=n.sym.get(t);return n.sym.set(t,r+1),e(`${t}${r}`)};n.loop||(n.loop="ijklmnopqrstuvxyz".split(""));return{gensym:s,genpattern:e=>{if(n.pattern.has(e))return n.pattern.get(e);const t=s("pattern");return r[t]=new RegExp(e,"u"),n.pattern.set(e,t),t},genloop:()=>{const t=n.loop.shift();return n.loop.push(`${t}${t[0]}`),e(t)},getref:e=>n.ref.get(e),genref:e=>{const t=s("ref");return n.ref.set(e,t),t},genformat:e=>{let t=n.format.get(e);return t||(t=s("format"),r[t]=e,n.format.set(e,t)),t}}}}}function E(){if(i)return o;i=1;const t=(e,r)=>{if(e===r)return!0;if(!e||!r||typeof e!=typeof r)return!1;if(e!==r&&"object"!=typeof e)return!1;const n=Object.getPrototypeOf(e);if(n!==Object.getPrototypeOf(r))return!1;if(n===Array.prototype)return!(!Array.isArray(e)||!Array.isArray(r))&&(e.length===r.length&&e.every(((e,n)=>t(e,r[n]))));if(n===Object.prototype){const[n,s]=[Object.keys(e),Object.keys(r)];if(n.length!==s.length)return!1;return new Set([...n,...s]).size===n.length&&n.every((n=>t(e[n],r[n])))}return!1},r=Function.prototype.call.bind(Object.prototype.hasOwnProperty);r[Symbol.for("toJayString")]="Function.prototype.call.bind(Object.prototype.hasOwnProperty)";const n=e=>/~\//.test(e)?`${e}`.replace(/~/g,"~0").replace(/\//g,"~1"):e;return o={stringLength:e=>/[\uD800-\uDFFF]/.test(e)?[...e].length:e.length,isMultipleOf:(e,t,r,n)=>{if(e%t==0)return!0;let s=e*r;if(s!==1/0&&s!==-1/0||(s=e),s%n==0)return!0;const o=Math.floor(s+.5);return o/r===e&&o%n==0},deepEqual:t,unique:e=>{if(e.length<2)return!0;if(2===e.length)return!t(e[0],e[1]);const r=[],n=e.length>20?new Set:null;let s=0,o=0;for(const t of e){if("object"==typeof t)r.push(t);else if(n){if(n.add(t),n.size!==++s)return!1}else if(-1!==e.indexOf(t,o+1))return!1;o++}for(let e=1;e<r.length;e++)for(let n=0;n<e;n++)if(t(r[e],r[n]))return!1;return!0},deBase64:t=>{if(void 0!==e)return e.from(t,"base64").toString("utf-8");const r=atob(t);return new TextDecoder("utf-8").decode(new Uint8Array(r.length).map(((e,t)=>r.charCodeAt(t))))},hasOwn:r,...{toPointer:e=>0===e.length?"#":`#/${e.map(n).join("/")}`,pointerPart:n,errorMerge:({keywordLocation:e,instanceLocation:t},r,n)=>({keywordLocation:`${r}${e.slice(1)}`,instanceLocation:`${n}${t.slice(1)}`}),propertyIn:(e,[t,r])=>t.includes(!0)||t.some((t=>t===e))||r.some((t=>new RegExp(t,"u").test(e))),dynamicResolve:(e,t)=>(e.filter((e=>e[t]))[0]||{})[t]}}}function k(){if(c)return a;c=1;const{format:e,safe:t}=O(),{scopeMethods:r}=x(),n=E(),s=new Map(Object.entries({null:t=>e("%s === null",t),boolean:t=>e('typeof %s === "boolean"',t),array:t=>e("Array.isArray(%s)",t),object:t=>e('typeof %s === "object" && %s && !Array.isArray(%s)',t,t,t),number:t=>e('typeof %s === "number"',t),integer:t=>e("Number.isInteger(%s)",t),string:t=>e('typeof %s === "string"',t)})),o=({name:r,parent:n,keyval:s,keyname:i})=>{if(r){if(n||s||i)throw new Error("name can be used only stand-alone");return r}if(!n)throw new Error("Can not use property of undefined parent!");const a=o(n);if(void 0!==s){if(i)throw new Error("Can not use key value and name together");if(!["string","number"].includes(typeof s))throw new Error("Invalid property path");return/^[a-z][a-z0-9_]*$/i.test(s)?e("%s.%s",a,t(s)):e("%s[%j]",a,s)}if(i)return e("%s[%s]",a,i);throw new Error("Unreachable")},i=new Set([].concat(...[Object,Array,String,Number,Boolean].map((e=>Object.getOwnPropertyNames(e.prototype))))),l=/^\([^)]*\) *=>/,u=/^[^=]*=>/,p=Symbol.for("toJayString");return a={types:s,buildName:o,jsHelpers:(t,a,c,{unmodifiedPrototypes:l,isJSON:u},p)=>{const{gensym:d,genpattern:f,genloop:m}=r(a,c);return{present:t=>{const r=o(t),{parent:s,keyval:c,keyname:p,inKeys:d,checked:f}=t;if(f||d&&u)throw new Error("Unreachable: useless check for undefined");if(d)return e("%s !== undefined",r);if(s&&p){a.hasOwn=n.hasOwn;const t=o(s);return u?e("%s !== undefined && hasOwn(%s, %s)",r,t,p):e("%s in %s && hasOwn(%s, %s)",p,t,t,p)}if(s&&void 0!==c){if(l&&u&&!i.has(`${c}`))return e("%s !== undefined",r);a.hasOwn=n.hasOwn;const t=o(s);return u?e("%s !== undefined && hasOwn(%s, %j)",r,t,c):e("%j in %s && hasOwn(%s, %j)",c,t,t,c)}throw new Error("Unreachable: present() check without parent")},forObjectKeys:(r,n)=>{const s=d("key");t.block(e("for (const %s of Object.keys(%s))",s,o(r)),(()=>{n(c(r,s,!0),s)}))},forArray:(r,n,s)=>{const i=m(),a=o(r);t.block(e("for (let %s = %s; %s < %s.length; %s++)",i,n,i,a,i),(()=>{s(c(r,i,l,!0),i)}))},patternTest:(t,r)=>{const n=t.replace(/[.^$|*+?(){}[\]\\]/gu,"");if(t===`^${n}$`)return e("(%s === %j)",r,t.slice(1,-1));if(p.has(t))return e("true");if([n,`${n}+`,`${n}.*`,`.*${n}.*`].includes(t))return e("%s.includes(%j)",r,n);if([`^${n}`,`^${n}+`,`^${n}.*`].includes(t))return e("%s.startsWith(%j)",r,n);if([`${n}$`,`.*${n}$`].includes(t))return e("%s.endsWith(%j)",r,n);const s=[...n].slice(0,-1).join("");return[`${n}*`,`${n}?`].includes(t)?0===s.length?e("true"):e("%s.includes(%j)",r,s):[`^${n}*`,`^${n}?`].includes(t)?0===s.length?e("true"):e("%s.startsWith(%j)",r,s):e("%s.test(%s)",f(t),r)},compare:(t,r)=>{if(!r||"object"!=typeof r)return e("%s === %j",t,r);let o;const i=e=>e.length<=3&&e.every((e=>!e||"object"!=typeof e));if(Array.isArray(r)){if(o=s.get("array")(t),i(r)){let n=e("%s.length === %d",t,r.length);for(let s=0;s<r.length;s++)n=e("%s && %s[%d] === %j",n,t,s,r[s]);return e("%s && %s",o,n)}}else{o=s.get("object")(t);const[c,l]=[Object.keys(r),Object.values(r)];if(i(l)){let s=e("Object.keys(%s).length === %d",t,c.length);c.length>0&&(a.hasOwn=n.hasOwn);for(const r of c)s=e("%s && hasOwn(%s, %j)",s,t,r);for(const n of c)s=e("%s && %s[%j] === %j",s,t,n,r[n]);return e("%s && %s",o,s)}}return a.deepEqual=n.deepEqual,e("%s && deepEqual(%s, %j)",o,t,r)},propvar:c}},jaystring:function(t){if("function"==typeof t){if(t[p])return t[p];if(Object.getPrototypeOf(t)!==Function.prototype)throw new Error("Can not stringify: a function with unexpected prototype");const e=`${t}`;if(t.prototype){if(!/^function[ (]/.test(e))throw new Error("Unexpected function");return e}if(l.test(e)||u.test(e))return e;throw new Error("Can not stringify: only either normal or arrow functions are supported")}if("object"==typeof t){const r=Object.getPrototypeOf(t);if(t instanceof RegExp&&r===RegExp.prototype)return e("%r",t);throw new Error("Can not stringify: an object with unexpected prototype")}throw new Error("Can not stringify: unknown type "+typeof t)}}}function A(){if(u)return l;u=1;const{format:e,safe:t,safenot:r}=O(),{jaystring:n}=k(),s=/[{[]/,o=/[}\]]/;return l=()=>{const i=[];let a=0;const c=()=>{if(0!==a)throw new Error("Unexpected indent at build()");const t=i.map((t=>e("%w%s",2*t.indent,t.code))).join("\n");return/^[a-z][a-z0-9]*$/i.test(t)?`return ${t}`:`return (${t})`},l=e=>{const t=Object.entries(e);for(const[e,r]of t){if(!/^[a-z][a-z0-9]*$/i.test(e))throw new Error("Unexpected scope key!");if(!("function"==typeof r||r instanceof RegExp))throw new Error("Unexpected scope value!")}return t};return{optimizedOut:!1,size:()=>i.length,write(t,...r){if("string"!=typeof t)throw new Error("Format must be a string!");if(t.includes("\n"))throw new Error("Only single lines are supported");var n;return n=e(t,...r),o.test(n.trim()[0])&&a--,i.push({indent:a,code:n}),s.test(n[n.length-1])&&a++,!0},block(e,t,r=!1){const n=a;this.write("%s {",e);const s=i.length;if(t(),s===i.length)return i.pop(),a=n,!1;if(s===i.length-1&&!r){const{code:t}=i[i.length-1];if(!/^(if|for) /.test(t))return i.length-=2,a=n,this.write("%s %s",e,t)}return this.write("}")},if(t,n,s){"false"==`${t}`?(s&&s(),n&&(this.optimizedOut=!0)):"true"==`${t}`?(n&&n(),s&&(this.optimizedOut=!0)):n&&this.block(e("if (%s)",t),n,!!s)?s&&this.block(e("else"),s):s&&this.if(r(t),s)},makeModule:(e={})=>`(function() {\n'use strict'\n${l(e).map((([e,r])=>`const ${t(e)} = ${n(r)};`)).join("\n")}\n${c()}})()`,makeFunction(e={}){const t=l(e),r=t.map((e=>e[0])),n=t.map((e=>e[1]));return Function(...r,`'use strict'\n${c()}`)(...n)}}}}function S(){if(d)return p;d=1;const e=["$schema","$vocabulary","id","$id","$anchor","$ref","definitions","$defs","$recursiveRef","$recursiveAnchor","$dynamicAnchor","$dynamicRef","type","required","default","enum","const","not","allOf","anyOf","oneOf","if","then","else","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","divisibleBy","items","maxItems","minItems","additionalItems","prefixItems","contains","minContains","maxContains","uniqueItems","maxLength","minLength","format","pattern","contentEncoding","contentMediaType","contentSchema","properties","maxProperties","minProperties","additionalProperties","patternProperties","propertyNames","dependencies","dependentRequired","dependentSchemas","propertyDependencies","unevaluatedProperties","unevaluatedItems","title","description","deprecated","readOnly","writeOnly","examples","$comment","example","discriminator","removeAdditional"],t=["draft/next","draft/2020-12","draft/2019-09","draft-07","draft-06","draft-04","draft-03"].map((e=>`https://json-schema.org/${e}/schema`)),r=["core","applicator","unevaluated","validation","meta-data","format-annotation","format-assertion","content"],n=[...["core","applicator","validation","meta-data","format","content"].map((e=>`https://json-schema.org/draft/2019-09/vocab/${e}`)),...r.map((e=>`https://json-schema.org/draft/2020-12/vocab/${e}`))];return p={knownKeywords:e,schemaVersions:t,knownVocabularies:n}}function z(){if(m)return f;m=1;const{knownKeywords:e}=S();function t(e,t,r,n="keys"){if(!e.has(t))return e.set(t,r);if(e.get(t)!==r)throw new Error(`Conflicting duplicate ${n}: ${t}`)}function r(e,t,r){if("object"!=typeof e)throw new Error("Invalid input object");if("string"!=typeof t)throw new Error("Invalid JSON pointer");const n=t.split("/");if(!["","#"].includes(n.shift()))throw new Error("Invalid JSON pointer");if(0===n.length)return e;let s=e;for(const e of n){if("string"!=typeof e)throw new Error("Invalid JSON pointer");r&&r.push(s);const t=(o=e).includes("~")?o.replace(/~[01]/g,(e=>{switch(e){case"~1":return"/";case"~0":return"~"}throw new Error("Unreachable")})):o;if("object"!=typeof s)return;if(!Object.prototype.hasOwnProperty.call(s,t))return;s=s[t]}var o;return s}const n=/^https?:\/\//;function s(e,t){if("string"!=typeof e||"string"!=typeof t)throw new Error("Unexpected path!");if(0===t.length)return e;const r=e.replace(/#.*/,"");return t.startsWith("#")?`${r}${t}`:!r.includes("/")||n.test(t)?t:n.test(r)?`${new URL(t,r)}`:t.startsWith("/")?t:[...r.split("/").slice(0,-1),t].join("/")}function o(e){return e.map((e=>e&&(e.$id||e.id)||"")).filter((e=>e&&"string"==typeof e)).reduce(s,"")}const i=["properties","patternProperties","$defs","definitions"],a=["const","enum","examples","example","comment"],c=Symbol("skip");function l(t,r){const n=(t,s=!1)=>{if(!t||"object"!=typeof t)return;const o=r(t);if(void 0!==o)return o===c?void 0:o;for(const r of Object.keys(t)){if(!s&&!Array.isArray(t)&&!e.includes(r))continue;if(!s&&a.includes(r))continue;const o=n(t[r],!s&&i.includes(r));if(void 0!==o)return o}};return n(t)}const u=(e,r,n=!1)=>{if(!Array.isArray(r))throw new Error("Expected an array of schemas");for(const s of r)l(s,(r=>{const o=r.$id||r.id,i=o&&"string"==typeof o?o.replace(/#$/,""):null;if(i&&i.includes("://")&&!i.includes("#"))t(e,i,r,"schema $id in 'schemas'");else if(r===s&&!n)throw new Error("Schema with missing or invalid $id in 'schemas'")}));return e},p=(e,t)=>{if(t)return u(p(e),t,!0);if(e)switch(Object.getPrototypeOf(e)){case Object.prototype:return new Map(Object.entries(e));case Map.prototype:return new Map(e);case Array.prototype:return u(new Map,e)}throw new Error("Unexpected value for 'schemas' option")};return f={get:r,joinPath:s,resolveReference:function t(n,c,l,u=""){const p=s(u,l),d=[],[f,m=""]=p.split("#"),y=decodeURI(m),h=(t,c,l=!1,u=!1)=>{if(!t||"object"!=typeof t)return;const m=t.$id||t.id;let g=c;if(m&&"string"==typeof m)if(g=s(g,m),g===p||g===f&&""===y)d.push([t,n,c]);else if(g===f&&"/"===y[0]){const e=[],i=r(t,y,e);void 0!==i&&d.push([i,n,s(c,o(e))])}const w=u?t.$dynamicAnchor:t.$anchor;if(w&&"string"==typeof w){if(w.includes("#"))throw new Error("$anchor can't include '#'");if(w.startsWith("/"))throw new Error("$anchor can't start with '/'");g=s(g,`#${w}`),g===p&&d.push([t,n,c])}for(const r of Object.keys(t))(l||Array.isArray(t)||e.includes(r))&&(!l&&a.includes(r)||h(t[r],g,!l&&i.includes(r)));!u&&t.$dynamicAnchor&&h(t,c,l,!0)};if(h(n,f),f===u.replace(/#$/,"")&&("/"===y[0]||""===y)){const e=[],t=r(n,y,e);void 0!==t&&d.push([t,n,o(e)])}if(c.has(f)&&c.get(f)!==n){const e=t(c.get(f),c,`#${m}`,f);d.push(...e.map((([e,t,r])=>[e,t,s(f,r)])))}return c.has(p)&&d.push([c.get(p),c.get(p),p]),d},getDynamicAnchors:function(e){const r=new Map;return l(e,(n=>{if(n!==e&&(n.$id||n.id))return c;const s=n.$dynamicAnchor;if(s&&"string"==typeof s){if(s.includes("#"))throw new Error("$dynamicAnchor can't include '#'");if(!/^[a-zA-Z0-9_-]+$/.test(s))throw new Error(`Unsupported $dynamicAnchor: ${s}`);t(r,s,n,"$dynamicAnchor")}})),r},hasKeywords:(e,t)=>l(e,(e=>Object.keys(e).some((e=>t.includes(e)))||void 0))||!1,buildSchemas:p},f}function M(){if(h)return y;h=1;const e={email:e=>{if(e.length>318)return!1;if(/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(e))return!0;if(!e.includes("@")||/(^\.|^"|\.@|\.\.)/.test(e))return!1;const[t,r,...n]=e.split("@");return!(!t||!r||0!==n.length||t.length>64||r.length>253)&&(!(!/^[a-z0-9.-]+$/i.test(r)||!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(t))&&r.split(".").every((e=>/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(e))))},hostname:e=>{if(e.length>(e.endsWith(".")?254:253))return!1;return/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i.test(e)},date:e=>{if(10!==e.length)return!1;if("0"===e[5]&&"2"===e[6]){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(e))return!0;const t=e.match(/^(\d\d\d\d)-02-29$/);if(!t)return!1;const r=0|t[1];return r%16==0||r%4==0&&r%25!=0}return e.endsWith("31")?/^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(e):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(e)},time:e=>{if(e.length>27)return!1;if(!/^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i.test(e))return!1;if(!/:60/.test(e))return!0;const t=e.match(/([0-9.]+|[^0-9.])/g);let r=60*Number(t[0])+Number(t[2]);return"+"===t[5]?r+=1440-60*Number(t[6]||0)-Number(t[8]||0):"-"===t[5]&&(r+=60*Number(t[6]||0)+Number(t[8]||0)),r%1440==1439},"date-time":e=>{if(e.length>38)return!1;const t="0"===e[5]&&"2"===e[6];if(t&&"3"===e[8]||!/^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i.test(e))return!1;if("6"===e[17]){const t=e.slice(11).match(/([0-9.]+|[^0-9.])/g);let r=60*Number(t[0])+Number(t[2]);if("+"===t[5]?r+=1440-60*Number(t[6]||0)-Number(t[8]||0):"-"===t[5]&&(r+=60*Number(t[6]||0)+Number(t[8]||0)),r%1440!=1439)return!1}if(t){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(e))return!0;const t=e.match(/^(\d\d\d\d)-02-29/);if(!t)return!1;const r=0|t[1];return r%16==0||r%4==0&&r%25!=0}return"3"===e[8]&&"1"===e[9]?/^\d\d\d\d-(?:0[13578]|1[02])-31/.test(e):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(e)},ipv4:e=>e.length<=15&&/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(e),ipv6:e=>{if(e.length>45||e.length<2)return!1;let t=0,r=0,n=0,s=!1,o=!1,i=0,a=!0;for(let c=0;c<e.length;c++){const l=e.charCodeAt(c);if(1===c&&58===i&&58!==l)return!1;if(l>=48&&l<=57){if(++n>4)return!1}else if(46===l){if(t>6||r>=3||0===n||o)return!1;r++,n=0}else if(58===l){if(r>0||t>=7)return!1;if(58===i){if(s)return!1;s=!0}else 0===c&&(a=!1);t++,n=0,o=!1}else{if(!(l>=97&&l<=102||l>=65&&l<=70))return!1;if(r>0)return!1;if(++n>4)return!1;o=!0}i=l}if(t<2||r>0&&(3!==r||0===n))return!1;if(s&&2===e.length)return!0;if(r>0&&!/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(e))return!1;const c=r>0?6:7;return s?(a||n>0)&&t<c:t===c&&a&&n>0},uri:/^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,"json-pointer":/^(?:|\/(?:[^~]|~0|~1)*)$/,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,uuid:/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,duration:e=>e.length>1&&e.length<80&&(/^P\d+([.,]\d+)?W$/.test(e)||/^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(e)&&/^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(e))};return y={core:e,extra:{alpha:/^[a-zA-Z]+$/,alphanumeric:/^[a-zA-Z0-9]+$/,"hex-digits":/^[0-9a-f]+$/i,"hex-digits-prefixed":/^0x[0-9a-f]+$/i,"hex-bytes":/^([0-9a-f][0-9a-f])+$/i,"hex-bytes-prefixed":/^0x([0-9a-f][0-9a-f])+$/i,base64:e=>e.length%4==0&&/^[a-z0-9+/]*={0,3}$/i.test(e),"json-pointer-uri-fragment":/^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,"host-name":e.hostname,"ip-address":e.ipv4,color:/^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/},weak:{regex:e=>{if(e.length>1e5)return!1;if(/[^\\]\\Z/.test(e))return!1;try{return new RegExp(e,"u"),!0}catch(e){return!1}}}}}function q(){if($)return b;$=1;const{format:e,safe:t,safeand:r,safenot:n,safenotor:s}=O(),o=A(),{resolveReference:i,joinPath:a,getDynamicAnchors:c,hasKeywords:l}=z(),u=M(),{toPointer:p,...d}=E(),{scopeMethods:f}=x(),{buildName:m,types:y,jsHelpers:h}=k(),{knownKeywords:v,schemaVersions:j,knownVocabularies:q}=S(),{initTracing:N,andDelta:P,orDelta:I,applyDelta:R,isDynamic:U,inProperties:C}=function(){if(w)return g;w=1;const e=(e,t)=>[...new Set([...e,...t])].sort(),t=(e,t)=>e.filter((e=>t.includes(e))),r=e=>(...t)=>s(e(...t.map(s))),n=(e,t)=>e&&!e.includes(t),s=({type:t=null,dyn:r={},...s})=>({type:t?[...t].sort():t,items:n(t,"array")?1/0:s.items||0,properties:n(t,"object")?[!0]:[...s.properties||[]].sort(),patterns:n(t,"object")?[]:[...s.patterns||[]].sort(),required:n(t,"object")?[]:[...s.required||[]].sort(),fullstring:n(t,"string")||s.fullstring||!1,dyn:{item:!n(t,"array")&&(r.item||!1),items:n(t,"array")?0:Math.max(s.items||0,r.items||0),properties:n(t,"object")?[]:e(s.properties||[],r.properties||[]),patterns:n(t,"object")?[]:e(s.patterns||[],r.patterns||[])},unknown:s.unknown&&!(n(t,"object")&&n(t,"array"))||!1}),o=r(((r,n)=>({type:r.type&&n.type?t(r.type,n.type):r.type||n.type||null,items:Math.max(r.items,n.items),properties:e(r.properties,n.properties),patterns:e(r.patterns,n.patterns),required:e(r.required,n.required),fullstring:r.fullstring||n.fullstring,dyn:{item:r.dyn.item||n.dyn.item,items:Math.max(r.dyn.items,n.dyn.items),properties:e(r.dyn.properties,n.dyn.properties),patterns:e(r.dyn.patterns,n.dyn.patterns)},unknown:r.unknown||n.unknown}))),i=(e,t)=>!0!==t&&new RegExp(e,"u").test(t),a=({properties:t,patterns:r},{properties:n,patterns:s})=>{const o=t.filter((e=>n.includes(e)||n.includes(!0)||s.some((t=>i(t,e))))),a=n.filter((e=>t.includes(e)||t.includes(!0)||r.some((t=>i(t,e))))),c=r.filter((e=>s.includes(e)||n.includes(!0))),l=s.filter((e=>r.includes(e)||t.includes(!0)));return{properties:e(o,a),patterns:e(c,l)}},c=({properties:e,patterns:t},{properties:r,patterns:n})=>r.every((r=>e.includes(r)||e.includes(!0)||t.some((e=>i(e,r)))))&&n.every((r=>t.includes(r)||e.includes(!0))),l=r(((r,s)=>({type:r.type&&s.type?e(r.type,s.type):null,items:Math.min(r.items,s.items),...a(r,s),required:n(r.type,"object")&&s.required||n(s.type,"object")&&r.required||t(r.required,s.required),fullstring:r.fullstring&&s.fullstring,dyn:{item:r.dyn.item||s.dyn.item,items:Math.max(r.dyn.items,s.dyn.items),properties:e(r.dyn.properties,s.dyn.properties),patterns:e(r.dyn.patterns,s.dyn.patterns)},unknown:r.unknown||s.unknown}))),u=(p=({unknown:e,items:t,dyn:r,...n})=>({items:t!==1/0&&(e||r.items>t||r.item),properties:!n.properties.includes(!0)&&(e||!c(n,r))}),(...e)=>p(...e.map(s)));var p;return g={initTracing:()=>s({}),andDelta:o,orDelta:l,applyDelta:(e,t)=>Object.assign(e,o(e,t)),isDynamic:u,inProperties:c}}(),D=new Set(["^[\\s\\S]*$","^[\\S\\s]*$","^[^]*$","",".*","^","$"]),_=["null","boolean","number","integer","string"],L=new Map(Object.entries({boolean:e=>"boolean"==typeof e,array:e=>Array.isArray(e)&&Object.getPrototypeOf(e)===Array.prototype,object:e=>e&&Object.getPrototypeOf(e)===Object.prototype,finite:e=>Number.isFinite(e),natural:e=>Number.isInteger(e)&&e>=0,string:e=>"string"==typeof e,jsonval:e=>d.deepEqual(e,JSON.parse(JSON.stringify(e)))})),J=L.get("object"),F=e=>J(e)||"boolean"==typeof e,T=(e,t)=>j.indexOf(e)>j.indexOf(`https://json-schema.org/${t}/schema`),V=(e,t)=>{const r=`${e}`.replace(/^http:\/\//,"https://").replace(/#$/,"");return!j.includes(r)||T(r,t)},W=(e,t,r=!1,n=!1)=>Object.freeze({parent:e,keyname:t,inKeys:r,number:n}),K=Symbol("evaluatedStatic"),B=Symbol("optDynamic"),H=Symbol("optDynAnchors"),Z=Symbol("optRecAnchors"),Y=new Set,G=new Map,Q=(g,w,b,$,O="")=>{const{mode:x="default",useDefaults:E=!1,removeAdditional:k=!1,includeErrors:A=!1,allErrors:S=!1,contentValidation:z,dryRun:M,lint:X=!1,allowUnusedKeywords:ee="lax"===b.mode||"spec"===b.mode,allowUnreachable:te="lax"===b.mode||"spec"===b.mode,requireSchema:re="strong"===b.mode,requireValidation:ne="strong"===b.mode,requireStringValidation:se="strong"===b.mode,forbidNoopValues:oe="strong"===b.mode,complexityChecks:ie="strong"===b.mode,unmodifiedPrototypes:ae=!1,isJSON:ce=!1,$schemaDefault:le=null,formatAssertion:ue="spec"!==b.mode||V(w.$schema,"draft/2019-09"),formats:pe={},weakFormats:de="strong"!==b.mode,extraFormats:fe=!1,schemas:me,...ye}=b,he={...u.core,...de?u.weak:{},...fe?u.extra:{},...pe};if(0!==Object.keys(ye).length)throw new Error(`Unknown options: ${Object.keys(ye).join(", ")}`);if(!["strong","lax","default","spec"].includes(x))throw new Error(`Invalid mode: ${x}`);if(!A&&S)throw new Error("allErrors requires includeErrors to be enabled");if(re&&le)throw new Error("requireSchema forbids $schemaDefault");if("strong"===x){const e={...{requireValidation:ne,requireStringValidation:se},formatAssertion:ue,complexityChecks:ie,requireSchema:re},t={weakFormats:de,allowUnusedKeywords:ee};for(const[t,r]of Object.entries(e))if(!r)throw new Error(`Strong mode demands ${t}`);for(const[e,r]of Object.entries(t))if(r)throw new Error(`Strong mode forbids ${e}`)}const{gensym:ge,getref:we,genref:be,genformat:$e}=f($),ve=be(g);let je=null;const Oe=(...e)=>{const t=je(...e);return Oe.errors=je.errors,t};$[ve]=Oe;const xe=l(g,["$ref","$recursiveRef","$dynamicRef"]),Ee=b[H]&&xe&&l(g,["$dynamicAnchor"]),ke=b[Z]?e(", recursive"):e(""),Ae=o();Ae.write("function validate(data%s%s) {",ke,b[H]?e(Ee?", dynAnchors = []":", dynAnchors"):e("")),A&&Ae.write("validate.errors = null"),S&&Ae.write("let errorCount = 0"),b[B]&&Ae.write("validate.evaluatedDynamic = null");let Se=b[H]?e(", dynAnchors"):e("");Ee&&(Ae.write("const dynLocal = [{}]"),Se=e(", [...dynAnchors, dynLocal[0] || []]"));const ze=h(Ae,$,W,{unmodifiedPrototypes:ae,isJSON:ce},D),{present:Me,forObjectKeys:qe,forArray:Ne,patternTest:Pe,compare:Ie}=ze,Re=[],Ue=()=>G.get(w),Ce=O?[O]:[],De=(o,l,f,h,M,V={},{constProp:W}={})=>{const ae=l.length>0&&l[l.length-1].prop===f,de=()=>l.filter((e=>e.prop===f)),fe=!f.parent||f.checked||f.inKeys&&ce||de().length>0,ye=m(f),be=(...e)=>((e,t,r=!1)=>Object.freeze({parent:e,keyval:t,checked:r}))(f,...e),je=({path:t=[],prop:r=f,source:n,suberr:s})=>{const i=p([...M,...t]),a=A?(t=>{const r=[];let n=t;for(;n;)n.name||r.unshift(n),n=n.parent||n.errorParent;if(r.every((e=>void 0!==e.keyval)))return e("%j",p(r.map((e=>e.keyval))));const s=["#"],o=()=>{const e=s.map(d.pointerPart).join("/");return s.length=0,e};let i=null;for(const{keyname:t,keyval:n,number:a}of r)if(t){a||($.pointerPart=d.pointerPart);const r=a?t:e("pointerPart(%s)",t),n=`${o()}/`;i=i?e("%s+%j+%s",i,n,r):e("%j+%s",n,r)}else n&&s.push(n);return s.length>0?e("%s+%j",i,`/${o()}`):i})(r):null;if(!0===A&&o&&n){$.errorMerge=d.errorMerge;const e=[n,i,a];S?(Ae.write("if (validate.errors === null) validate.errors = []"),Ae.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))",...e)):Ae.write("validate.errors = [errorMerge(%s[0], %j, %s)]",...e)}else if(!0===A&&o){const t=e("{ keywordLocation: %j, instanceLocation: %s }",i,a);S?(Ae.write("if (%s === null) %s = []",o,o),Ae.write("%s.push(%s)",o,t)):Ae.write("%s = [%s]",o,t)}s&&xt(s),S?Ae.write("errorCount++"):Ae.write("return false")},Oe=(e,t)=>Ae.if(e,(()=>je(t)));X&&!$.lintErrors&&($.lintErrors=[]);const xe=(e,t)=>{const r=void 0!==t?` ${JSON.stringify(t)}`:"",n=a(O,p(M)),s=`${e}${r} at ${n}`;if(X)return $.lintErrors.push({message:s,keywordLocation:n,schema:g});throw new Error(s)},ke=(t,r)=>{try{return Pe(t,r)}catch(t){return xe(t.message),e("false")}},ze=(e,...t)=>e||xe(...t),_e=(e,...t)=>ze("lax"===x||"spec"===x||e,...t),Le=(e,t)=>_e(!(h[t]<h[e]),`Invalid ${e} / ${t} combination`),Je=(e,t="should be specified")=>ze(!ne,`[requireValidation] ${e} ${t}`),Fe=(...e)=>[...M,...e],Te=e=>ze(!k&&!E,`[removeAdditional/useDefaults] uncertain: ${e}`),Ve=(e,t)=>ze(!ie,`[complexityChecks] ${e}`,t),We=e=>((e,t,r,n)=>{if(t){const n=t.replace(/^http:\/\//,"https://").replace(/#$/,"");r(j.includes(n),"Unexpected schema version:",n),G.set(e,{exclusiveRefs:T(n,"draft/2019-09"),contentValidation:T(n,"draft/2019-09"),dependentUnsupported:T(n,"draft/2019-09"),newItemsSyntax:!T(n,"draft/2020-12"),containsEvaluates:!T(n,"draft/2020-12"),objectContains:!T(n,"draft/next"),bookending:T(n,"draft/next")})}else r(!n,"[requireSchema] $schema is required"),G.set(e,{})})(w,e||le,ze,re),Ke=N(),Be=e=>R(Ke,e);if("boolean"==typeof h)return!0===h?(Je("schema = true","is not allowed"),{stat:Ke}):(Oe(!(!fe&&!f.inKeys)||Me(f),{}),Be({type:[]}),{stat:Ke});ze(J(h),"Schema is not an object");for(const e of Object.keys(h))ze(v.includes(e)||ee,"Keyword not supported:",e);if(0===Object.keys(h).length)return Je("empty rules node","is not allowed"),{stat:Ke};const He=new Set(Object.keys(h)),Ze=new Set,Ye=(e,...t)=>{ze(Ze.has(e)||He.has(e),"Unexpected double consumption:",e),ze(d.hasOwn(h,e),"Is not an own property:",e),ze(t.every((e=>L.has(e))),"Invalid type used in consume"),ze(t.some((t=>L.get(t)(h[e]))),"Unexpected type for",e),He.delete(e)},Ge=(e,...t)=>(void 0!==h[e]&&Ye(e,...t),h[e]),Qe=(e,t,r,n={})=>{if(void 0===h[e])return!1;if(Ye(e,...t),null!==r)try{const t=r(h[e]);null!==t&&Oe(t,{path:[e],...n})}catch(e){if(!X||e.message.startsWith("[opt] "))throw e;xe(e.message)}return!0};if(h===w?(We(Ge("$schema","string")),Qe("$vocabulary",["object"],(e=>{for(const[t,r]of Object.entries(e))!1!==r&&ze(!0===r&&q.includes(t),"Unknown vocabulary:",t);return null}))):Ue()||We(w.$schema),Ue().objectContains)for(const e of["contains","minContains","maxContains"])Ze.add(e);Qe("examples",["array"],null),Qe("example",["jsonval"],null);for(const e of["title","description","$comment"])Qe(e,["string"],null);for(const e of["deprecated","readOnly","writeOnly"])Qe(e,["boolean"],null);Qe("$defs",["object"],null)||Qe("definitions",["object"],null);const Xe=(e,r,n)=>e===g?t("validate"):we(e)||Q(e,r,b,$,n),et=()=>Ce.length>0?Ce[Ce.length-1]:"",tt=Ce.length,rt=e=>(Ce.push(a(et(),e)),null);Ue().exclusiveRefs&&h.$ref||(Qe("$id",["string"],rt)||Qe("id",["string"],rt),Qe("$anchor",["string"],null),Qe("$dynamicAnchor",["string"],null),!h.$recursiveAnchor&&oe||Qe("$recursiveAnchor",["boolean"],(e=>(e&&Re.push([h,w,et()]),null))));const nt=Ee&&(h===g||h.id||h.$id);if(nt){const e=c(h);h!==g&&Ae.write("dynLocal.unshift({})");for(const[t,r]of e){const e=i(w,me,`#${t}`,et()),[n,s,o]=e[0]||[];ze(n===r,`Unexpected $dynamicAnchor resolution: ${t}`);const a=Xe(n,s,o);Ae.write("dynLocal[0][%j] = %s",`#${t}`,a)}}const st=e=>b[B]&&(h[e]||!1===h[e]||h===g),ot=Object.freeze({item:st("unevaluatedItems")?ge("evaluatedItem"):null,items:st("unevaluatedItems")?ge("evaluatedItems"):null,props:st("unevaluatedProperties")?ge("evaluatedProps"):null}),it=Object.freeze({item:ot.item||V.item,items:ot.items||V.items,props:ot.props||V.props}),at=()=>(!it.items||Ke.items===1/0)&&(!it.props||Ke.properties.includes(!0)),ct=e=>{if(it.item&&e.item&&Ke.items!==1/0&&Ae.write("%s.push(%s)",it.item,e.item),it.items&&e.items>Ke.items&&Ae.write("%s.push(%d)",it.items,e.items),it.props&&(e.properties||[]).includes(!0)&&!Ke.properties.includes(!0))Ae.write("%s[0].push(true)",it.props);else if(it.props){const t=(e,t)=>C(Ke,{properties:e,patterns:t}),r=(e.properties||[]).filter((e=>!t([e],[]))),n=(e.patterns||[]).filter((e=>!t([],[e])));r.length>0&&Ae.write("%s[0].push(...%j)",it.props,r),n.length>0&&Ae.write("%s[1].push(...%j)",it.props,n);for(const t of e.propertiesVars||[])Ae.write("%s[0].push(%s)",it.props,t)}},lt=(e,t,r,n)=>{U(Ke).items&&e.item&&t&&Ae.write("%s.push(...%s)",e.item,t),U(Ke).items&&e.items&&r&&Ae.write("%s.push(...%s)",e.items,r),U(Ke).properties&&e.props&&n&&(Ae.write("%s[0].push(...%s[0])",e.props,n),Ae.write("%s[1].push(...%s[1])",e.props,n))},ut=(t,r)=>{const s=$[t]&&$[t][K]||{unknown:!0};Be(s);const o=e("%s(%s%s%s)",t,ye,b[Z]?0===Re.length?e(", recursive"):e(", recursive || %s",Xe(...Re[0])):e(""),Se);if(!A&&at())return e("!%s",o);const i=ge("res"),a=ge("err"),c=ge("suberr");return A&&Ae.write("const %s = validate.errors",a),Ae.write("const %s = %s",i,o),A&&Ae.write("const %s = %s.errors",c,t),A&&Ae.write("validate.errors = %s",a),Oe(n(i),{...r,source:c}),Ae.if(i,(()=>{const r=U(s).items?e("%s.evaluatedDynamic[0]",t):null,n=U(s).items?e("%s.evaluatedDynamic[1]",t):null,o=U(s).properties?e("%s.evaluatedDynamic[2]",t):null;lt(it,r,n,o)})),null},pt=(e,t)=>e&&e.every((e=>t.includes(e))),dt=(e,t)=>t.some((t=>null===e||e.includes(t))),ft=(...e)=>de().some((t=>pt(t.stat.type,e))),mt=(...e)=>dt(Ke.type,e)&&de().every((t=>dt(t.stat.type,e))),yt=(e,t=h)=>{ze("string"==typeof e,"Invalid pattern:",e),(ne||se)&&ze(/^\^.*\$$/.test(e),"Should start with ^ and end with $:",e),/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(e)&&void 0===t.maxLength&&Ve("maxLength should be specified for pattern:",e)},ht=h.pattern&&!D.has(h.pattern),gt=h.uniqueItems||ht||h.patternProperties||h.format,wt=S&&gt?ge("prev"):null,bt=(t,r)=>Ae.if(!t||null===wt||e("errorCount === %s",wt),r),$t=()=>[...l,{stat:Ke,prop:f}],vt=(...e)=>De(o,$t(),...e).stat,jt=(t,...r)=>{if(r[0]===f){const t=(e=>"boolean"==typeof e?e:!(!J(e)||0!==Object.keys(e).length)||void 0)(r[1]);if(!0===t)return{sub:e("true"),delta:{}};if(!1===t)return{sub:e("false"),delta:{type:[]}}}const n=ge("sub");Ae.write("const %s = (() => {",n),S&&Ae.write("let errorCount = 0");const{stat:s}=De(t,$t(),...r);return S?Ae.write("return errorCount === 0"):Ae.write("return true"),Ae.write("})()"),{sub:n,delta:s}},Ot=()=>{const e=A&&S?ge("suberr"):null;return e&&Ae.write("let %s = null",e),e},xt=e=>{null!==o&&null!==e&&Ae.if(e,(()=>Ae.write("%s.push(...%s)",o,e)))},Et=()=>{if(!k)return!1;if(!0===k)return!0;if("keyword"===k)return!!h.removeAdditional&&(Ye("removeAdditional","boolean"),!0);throw new Error(`Invalid removeAdditional: ${k}`)},kt=(t,r,n)=>{Qe(t,["object","boolean"],(s=>!1===s&&Et()?(Ae.write("if (%s.length > %s) %s.length = %s",ye,r,ye,r),null):!1!==s||n?(Ne(f,r,((e,r)=>(n&&Ae.write("if (%s) continue",n(r)),vt(e,s,Fe(t))))),null):e("%s.length > %s",ye,r)))&&Be({items:1/0})},At=(e,t)=>{Qe(e,["object","boolean"],(r=>(qe(f,((n,s)=>{Ae.if(t(s),(()=>{!1===r&&Et()?Ae.write("delete %s[%s]",ye,s):vt(n,r,Fe(e))}))})),null)))&&Be({properties:[!0]})},St=(t,s,o)=>r(...s.map((r=>e("%s !== %j",t,r))),...o.map((e=>n(ke(e,t))))),zt=(e,t)=>{const r=t.map((e=>new RegExp(e,"u"))),n=t=>e.includes(t)||r.some((e=>e.test(t)));for(const e of Ke.required)ze(n(e),"Unknown required property:",e)},Mt=[],qt=()=>{const t=(t,r)=>e("!(%d %c %s)",t,r,ye);Number.isFinite(h.exclusiveMinimum)?Qe("exclusiveMinimum",["finite"],(e=>t(e,"<"))):(Qe("minimum",["finite"],(e=>t(e,h.exclusiveMinimum?"<":"<="))),Qe("exclusiveMinimum",["boolean"],null)),Number.isFinite(h.exclusiveMaximum)?(Qe("exclusiveMaximum",["finite"],(e=>t(e,">"))),Le("minimum","exclusiveMaximum"),Le("exclusiveMinimum","exclusiveMaximum")):void 0!==h.maximum&&(Qe("maximum",["finite"],(e=>t(e,h.exclusiveMaximum?">":">="))),Qe("exclusiveMaximum",["boolean"],null),Le("minimum","maximum"),Le("exclusiveMinimum","maximum"));const r=void 0===h.multipleOf?"divisibleBy":"multipleOf";Qe(r,["finite"],(t=>{ze(t>0,`Invalid ${r}:`,t);const[n,s]=`${t}`.split("e-"),o=`${n}.`.split(".")[1].length+(s?Number(s):0);if(Number.isInteger(t*2**o))return e("%s %% %d !== 0",ye,t);$.isMultipleOf=d.isMultipleOf;const i=[ye,t,o,Math.round(t*Math.pow(10,o))];return e("!isMultipleOf(%s, %d, 1e%d, %d)",...i)}))},Nt=()=>{Qe("maxLength",["natural"],(t=>($.stringLength=d.stringLength,e("%s.length > %d && stringLength(%s) > %d",ye,t,ye,t)))),Qe("minLength",["natural"],(t=>($.stringLength=d.stringLength,e("%s.length < %d || stringLength(%s) < %d",ye,t,ye,t)))),Le("minLength","maxLength"),bt(!0,(()=>{const t=(t,r,n=he)=>{const s="string"==typeof t&&d.hasOwn(n,t);ze(s,"Unrecognized format used:",t);const o=n[t],i=o instanceof RegExp||"function"==typeof o;return ze(i,"Invalid format used:",t),ue?o instanceof RegExp?(d.hasOwn(pe,t)&&yt(o.source),e("!%s.test(%s)",$e(o),r)):e("!%s(%s)",$e(o),r):null};Qe("format",["string"],(e=>(Be({fullstring:!0}),t(e,ye)))),Qe("pattern",["string"],(e=>(yt(e),Be({fullstring:!0}),D.has(e)?null:n(ke(e,ye))))),ze(!1!==h.contentSchema,"contentSchema cannot be set to false");const r=void 0===z?Ue().contentValidation:z,s=h.contentEncoding||h.contentMediaType||h.contentSchema;if(ze(!s||r||ee,'"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)'),s&&r){const e=ge("dec");h.contentMediaType&&Ae.write("let %s = %s",e,ye),"base64"===h.contentEncoding?(Oe(t("base64",ye,u.extra),{path:["contentEncoding"]}),h.contentMediaType&&($.deBase64=d.deBase64,Ae.write("try {"),Ae.write("%s = deBase64(%s)",e,e)),Ye("contentEncoding","string")):ze(!h.contentEncoding,"Unknown contentEncoding:",h.contentEncoding);let r=!1;if("application/json"===h.contentMediaType?(Ae.write("try {"),Ae.write("%s = JSON.parse(%s)",e,e),r=!0,Ye("contentMediaType","string")):ze(!h.contentMediaType,"Unknown contentMediaType:",h.contentMediaType),h.contentSchema){ze(r,"contentSchema requires contentMediaType application/json");const t=Object.freeze({name:e,errorParent:f});vt(t,h.contentSchema,Fe("contentSchema")),Ye("contentSchema","object","array"),Be({fullstring:!0})}h.contentMediaType&&(Ae.write("} catch (e) {"),je({path:["contentMediaType"]}),Ae.write("}"),h.contentEncoding&&(Ae.write("} catch (e) {"),je({path:["contentEncoding"]}),Ae.write("}")))}}))},Pt=()=>{Qe("maxItems",["natural"],(t=>{const r=Ue().newItemsSyntax?"prefixItems":"items";return Array.isArray(h[r])&&h[r].length>t&&xe(`Invalid maxItems: ${t} is less than ${r} array length`),e("%s.length > %d",ye,t)})),Qe("minItems",["natural"],(t=>e("%s.length < %d",ye,t))),Le("minItems","maxItems");const t=e=>{for(let t=0;t<e.length;t++)vt(be(t),e[t],Fe(`${t}`));return Be({items:e.length}),null};Ue().newItemsSyntax?(Qe("prefixItems",["array"],t),kt("items",e("%d",(h.prefixItems||[]).length))):Array.isArray(h.items)?(Qe("items",["array"],t),kt("additionalItems",e("%d",h.items.length))):Qe("items",["object","boolean"],(t=>(Ne(f,e("0"),(e=>vt(e,t,Fe("items")))),Be({items:1/0}),null))),Ut((t=>{Ne(f,e("0"),((e,r)=>{t(e,(()=>{Be({dyn:{item:!0}}),ct({item:r})}))}))}));const r=e=>{if(!J(e))return!1;if(e.enum||d.hasOwn(e,"const"))return!0;if(e.type){if((Array.isArray(e.type)?e.type:[e.type]).every((e=>_.includes(e))))return!0}if(e.$ref){const[t]=i(w,me,e.$ref,et())[0]||[];if(r(t))return!0}return!1},n=e=>!1===e||r(e);bt(!0,(()=>{Qe("uniqueItems",["boolean"],(t=>!1===t?null:(void 0!==h.maxItems||n(h.items)||Array.isArray(h.items)&&n(h.additionalItems)||Ve("maxItems should be specified for non-primitive uniqueItems"),Object.assign($,{unique:d.unique,deepEqual:d.deepEqual}),e("!unique(%s)",ye))))}))},It=e=>!S&&(Ke.required.includes(e)||de().some((t=>t.stat.required.includes(e)))),Rt=()=>{const t=e("Object.keys(%s).length",ye);Qe("maxProperties",["natural"],(r=>e("%s > %d",t,r))),Qe("minProperties",["natural"],(r=>e("%s < %d",t,r))),Le("minProperties","maxProperties"),Qe("propertyNames",["object","boolean"],(e=>(qe(f,((t,r)=>{const n="object"!=typeof e||e.$ref?e:{type:"string",...e},s=Object.freeze({name:r,errorParent:t,type:"string"});vt(s,n,Fe("propertyNames"))})),null))),Qe("required",["array"],(e=>{for(const t of e){if(It(t))continue;const e=be(t);Oe(n(Me(e)),{path:["required"],prop:e})}return Be({required:e}),null}));for(const e of["dependencies","dependentRequired","dependentSchemas"])"dependencies"!==e&&Ue().dependentUnsupported||Qe(e,["object"],(t=>{for(const s of Object.keys(t)){const o="string"==typeof t[s]?[t[s]]:t[s],i=be(s,It(s));if(Array.isArray(o)&&"dependentSchemas"!==e){const t=o.filter((e=>!It(e))).map((e=>Me(be(e)))),a=n(r(...t)),c={path:[e,s]};0===t.length||(i.checked?(Oe(a,c),Be({required:o})):Oe(r(Me(i),a),c))}else F(o)&&"dependentRequired"!==e?(Te(e),Ae.if(!!i.checked||Me(i),(()=>{const t=vt(f,o,Fe(e,s),it);Be(I({},t)),ct(t)}))):xe(`Unexpected ${e} entry`)}return null}));Qe("propertyDependencies",["object"],(e=>{for(const[t,r]of Object.entries(e)){ze(J(r),"propertyDependencies must be an object"),Te("propertyDependencies");const e=be(t,It(t));Ae.if(!!e.checked||Me(e),(()=>{for(const[n,s]of Object.entries(r))ze(F(s),"propertyDependencies must contain schemas"),Ae.if(Ie(m(e),n),(()=>{const e=vt(f,s,Fe("propertyDependencies",t,n),it);Be(I({},e)),ct(e)}))}))}return null})),Qe("properties",["object"],(e=>{for(const t of Object.keys(e))W!==t&&vt(be(t,It(t)),e[t],Fe("properties",t));return Be({properties:Object.keys(e)}),null})),bt(h.patternProperties,(()=>{if(Qe("patternProperties",["object"],(e=>(qe(f,((t,r)=>{for(const n of Object.keys(e))yt(n,h.propertyNames||{}),Ae.if(ke(n,r),(()=>{vt(t,e[n],Fe("patternProperties",n))}))})),Be({patterns:Object.keys(e)}),null))),h.additionalProperties||!1===h.additionalProperties){const e=Object.keys(h.properties||{}),t=Object.keys(h.patternProperties||{});!1===h.additionalProperties&&Mt.push((()=>zt(e,t)));At("additionalProperties",(r=>St(r,e,t)))}})),Ue().objectContains&&Ut((e=>{qe(f,((t,r)=>{e(t,(()=>{Be({dyn:{properties:[!0]}}),ct({propertiesVars:[r]})}))}))}))},Ut=t=>{Qe("contains",["object","boolean"],(()=>{Te("contains"),Ue().objectContains&&mt("array")&&mt("object")&&Je("possible type confusion in 'contains',","forbid 'object' or 'array'");const r=ge("passes");Ae.write("let %s = 0",r);const n=Ot();return t(((e,t)=>{const{sub:s}=jt(n,e,h.contains,Fe("contains"));Ae.if(s,(()=>{Ae.write("%s++",r),Ue().containsEvaluates&&(ze(!k,'Can\'t use removeAdditional with draft2020+ "contains"'),t())}))})),Qe("minContains",["natural"],(t=>e("%s < %d",r,t)),{suberr:n})||Oe(e("%s < 1",r),{path:["contains"],suberr:n}),Qe("maxContains",["natural"],(t=>e("%s > %d",r,t))),Le("minContains","maxContains"),null}))},Ct=()=>{Qe("not",["object","boolean"],(e=>jt(null,f,e,Fe("not")).sub)),h.not&&Te("not");(h.then||!1===h.then||h.else||!1===h.else||ee)&&Qe("if",["object","boolean"],(e=>{Te("if/then/else");const{sub:t,delta:r}=jt(null,f,e,Fe("if"),it);let n,s,o,i;var a;return Qe("else",["object","boolean"],(e=>(n=()=>{o=vt(f,e,Fe("else"),it),ct(o)},null))),Qe("then",["object","boolean"],(e=>(s=()=>{i=vt(f,e,Fe("then"),it),ct(P(r,i))},null))),s||(a=r,d.deepEqual(a,{type:[]}))||(s=()=>ct(r)),Ae.if(t,s,n),Be(I(o||{},P(r,i||{}))),null}));const t=(e,t="allOf")=>{ze(e.length>0,`${t} cannot be empty`);for(const[r,n]of Object.entries(e))Be(vt(f,n,Fe(t,r),it));return null};Qe("allOf",["array"],(e=>t(e)));let r=null;Qe("discriminator",["object"],(e=>{const t=new Set,n=(e,t,r)=>ze(e,`[discriminator]: ${t}`,r),{propertyName:s,mapping:o,...a}=e,c=be(s);n(s&&!h.oneOf!=!h.anyOf,"need propertyName, oneOf OR anyOf"),n(0===Object.keys(a).length,'only "propertyName" and "mapping" are supported');return r=(e,r)=>{const a=()=>{let a;Ae.write("switch (%s) {",m(c));for(const[c,l]of Object.entries(e)){const{const:e,enum:u,...p}=(l.properties||{})[s]||{};let m=void 0!==e?[e]:u;if(!m&&l.$ref){const[e]=i(w,me,l.$ref,et())[0]||[];ze(J(e),"failed to resolve $ref:",l.$ref);const t=(e.properties||{})[s]||{};m=void 0!==t.const?[t.const]:t.enum}const y=Array.isArray(m)&&m.length>0;n(y,"branches should have unique string const or enum values for [propertyName]");const h=!(0!==Object.keys(p).length||e&&u);n(h,"only const OR enum rules are allowed on [propertyName] in branches");for(const e of m){const r=!o||d.hasOwn(o,e)&&o[e]===l.$ref;n(r,"mismatching mapping for",e);const s="string"==typeof e&&!t.has(e);n(s,"const/enum values for [propertyName] should be unique strings"),t.add(e),Ae.write("case %j:",e)}const g=vt(f,l,Fe(r,c),it,{constProp:s});ct(g),a=a?I(a,g):g,Ae.write("break")}var l;n(void 0===o||(J(l=o)?Object.keys(l).length:null)===t.size,"mismatching mapping size"),Be(a),Ae.write("default:"),je({path:[r]}),Ae.write("}")},l=()=>{if(It(s))a();else{const e=["discriminator","propertyName"];Ae.if(Me(c),a,(()=>je({path:e,prop:c})))}};return S||!d.deepEqual(Ke.type,["object"])?Ae.if(y.get("object")(ye),l,(()=>je({path:["discriminator"]}))):l(),n(d.deepEqual(Ke.type,["object"]),"has to be checked for type:","object"),n(Ke.required.includes(s),"propertyName should be placed in required:",s),null},null}));const o=(e,t)=>{const r=t.map((e=>e.type||(Array.isArray(e.const)?"array":typeof e.const))),n=r.filter((e=>!_.includes(e)&&"array"!==e)).length,s=r.filter((e=>!_.includes(e)&&"object"!==e)).length;(n>1||s>1)&&Te(`${e}, use discriminator to make it certain`)};Qe("anyOf",["array"],(e=>{if(ze(e.length>0,"anyOf cannot be empty"),1===e.length)return t(e);if(r)return r(e,"anyOf");const i=Ot();if(!at()){o("anyOf",e);const t=Object.entries(e).map((([e,t])=>jt(i,f,t,Fe("anyOf",e),it)));Be(t.map((e=>e.delta)).reduce(((e,t)=>I(e,t)))),Oe(s(...t.map((({sub:e})=>e))),{path:["anyOf"],suberr:i});for(const{delta:e,sub:r}of t)Ae.if(r,(()=>ct(e)));return null}const a=e.filter((e=>d.hasOwn(e,"const"))),c=e.filter((e=>!d.hasOwn(e,"const")));o("anyOf",c);const l=[...a,...c];let u;if(Ue().exclusiveRefs){let e=()=>je({path:["anyOf"],suberr:i});for(const[t,r]of Object.entries(l).reverse()){const s=e;e=()=>{const{sub:e,delta:o}=jt(i,f,r,Fe("anyOf",t));Ae.if(n(e),s),u=u?I(u,o):o}}e()}else{const t=Object.entries(e).map((([e,t])=>jt(i,f,t,Fe("anyOf",e),it)));u=t.map((e=>e.delta)).reduce(((e,t)=>I(e,t))),Oe(s(...t.map((({sub:e})=>e))),{path:["anyOf"],suberr:i})}return Be(u),null})),Qe("oneOf",["array"],(n=>{if(ze(n.length>0,"oneOf cannot be empty"),1===n.length)return t(n);if(r)return r(n,"oneOf");o("oneOf",n);const s=ge("passes");Ae.write("let %s = 0",s);const i=Ot();let a,c=0;const l=Object.entries(n).map((([t,r])=>{!A&&c++>1&&Oe(e("%s > 1",s),{path:["oneOf"]});const n=jt(i,f,r,Fe("oneOf",t),it);return Ae.if(n.sub,(()=>Ae.write("%s++",s))),a=a?I(a,n.delta):n.delta,n}));Be(a),Oe(e("%s !== 1",s),{path:["oneOf"]}),Ae.if(e("%s === 0",s),(()=>xt(i)));for(const e of l)Ae.if(e.sub,(()=>ct(e.delta)));return null}))},Dt=(e,t,r)=>{const[n,s]=[Ae.size(),He.size];Ae.if(!!((...e)=>pt(Ke.type,e)||ft(...e))(...t)||r,e),n===Ae.size()&&s===He.size||ze(mt(...t),"Unexpected rules in type",h.type)},_t=()=>{if(Ke.items===1/0)!1===h.unevaluatedItems&&Ye("unevaluatedItems","boolean");else if(h.unevaluatedItems||!1===h.unevaluatedItems)if(U(Ke).items){if(!b[B])throw new Error("[opt] Dynamic unevaluated tracing not enabled");const t=e("Math.max(%d, ...%s)",Ke.items,it.items),r=t=>e("%s.includes(%s)",it.item,t);kt("unevaluatedItems",t,Ue().containsEvaluates?r:null)}else kt("unevaluatedItems",e("%d",Ke.items))},Lt=()=>{bt(Ke.patterns.length>0||Ke.dyn.patterns.length>0||Ke.unknown,(()=>{if(Ke.properties.includes(!0))!1===h.unevaluatedProperties&&Ye("unevaluatedProperties","boolean");else if(h.unevaluatedProperties||!1===h.unevaluatedProperties){const t=e=>St(e,Ke.properties,Ke.patterns);if(U(Ke).properties){if(!b[B])throw new Error("[opt] Dynamic unevaluated tracing not enabled");$.propertyIn=d.propertyIn;const n=t=>e("!propertyIn(%s, %s)",t,it.props);At("unevaluatedProperties",(e=>r(t(e),n(e))))}else!1===h.unevaluatedProperties&&zt(Ke.properties,Ke.patterns),At("unevaluatedProperties",t)}}))},Jt=()=>{if(null!==wt&&Ae.write("const %s = errorCount",wt),(()=>{const e=Qe("const",["jsonval"],(e=>n(Ie(ye,e))));if(e&&!ee)return!0;const t=Qe("enum",["array"],(e=>{const t=e.filter((e=>e&&"object"==typeof e)),r=e.filter((e=>!(e&&"object"==typeof e)));return s(...[...r,...t].map((e=>Ie(ye,e))))}));return e||t})()){const e=[...y.keys()];if(Be({properties:[!0],items:1/0,type:e,fullstring:!0}),!ee)return void ze(0===He.size,"Unexpected keywords mixed with const or enum:",[...He])}Dt(qt,["number","integer"],y.get("number")(ye)),Dt(Nt,["string"],y.get("string")(ye)),Dt(Pt,["array"],y.get("array")(ye)),Dt(Rt,["object"],y.get("object")(ye)),Ct(),Dt(_t,["array"],y.get("array")(ye)),Dt(Lt,["object"],y.get("object")(ye));for(const e of Mt)e();lt(V,ot.item,ot.items,ot.props)},Ft=()=>{if(ot.item&&Ae.write("const %s = []",ot.item),ot.items&&Ae.write("const %s = [0]",ot.items),ot.props&&Ae.write("const %s = [[], []]",ot.props),Qe("$ref",["string"],(e=>{const t=i(w,me,e,et()),[r,n,s]=t[0]||[];if(!r&&!1!==r&&(xe("failed to resolve $ref:",e),X))return null;const o=Xe(r,n,s),a=r===g?ve:o;if(!$[a])throw new Error("Unexpected: coherence check failed");if(!$[a][K]&&r.type){const e=Array.isArray(r.type)?r.type:[r.type];Be({type:e}),ne&&(Y.add(a),e.includes("array")&&Be({items:1/0}),e.includes("object")&&Be({properties:[!0]})),se&&e.includes("string")&&(Y.add(a),Be({fullstring:!0}))}return ut(o,{path:["$ref"]})})),Ue().exclusiveRefs&&(ze(!b[B],"unevaluated* is supported only on draft2019-09 and above"),h.$ref))return;Qe("$recursiveRef",["string"],(t=>{if(!b[Z])throw new Error("[opt] Recursive anchors are not enabled");ze("#"===t,'Behavior of $recursiveRef is defined only for "#"');const r=i(w,me,"#",et()),[n,s,o]=r[0];_e(n.$recursiveAnchor,"$recursiveRef without $recursiveAnchor");const a=Xe(n,s,o),c=n.$recursiveAnchor?e("(recursive || %s)",a):a;return ut(c,{path:["$recursiveRef"]})})),Qe("$dynamicRef",["string"],(t=>{if(!b[H])throw new Error("[opt] Dynamic anchors are not enabled");_e(/^[^#]*#[a-zA-Z0-9_-]+$/.test(t),"Unsupported $dynamicRef format");const r=t.replace(/^[^#]+/,""),n=i(w,me,t,et());if(!n[0]&&!Ue().bookending){_e(!1,"$dynamicRef bookending resolution failed (even though not required)"),$.dynamicResolve=d.dynamicResolve;const t=e("dynamicResolve(dynAnchors || [], %j)",r);return ut(t,{path:["$dynamicRef"]})}ze(n[0],"$dynamicRef bookending resolution failed",t);const[s,o,a]=n[0],c=s.$dynamicAnchor&&`#${s.$dynamicAnchor}`===r;_e(c,"$dynamicRef without $dynamicAnchor in the same scope");const l=Xe(s,o,a);$.dynamicResolve=d.dynamicResolve;const u=c?e("(dynamicResolve(dynAnchors || [], %j) || %s)",r,l):l;return ut(u,{path:["$dynamicRef"]})}));let t=null;Qe("type",["string","array"],(e=>{const r=Array.isArray(e)?e:[e];for(const e of r)ze("string"==typeof e&&y.has(e),"Unknown type:",e);if(f.type)return ze(d.deepEqual(r,[f.type]),"One type allowed:",f.type),Be({type:[f.type]}),null;if(ft(...r))return null;const n=r.filter((e=>mt(e)));return 0===n.length&&xe("No valid types possible"),Be({type:r}),t=s(...n.map((e=>y.get(e)(ye)))),null})),t&&S?Ae.if(t,(()=>je({path:["type"]})),Jt):(t&&Oe(t,{path:["type"]}),Jt()),Ke.items<1/0&&h.maxItems<=Ke.items&&Be({items:1/0})};if(void 0!==h.default&&E){fe&&xe("Can not apply default value here (e.g. at root)");const e=Ge("default","jsonval");Ae.if(Me(f),Ft,(()=>Ae.write("%s = %j",ye,e)))}else Qe("default",["jsonval"],null),Ae.if(!!fe||Me(f),Ft);if(Ce.length=tt,Re[0]&&Re[Re.length-1][0]===h&&Re.pop(),nt&&h!==g&&Ae.write("dynLocal.shift()"),te||ze(!Ae.optimizedOut,"some checks are never reachable"),ae){const e=["not","if","then","else"].includes(M[M.length-1]),t=["oneOf","anyOf","allOf"].includes(M[M.length-2]),r=["dependencies","dependentSchemas"].includes(M[M.length-2]),n=["propertyDependencies"].includes(M[M.length-3]);ze(e||t||r||n,"Unexpected logical path")}else if(!M.includes("not")){if((!(g!==w&&h===g)||Y.has(ve))&&(Y.delete(ve),Ke.type||Je("type"),mt("array")&&Ke.items!==1/0&&Je(h.items?"additionalItems or unevaluatedItems":"items rule"),mt("object")&&!Ke.properties.includes(!0)&&Je("additionalProperties or unevaluatedProperties"),!Ke.fullstring&&se)){xe(`[requireStringValidation] ${"pattern, format or contentSchema should be specified for strings"}, use pattern: ^[\\s\\S]*$ to opt-out`)}if("object"!=typeof h.propertyNames)for(const e of["additionalProperties","unevaluatedProperties"])h[e]&&Je(`wild-card ${e}`,"requires propertyNames")}return h.properties&&!h.required&&Je("if properties is used, required"),ze(0===He.size||ee,"Unprocessed keywords:",[...He]),{stat:Ke,local:ot}},{stat:_e,local:Le}=De(e("validate.errors"),[],{name:t("data")},g,[]);if(Y.has(ve))throw new Error("Unexpected: unvalidated cyclic ref");if(b[B]&&(U(_e).items||U(_e).properties)){if(!Le)throw new Error("Failed to trace dynamic properties");Ae.write("validate.evaluatedDynamic = [%s, %s, %s]",Le.item,Le.items,Le.props)}return S?Ae.write("return errorCount === 0"):Ae.write("return true"),Ae.write("}"),X||(je=Ae.makeFunction($),delete $[ve],$[ve]=je),$[ve][K]=_e,ve},X=(e,t)=>{if(!Array.isArray(e))throw new Error("Expected an array of schemas");try{const r=Object.create(null),{getref:n}=f(r);Y.clear(),G.clear();const s=e.map((e=>n(e)||Q(e,e,t,r)));if(0!==Y.size)throw new Error("Unexpected: not all refs are validated");return{scope:r,refs:s}}catch(r){if(!t[B]&&"[opt] Dynamic unevaluated tracing not enabled"===r.message)return X(e,{...t,[B]:!0});if(!t[H]&&"[opt] Dynamic anchors are not enabled"===r.message)return X(e,{...t,[H]:!0});if(!t[Z]&&"[opt] Recursive anchors are not enabled"===r.message)return X(e,{...t,[Z]:!0});throw r}finally{Y.clear(),G.clear()}};return b={compile:X}}function N(){if(j)return v;j=1;const e=A(),{buildSchemas:t}=z(),{compile:r}=q(),{deepEqual:n}=E(),s=e=>function t(r){if(!n(r,JSON.parse(JSON.stringify(r))))return t.errors=[{instanceLocation:"#",error:"not JSON compatible"}],!1;const s=e(r);return t.errors=e.errors,s},o=e=>t=>n(t,JSON.parse(JSON.stringify(t)))&&e(t),i=(i,{parse:l=!1,multi:u=!1,jsonCheck:p=!1,isJSON:d=!1,schemas:f=[],...m}={})=>{if(p&&d)throw new Error("Can not specify both isJSON and jsonCheck options");if(l&&(p||d))throw new Error("jsonCheck and isJSON options are not applicable in parser mode");const y=d||p||l,h=u?i:[i],g={mode:l?"strong":"default",...m,schemas:t(f,h),isJSON:y},{scope:w,refs:b}=r(h,g);if(m.dryRun)return;if(m.lint)return w.lintErrors;const $=e();if(l?w.parseWrap=m.includeErrors?a:c:p&&(w.deepEqual=n,w.jsonCheckWrap=m.includeErrors?s:o),u){$.write("[");for(const e of b.slice(0,-1))$.write("%s,",e);b.length>0&&$.write("%s",b[b.length-1]),$.write("]"),l?$.write(".map(parseWrap)"):p&&$.write(".map(jsonCheckWrap)")}else l?$.write("parseWrap(%s)",b[0]):p?$.write("jsonCheckWrap(%s)",b[0]):$.write("%s",b[0]);const v=$.makeFunction(w);return v.toModule=({semi:e=!0}={})=>$.makeModule(w)+(e?";":""),v.toJSON=()=>i,v},a=e=>t=>{if("string"!=typeof t)return{valid:!1,error:"Input is not a string"};try{const r=JSON.parse(t);if(!e(r)){const{keywordLocation:t,instanceLocation:r}=e.errors[0],n=t.slice(t.lastIndexOf("/")+1);return{valid:!1,error:`JSON validation failed for ${n} at ${r}`,errors:e.errors}}return{valid:!0,value:r}}catch({message:e}){return{valid:!1,error:e}}},c=e=>t=>{if("string"!=typeof t)return{valid:!1};try{const r=JSON.parse(t);return e(r)?{valid:!0,value:r}:{valid:!1}}catch(e){return{valid:!1}}};return v={validator:i,parser:function(e,{parse:t=!0,...r}={}){if(!t)throw new Error("can not disable parse in parser");return i(e,{parse:t,...r})},lint:function(e,{lint:t=!0,...r}={}){if(!t)throw new Error("can not disable lint option in lint()");return i(e,{lint:t,...r})}}}export{N as r};
