import{r as t,j as e}from"./jsonld-signatures-BbILf-Q7-DTp6__ud.js";import{e as r,d as o}from"./index-DZLKRa_V-D_IQzjvG.js";import{d as i}from"./base64url-Cy03LJLt-vkTPfQOh.js";var n=t();
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */const a=new RegExp("-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](.[0-9]+)?|(24:00:00(.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"),s=t=>a.test(t),c=self&&(self.crypto||self.msCrypto);async function u({string:t}){const e=(new TextEncoder).encode(t);return new Uint8Array(await c.subtle.digest("SHA-256",e))}
/*!
 * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.
 */const{suites:{LinkedDataProof:d}}=e;class f extends d{constructor({signer:t,date:e,cryptosuite:r,legacyContext:o=!1}={}){super({type:"DataIntegrityProof"});const{canonize:i,createVerifier:n,name:a,requiredAlgorithm:s,derive:c,createProofValue:u,createVerifyData:d}=r;if(!n||"function"!=typeof n)throw new TypeError('"cryptosuite.createVerifier" must be a function.');if(c&&"function"!=typeof c)throw new TypeError('"cryptosuite.derive" must be a function.');if(u&&"function"!=typeof u)throw new TypeError('"cryptosuite.createProofValue" must be a function.');if(d&&"function"!=typeof d)throw new TypeError('"cryptosuite.createVerifyData" must be a function.');if(this.contextUrl="https://w3id.org/security/data-integrity/v2",o&&(this.contextUrl="https://w3id.org/security/data-integrity/v1"),this.canonize=i,this.createVerifier=n,this.cryptosuite=a,this._cryptosuite=r,this.requiredAlgorithm=s,e){if(this.date=new Date(e),isNaN(this.date))throw TypeError(`"date" "${e}" is not a valid date.`)}else null===e&&(this.date=null);const f=function({signer:t,requiredAlgorithm:e}){const r={verificationMethod:void 0,signer:void 0};if(!t)return r;if("function"!=typeof t.sign)throw new TypeError("A signer API has not been specified.");const o=Array.isArray(e)?e.includes(t.algorithm):e===t.algorithm;if(!o){const r=Array.isArray(e)?e.join(", "):e,o=Array.isArray(e)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${r}".`:`does not match the required algorithm for the cryptosuite "${r}".`,i=`The signer's algorithm "${t.algorithm}" ${o}`;throw new Error(i)}return r.signer=t,r.verificationMethod=t.id,r}({signer:t,requiredAlgorithm:s});this.verificationMethod=f.verificationMethod,this.signer=f.signer}async sign({verifyData:t,proof:e}){if(!this.signer||"function"!=typeof this.signer.sign)throw new Error("A signer API has not been specified.");const o=await this.signer.sign({data:t});return e.proofValue="z"+r(o),e}async verifySignature({verifyData:t,verificationMethod:e,proof:r}){const n=await this.createVerifier({verificationMethod:e});if(!(Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.includes(n.algorithm):this.requiredAlgorithm===n.algorithm)){const t=Array.isArray(this.requiredAlgorithm)?this.requiredAlgorithm.join(", "):this.requiredAlgorithm,e=Array.isArray(this.requiredAlgorithm)?`is not a supported algorithm for the cryptosuite. The supported algorithms are: "${t}".`:`does not match the required algorithm for the cryptosuite "${t}".`,r=`The verifier's algorithm "${n.algorithm}" ${e}`;throw new Error(r)}const{proofValue:a}=r;if(!a||"string"!=typeof a)throw new TypeError('The proof does not include a valid "proofValue" property.');const s=a[0];let c;if("z"===s)c=o(a.slice(1));else{if("u"!==s)throw new Error("Only base58btc or base64url multibase encoding is supported.");c=i(a.slice(1))}return n.verify({data:t,signature:c})}async createProof({document:t,purpose:e,proofSet:r,documentLoader:o}){let i;i=this.proof?{...this.proof}:{},i.type=this.type;let n,a=this.date;return void 0===i.created&&void 0===a&&(a=new Date),a&&"string"!=typeof a&&(a=(t=>(null==t?t=new Date:"number"!=typeof t&&"string"!=typeof t||(t=new Date(t)),t.toISOString().slice(0,-5)+"Z"))(a)),a&&(i.created=a),i.verificationMethod=this.verificationMethod,i.cryptosuite=this.cryptosuite,i=await this.updateProof({document:t,proof:i,purpose:e,proofSet:r,documentLoader:o}),i=await e.update(i,{document:t,suite:this,documentLoader:o}),n=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:t,proof:i,proofSet:r,documentLoader:o,dataIntegrityProof:this}):await this.createVerifyData({document:t,proof:i,proofSet:r,documentLoader:o}),this._cryptosuite.createProofValue?i.proofValue=await this._cryptosuite.createProofValue({cryptosuite:this._cryptosuite,verifyData:n,document:t,proof:i,proofSet:r,documentLoader:o,dataIntegrityProof:this}):i=await this.sign({verifyData:n,document:t,proof:i,proofSet:r,documentLoader:o}),i}async derive({document:t,purpose:e,proofSet:r,documentLoader:o}){if(!this._cryptosuite.derive)throw new Error('"cryptosuite.derive" not provided.');return this._cryptosuite.derive({cryptosuite:this._cryptosuite,document:t,purpose:e,proofSet:r,documentLoader:o,dataIntegrityProof:this})}async updateProof({proof:t}){return t}async verifyProof({proof:t,proofSet:e,document:r,documentLoader:o}){try{const i=await this.getVerificationMethod({proof:t,documentLoader:o});let n;n=this._cryptosuite.createVerifyData?await this._cryptosuite.createVerifyData({cryptosuite:this._cryptosuite,document:r,proof:t,proofSet:e,documentLoader:o,dataIntegrityProof:this,verificationMethod:i}):await this.createVerifyData({document:r,proof:t,proofSet:e,documentLoader:o,verificationMethod:i});if(!await this.verifySignature({verifyData:n,verificationMethod:i,proof:t}))throw new Error("Invalid signature.");if(void 0!==t.created&&!s(t.created))throw new Error(`"proof.created" ("${t.created}") must be an XSD dateTimeStamp.`);if(void 0!==t.expires&&!s(t.expires))throw new Error(`"proof.expires" ("${t.expires}") must be an XSD dateTimeStamp.`);return{verified:!0,verificationMethod:i}}catch(t){return{verified:!1,error:t}}}async createVerifyData({document:t,proof:e,documentLoader:r}){let o;const{_hashCache:i}=this;i&&i.document===t?o=i.hash:this._hashCache={document:t,hash:o=this.canonize(t,{documentLoader:r,base:null,safe:!0}).then((t=>u({string:t})))};const[n,a]=await Promise.all([this.canonizeProof(e,{document:t,documentLoader:r}).then((t=>u({string:t}))),o]);return((t,e)=>{const r=new Uint8Array(t.length+e.length);return r.set(t,0),r.set(e,t.length),r})(n,a)}async getVerificationMethod({proof:t,documentLoader:e}){let{verificationMethod:r}=t;if("object"==typeof r&&(r=r.id),!r)throw new Error('No "verificationMethod" found in proof.');const o=await e(r);if(!o)throw new Error(`Unable to load verification method "${r}".`);const{document:i}=o;return r="string"==typeof i?JSON.parse(i):i,r}async canonizeProof(t,{documentLoader:e,document:r}){return t={"@context":r["@context"],...t},this.ensureSuiteContext({document:t,addSuiteContext:!0}),delete t.proofValue,this.canonize(t,{documentLoader:e,safe:!0,base:null,skipExpansion:!1})}async matchProof({proof:t}){const{type:e,cryptosuite:r}=t;return e===this.type&&r===this.cryptosuite}ensureSuiteContext({document:t,addSuiteContext:e}){const{contextUrl:r}=this;if(h({document:t,contextUrl:r})||h({document:t,contextUrl:"https://www.w3.org/ns/credentials/v2"}))return;if(!e)throw new TypeError(`The document to be signed must contain this suite's @context, "${r}".`);const o=t["@context"]||[];t["@context"]=Array.isArray(o)?[...o,r]:[o,r]}}function h({document:t,contextUrl:e}){const r=t["@context"];return r===e||Array.isArray(r)&&r.includes(e)}export{f as D,n as r};
