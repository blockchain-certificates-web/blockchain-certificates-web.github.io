import{B as e,c as t,J as r}from"./main.js";import{_ as n}from"./tslib.es6--gQC4x5c-CmLYFWVC.js";var s,i={};var o=function(){if(s)return i;s=1;class t{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,r){const n=t.toUint8Array(e),s=t.toUint8Array(r);if(n.length!==s.byteLength)return!1;for(let e=0;e<n.length;e++)if(n[e]!==s[e])return!1;return!0}static concat(...e){let t;t=!Array.isArray(e[0])||e[1]instanceof Function?Array.isArray(e[0])&&e[1]instanceof Function?e[0]:e[e.length-1]instanceof Function?e.slice(0,e.length-1):e:e[0];let r=0;for(const e of t)r+=e.byteLength;const n=new Uint8Array(r);let s=0;for(const e of t){const t=this.toUint8Array(e);n.set(t,s),s+=t.length}return e[e.length-1]instanceof Function?this.toView(n,e[e.length-1]):n.buffer}}const r="string",n=/^[0-9a-f]+$/i,o=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,a=/^[a-zA-Z0-9-_]+$/;class c{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static toString(e){const r=t.toUint8Array(e);let n="";for(let e=0;e<r.length;e++)n+=String.fromCharCode(r[e]);return decodeURIComponent(escape(n))}}class u{static toString(e,r=!1){const n=t.toArrayBuffer(e),s=new DataView(n);let i="";for(let e=0;e<n.byteLength;e+=2){const t=s.getUint16(e,r);i+=String.fromCharCode(t)}return i}static fromString(e,t=!1){const r=new ArrayBuffer(2*e.length),n=new DataView(r);for(let r=0;r<e.length;r++)n.setUint16(2*r,e.charCodeAt(r),t);return r}}class l{static isHex(e){return typeof e===r&&n.test(e)}static isBase64(e){return typeof e===r&&o.test(e)}static isBase64Url(e){return typeof e===r&&a.test(e)}static ToString(e,r="utf8"){const n=t.toUint8Array(e);switch(r.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return u.toString(n,!0);case"utf16":case"utf16be":return u.toString(n);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return u.fromString(e,!0);case"utf16":case"utf16be":return u.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(r){const n=t.toUint8Array(r);if("undefined"!=typeof btoa){const e=this.ToString(n,"binary");return btoa(e)}return e.from(n).toString("base64")}static FromBase64(t){const r=this.formatString(t);if(!r)return new ArrayBuffer(0);if(!l.isBase64(r))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(r)):new Uint8Array(e.from(r,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!l.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=l.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return c.fromString(e);case"utf16":case"utf16be":return u.fromString(e);case"utf16le":case"usc2":return u.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=l.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return c.toString(e);case"utf16":case"utf16be":return u.toString(e);case"utf16le":case"usc2":return u.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToBinary(e){const r=t.toUint8Array(e);let n="";for(let e=0;e<r.length;e++)n+=String.fromCharCode(r[e]);return n}static ToHex(e){const r=t.toUint8Array(e);let n="";const s=r.length;for(let e=0;e<s;e++){const t=r[e];t<16&&(n+="0"),n+=t.toString(16)}return n}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!l.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const n=t.slice(e,e+2);r[e/2]=parseInt(n,16)}return r.buffer}static ToUtf16String(e,t=!1){return u.toString(e,t)}static FromUtf16String(e,t=!1){return u.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}return l.DEFAULT_UTF8_ENCODING="utf8",i.BufferSourceConverter=t,i.Convert=l,i.assign=function(e,...t){const r=arguments[0];for(let e=1;e<arguments.length;e++){const t=arguments[e];for(const e in t)r[e]=t[e]}return r},i.combine=function(...e){const t=e.map((e=>e.byteLength)).reduce(((e,t)=>e+t)),r=new Uint8Array(t);let n=0;return e.map((e=>new Uint8Array(e))).forEach((e=>{for(const t of e)r[n++]=t})),r.buffer},i.isEqual=function(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let t=0;t<e.byteLength;t++)if(r[t]!==n[t])return!1;return!0},i}();
/*!
 Copyright (c) Peculiar Ventures, LLC
*/function a(e,t){let r=0;if(1===e.length)return e[0];for(let n=e.length-1;n>=0;n--)r+=e[e.length-1-n]*Math.pow(2,t*n);return r}function c(e,t,r=-1){const n=r;let s=e,i=0,o=Math.pow(2,t);for(let r=1;r<8;r++){if(e<o){let e;if(n<0)e=new ArrayBuffer(r),i=r;else{if(n<r)return new ArrayBuffer(0);e=new ArrayBuffer(n),i=n}const o=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);o[i-e-1]=Math.floor(s/r),s-=o[i-e-1]*r}return e}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function u(...e){let t=0,r=0;for(const r of e)t+=r.length;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const t of e)s.set(t,r),r+=t.length;return s}function l(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&!(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const n=a(r,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];i[0]&=127;return a(i,8)-n}function h(e,t){const r=e.toString(10);if(t<r.length)return"";const n=t-r.length,s=new Array(n);for(let e=0;e<n;e++)s[e]="0";return s.join("").concat(r)}
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function y(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function f(e){let t=0,r=0;for(let r=0;r<e.length;r++){t+=e[r].byteLength}const n=new Uint8Array(t);for(let t=0;t<e.length;t++){const s=e[t];n.set(new Uint8Array(s),r),r+=s.byteLength}return n.buffer}function p(e,t,r,n){return t instanceof Uint8Array?t.byteLength?r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):n<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-n<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class g{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return f(this.items)}}const m=[new Uint8Array([1])],d="0123456789",w="name",v="valueHexView",A="",b=new ArrayBuffer(0),k=new Uint8Array(0),S="EndOfContent",B="OCTET STRING",E="BIT STRING";function K(e){var t;return(t=class extends e{constructor(...e){var t;super(...e);const r=e[0]||{};this.isHexOnly=null!==(t=r.isHexOnly)&&void 0!==t&&t,this.valueHexView=r.valueHex?o.BufferSourceConverter.toUint8Array(r.valueHex):k}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}fromBER(e,t,r){const n=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!p(this,n,t,r))return-1;const s=t+r;return this.valueHexView=n.subarray(t,s),this.valueHexView.length?(this.blockLength=r,s):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",b)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:o.Convert.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class C{constructor({blockLength:e=0,error:t="",warnings:r=[],valueBeforeDecode:n=k}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=o.BufferSourceConverter.toUint8Array(n)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:o.Convert.ToHex(this.valueBeforeDecodeView)}}}C.NAME="baseBlock";class x extends C{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}x.NAME="valueBlock";class N extends(K(C)){constructor({idBlock:e={}}={}){var t,r,n,s;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?o.BufferSourceConverter.toUint8Array(e.valueHex):k,this.tagClass=null!==(r=e.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(n=e.tagNumber)&&void 0!==n?n:-1,this.isConstructed=null!==(s=e.isConstructed)&&void 0!==s&&s):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",b}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,r[0]=t}return r.buffer}if(!this.isHexOnly){const r=c(this.tagNumber,7),n=new Uint8Array(r),s=r.byteLength,i=new Uint8Array(s+1);if(i[0]=31|t,!e){for(let e=0;e<s-1;e++)i[e+1]=128|n[e];i[s]=n[s-1]}return i.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHexView.byteLength]=e[e.length-1]}return r.buffer}fromBER(e,t,r){const n=o.BufferSourceConverter.toUint8Array(e);if(!p(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;switch(192&s[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=!(32&~s[0]),this.isHexOnly=!1;const i=31&s[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),r=255;for(;128&s[e];){if(t[e-1]=127&s[e],e++,e>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(e===r){r+=255;const e=new Uint8Array(r);for(let r=0;r<t.length;r++)e[r]=t[r];t=this.valueHexView=new Uint8Array(r)}}this.blockLength=e+1,t[e-1]=127&s[e];const n=new Uint8Array(e);for(let r=0;r<e;r++)n[r]=t[r];t=this.valueHexView=new Uint8Array(e),t.set(n),this.blockLength<=9?this.tagNumber=a(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}N.NAME="identificationBlock";class U extends C{constructor({lenBlock:e={}}={}){var t,r,n;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(r=e.longFormUsed)&&void 0!==r&&r,this.length=null!==(n=e.length)&&void 0!==n?n:0}fromBER(e,t,r){const n=o.BufferSourceConverter.toUint8Array(e);if(!p(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,t+this.blockLength;const i=127&s[0];if(i>8)return this.error="Too big integer",-1;if(i+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const c=t+1,u=n.subarray(c,c+i);return 0===u[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=a(u,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const n=c(this.length,8);if(n.byteLength>127)return this.error="Too big length",b;if(t=new ArrayBuffer(n.byteLength+1),e)return t;const s=new Uint8Array(n);r=new Uint8Array(t),r[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}U.NAME="lengthBlock";const P={};class I extends C{constructor({name:e="",optional:t=!1,primitiveSchema:r,...n}={},s){super(n),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new N(n),this.lenBlock=new U(n),this.valueBlock=s?new s(n):new x(n)}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}toBER(e,t){const r=t||new g;t||O(this);const n=this.idBlock.toBER(e);if(r.write(n),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const n=this.lenBlock.toBER(e);r.write(n),r.write(t)}return t?b:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():o.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${o.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;return function(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0}(this.toBER(),e.toBER())}}function O(e){if(e instanceof P.Constructed)for(const t of e.valueBlock.value)O(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!e.lenBlock.isIndefiniteForm}I.NAME="BaseBlock";class H extends I{constructor({value:e="",...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}H.NAME="BaseStringBlock";class T extends(K(x)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var L,D,V,R,M,$;T.NAME="PrimitiveValueBlock";class J extends I{constructor(e={}){super(e,T),this.idBlock.isConstructed=!1}}function j(e,t=0,r=e.length){const n=t;let s=new I({},x);const i=new C;if(!p(i,e,t,r))return s.error=i.error,{offset:-1,result:s};if(!e.subarray(t,t+r).length)return s.error="Zero buffer length",{offset:-1,result:s};let o=s.idBlock.fromBER(e,t,r);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),-1===o)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=o,r-=s.idBlock.blockLength,o=s.lenBlock.fromBER(e,t,r),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),-1===o)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=o,r-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=I;if(1===s.idBlock.tagClass){if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=P.EndOfContent;break;case 1:a=P.Boolean;break;case 2:a=P.Integer;break;case 3:a=P.BitString;break;case 4:a=P.OctetString;break;case 5:a=P.Null;break;case 6:a=P.ObjectIdentifier;break;case 10:a=P.Enumerated;break;case 12:a=P.Utf8String;break;case 13:a=P.RelativeObjectIdentifier;break;case 14:a=P.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=P.Sequence;break;case 17:a=P.Set;break;case 18:a=P.NumericString;break;case 19:a=P.PrintableString;break;case 20:a=P.TeletexString;break;case 21:a=P.VideotexString;break;case 22:a=P.IA5String;break;case 23:a=P.UTCTime;break;case 24:a=P.GeneralizedTime;break;case 25:a=P.GraphicString;break;case 26:a=P.VisibleString;break;case 27:a=P.GeneralString;break;case 28:a=P.UniversalString;break;case 29:a=P.CharacterString;break;case 30:a=P.BmpString;break;case 31:a=P.DATE;break;case 32:a=P.TimeOfDay;break;case 33:a=P.DateTime;break;case 34:a=P.Duration;break;default:{const e=s.idBlock.isConstructed?new P.Constructed:new P.Primitive;e.idBlock=s.idBlock,e.lenBlock=s.lenBlock,e.warnings=s.warnings,s=e}}}else a=s.idBlock.isConstructed?P.Constructed:P.Primitive;return s=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecodeView=e.valueBeforeDecodeView,r}(s,a),o=s.fromBER(e,t,s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecodeView=e.subarray(n,n+s.blockLength),{offset:o,result:s}}function z(e){if(!e.byteLength){const e=new I({},x);return e.error="Input buffer has zero length",{offset:-1,result:e}}return j(o.BufferSourceConverter.toUint8Array(e).slice(),0,e.byteLength)}L=J,P.Primitive=L,J.NAME="PRIMITIVE";class F extends x{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const n=o.BufferSourceConverter.toUint8Array(e);if(!p(this,n,t,r))return-1;if(this.valueBeforeDecodeView=n.subarray(t,t+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let s=t;for(;i=this.isIndefiniteForm,a=r,(i?1:a)>0;){const e=j(n,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===S)break}var i,a;return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===S?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const r=t||new g;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,r);return t?b:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}F.NAME="ConstructedValueBlock";class G extends I{constructor(e={}){super(e,F),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map((e=>`  ${e}`)).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}D=G,P.Constructed=D,G.NAME="CONSTRUCTED";class _ extends x{fromBER(e,t,r){return t}toBER(e){return b}}_.override="EndOfContentValueBlock";class q extends I{constructor(e={}){super(e,_),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}V=q,P.EndOfContent=V,q.NAME=S;class W extends I{constructor(e={}){super(e,x),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const e=new Uint8Array(r);e[0]=5,e[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}R=W,P.Null=R,W.NAME="NULL";class Y extends(K(x)){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=o.BufferSourceConverter.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const n=o.BufferSourceConverter.toUint8Array(e);return p(this,n,t,r)?(this.valueHexView=n.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,l.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}Y.NAME="BooleanValueBlock";class X extends I{constructor(e={}){super(e,Y),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}M=X,P.Boolean=M,X.NAME="BOOLEAN";class Z extends(K(F)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let n=0;if(this.isConstructed){if(this.isHexOnly=!1,n=F.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===S){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==B)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(e,t,r),this.blockLength=r;return n}toBER(e,t){return this.isConstructed?F.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}Z.NAME="OctetStringValueBlock";let Q=class e extends I{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Z),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const n=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(n.byteLength){const e=j(n,0,n.byteLength);-1!==e.offset&&e.offset===r&&(this.valueBlock.value=[e.result])}}catch(e){}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?G.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${o.Convert.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const t=[];for(const r of this.valueBlock.value)r instanceof e&&t.push(r.valueBlock.valueHexView);return o.BufferSourceConverter.concat(t)}};$=Q,P.OctetString=$,Q.NAME=B;class ee extends(K(F)){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let n=-1;if(this.isConstructed){if(n=F.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(const e of this.value){const t=e.constructor.NAME;if(t===S){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==E)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=e.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return n}const s=o.BufferSourceConverter.toUint8Array(e);if(!p(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=j(e,0,e.byteLength);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}}catch(e){}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+r}toBER(e,t){if(this.isConstructed)return F.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return b;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}var te;ee.NAME="BitStringValueBlock";let re=class extends I{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},ee),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return G.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const r of t)e.push(r.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}};var ne,se,ie,oe;function ae(e,t){const r=new Uint8Array([0]),n=new Uint8Array(e),s=new Uint8Array(t);let i=n.slice(0);const o=i.length-1,a=s.slice(0),c=a.length-1;let l=0;let h=0;for(let e=c<o?o:c;e>=0;e--,h++){if(!0==h<a.length)l=i[o-h]+a[c-h]+r[0];else l=i[o-h]+r[0];if(r[0]=l/10,!0==h>=i.length)i=u(new Uint8Array([l%10]),i);else i[o-h]=l%10}return r[0]>0&&(i=u(r,i)),i}function ce(e){if(e>=m.length)for(let t=m.length;t<=e;t++){const e=new Uint8Array([0]);let r=m[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const n=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=n[0]/10,r[t]=n[0]%10}e[0]>0&&(r=u(e,r)),m.push(r)}return m[e]}function ue(e,t){let r=0;const n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1;let u,l=0;for(let e=c;e>=0;e--,l++)if(u=i[o-l]-a[c-l]-r,!0==u<0)r=1,i[o-l]=u+10;else r=0,i[o-l]=u;if(r>0)for(let e=o-c+1;e>=0;e--,l++){if(u=i[o-l]-r,!(u<0)){r=0,i[o-l]=u;break}r=1,i[o-l]=u+10}return i.slice()}te=re,P.BitString=te,re.NAME=E;class le extends(K(x)){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=l.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(e){const t=e<0?-1*e:e;let r=128;for(let n=1;n<8;n++){if(t<=r){if(e<0){const e=c(r-t,8,n);return new Uint8Array(e)[0]|=128,e}let s=c(t,8,n),i=new Uint8Array(s);if(128&i[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,n=0){const s=this.fromBER(e,t,r);if(-1===s)return s;const i=this.valueHexView;return 0===i[0]&&128&i[1]?this.valueHexView=i.subarray(1):0!==n&&i.length<n&&(n-i.length>1&&(n=i.length+1),this.valueHexView=i.subarray(n-i.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case!!(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&!(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,r){const n=super.fromBER(e,t,r);return-1===n||this.setValueHex(),n}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,r=new Uint8Array(8*this.valueHexView.length/3),n=0;const s=this.valueHexView;let i="",o=!1;for(let o=s.byteLength-1;o>=0;o--){t=s[o];for(let s=0;s<8;s++){if(!(1&~t))if(n===e)r=ue(ce(n),r),i="-";else r=ae(r,ce(n));n++,t>>=1}}for(let e=0;e<r.length;e++)r[e]&&(o=!0),o&&(i+=d.charAt(r[e]));return!1===o&&(i+=d.charAt(0)),i}}ne=le,le.NAME="IntegerValueBlock",Object.defineProperty(ne.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class he extends I{constructor(e={}){super(e,le),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return y(),BigInt(this.valueBlock.toString())}static fromBigInt(e){y();const t=BigInt(e),r=new g,n=t.toString(16).replace(/^-/,""),s=new Uint8Array(o.Convert.FromHex(n));if(t<0){const e=new Uint8Array(s.length+(128&s[0]?1:0));e[0]|=128;const n=BigInt(`0x${o.Convert.ToHex(e)}`)+t,i=o.BufferSourceConverter.toUint8Array(o.Convert.FromHex(n.toString(16)));i[0]|=128,r.write(i)}else 128&s[0]&&r.write(new Uint8Array([0])),r.write(s);return new he({valueHex:r.final()})}convertToDER(){const e=new he({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new he({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}se=he,P.Integer=se,he.NAME="INTEGER";class ye extends he{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}ie=ye,P.Enumerated=ie,ye.NAME="ENUMERATED";class fe extends(K(x)){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const n=o.BufferSourceConverter.toUint8Array(e);if(!p(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){y();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let e=0;e<r.length;e++)r[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=c(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",b;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r}toString(){let e="";if(this.isHexOnly)e=o.Convert.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}fe.NAME="sidBlock";class pe extends x{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new fe;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,b;t.push(n)}return f(t)}fromString(e){this.value=[];let t=0,r=0,n="",s=!1;do{if(r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const r=parseInt(n,10);if(isNaN(r))return;e.valueDec=r+t,s=!1}else{const e=new fe;if(n>Number.MAX_SAFE_INTEGER){y();const t=BigInt(n);e.valueBigInt=t}else if(e.valueDec=parseInt(n,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==r)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,this.value[r].isFirstSid?e=`2.{${n} - 80}`:e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}pe.NAME="ObjectIdentifierValueBlock";let ge=class extends I{constructor(e={}){super(e,pe),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};oe=ge,P.ObjectIdentifier=oe,ge.NAME="OBJECT IDENTIFIER";class me extends(K(C)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(0===r)return t;const n=o.BufferSourceConverter.toUint8Array(e);if(!p(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=c(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",b;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r.buffer}toString(){let e="";return e=this.isHexOnly?o.Convert.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}me.NAME="relativeSidBlock";class de extends x{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new me;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e,t){const r=[];for(let t=0;t<this.value.length;t++){const n=this.value[t].toBER(e);if(0===n.byteLength)return this.error=this.value[t].error,b;r.push(n)}return f(r)}fromString(e){this.value=[];let t=0,r=0,n="";do{r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1;const s=new me;if(s.valueDec=parseInt(n,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}var we,ve,Ae,be,ke,Se,Be,Ee,Ke,Ce,xe,Ne,Ue,Pe,Ie,Oe,He,Te,Le,De,Ve,Re;de.NAME="RelativeObjectIdentifierValueBlock";class Me extends I{constructor(e={}){super(e,de),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}we=Me,P.RelativeObjectIdentifier=we,Me.NAME="RelativeObjectIdentifier";class $e extends G{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}ve=$e,P.Sequence=ve,$e.NAME="SEQUENCE";class Je extends G{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}Ae=Je,P.Set=Ae,Je.NAME="SET";class je extends(K(x)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=A}toJSON(){return{...super.toJSON(),value:this.value}}}je.NAME="StringValueBlock";class ze extends je{}ze.NAME="SimpleStringValueBlock";class Fe extends H{constructor({...e}={}){super(e,ze)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,o.BufferSourceConverter.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);this.valueBlock.value=e}}Fe.NAME="SIMPLE STRING";class Ge extends Fe{fromBuffer(e){this.valueBlock.valueHexView=o.BufferSourceConverter.toUint8Array(e);try{this.valueBlock.value=o.Convert.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=o.Convert.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(o.Convert.FromUtf8String(e)),this.valueBlock.value=e}}Ge.NAME="Utf8StringValueBlock";class _e extends Ge{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}be=_e,P.Utf8String=be,_e.NAME="UTF8String";class qe extends Fe{fromBuffer(e){this.valueBlock.value=o.Convert.ToUtf16String(e),this.valueBlock.valueHexView=o.BufferSourceConverter.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(o.Convert.FromUtf16String(e))}}qe.NAME="BmpStringValueBlock";class We extends qe{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}ke=We,P.BmpString=ke,We.NAME="BMPString";class Ye extends Fe{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let n=0;n<t;n++){const t=c(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>4)continue;const i=4-s.length;for(let e=s.length-1;e>=0;e--)r[4*n+e+i]=s[e]}this.valueBlock.value=e}}Ye.NAME="UniversalStringValueBlock";class Xe extends Ye{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}Se=Xe,P.UniversalString=Se,Xe.NAME="UniversalString";class Ze extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}Be=Ze,P.NumericString=Be,Ze.NAME="NumericString";class Qe extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Ee=Qe,P.PrintableString=Ee,Qe.NAME="PrintableString";class et extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}Ke=et,P.TeletexString=Ke,et.NAME="TeletexString";class tt extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}Ce=tt,P.VideotexString=Ce,tt.NAME="VideotexString";class rt extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}xe=rt,P.IA5String=xe,rt.NAME="IA5String";class nt extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Ne=nt,P.GraphicString=Ne,nt.NAME="GraphicString";class st extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Ue=st,P.VisibleString=Ue,st.NAME="VisibleString";class it extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}Pe=it,P.GeneralString=Pe,it.NAME="GeneralString";class ot extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Ie=ot,P.CharacterString=Ie,ot.NAME="CharacterString";class at extends st{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,o.BufferSourceConverter.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=h(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=h(this.month,2),e[2]=h(this.day,2),e[3]=h(this.hour,2),e[4]=h(this.minute,2),e[5]=h(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}Oe=at,P.UTCTime=Oe,at.NAME="UTCTime";class ct extends at{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,n="",s="",i=0,o=0,a=0;if("Z"===e[e.length-1])n=e.substring(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=n.indexOf("+"),r="";if(-1===t&&(t=n.indexOf("-"),e=-1),-1!==t){if(r=n.substring(t+1),n=n.substring(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let s=parseInt(r.substring(0,2),10);if(isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");if(o=e*s,4===r.length){if(s=parseInt(r.substring(2,4),10),isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");a=e*s}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const e=new Number(`0${n.substring(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");i=e.valueOf(),s=n.substring(0,c)}else s=n;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for conversion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const u=t.exec(s);if(null===u)throw new Error("Wrong input string for conversion");for(let e=1;e<u.length;e++)switch(e){case 1:this.year=parseInt(u[e],10);break;case 2:this.month=parseInt(u[e],10);break;case 3:this.day=parseInt(u[e],10);break;case 4:this.hour=parseInt(u[e],10)+o;break;case 5:this.minute=parseInt(u[e],10)+a;break;case 6:this.second=parseInt(u[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(h(this.year,4)),e.push(h(this.month,2)),e.push(h(this.day,2)),e.push(h(this.hour,2)),e.push(h(this.minute,2)),e.push(h(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(h(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}He=ct,P.GeneralizedTime=He,ct.NAME="GeneralizedTime";class ut extends _e{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}Te=ut,P.DATE=Te,ut.NAME="DATE";class lt extends _e{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Le=lt,P.TimeOfDay=Le,lt.NAME="TimeOfDay";class ht extends _e{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}De=ht,P.DateTime=De,ht.NAME="DateTime";class yt extends _e{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Ve=yt,P.Duration=Ve,yt.NAME="Duration";class ft extends _e{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}Re=ft,P.TIME=Re,ft.NAME="TIME";class pt{constructor({name:e="",optional:t=!1}={}){this.name=e,this.optional=t}}class gt extends pt{constructor({value:e=[],...t}={}){super(t),this.value=e}}class mt extends pt{constructor({value:e=new pt,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}function dt(e,t,r){if(r instanceof gt){for(let n=0;n<r.value.length;n++){if(dt(e,t,r.value[n]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty(w)&&(e.name=r.name),e}}if(r instanceof pt)return r.hasOwnProperty(w)&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if(!("isHexOnly"in r.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(r.idBlock.isHexOnly){if(v in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.valueHexView,s=t.idBlock.valueHexView;if(n.length!==s.length)return{verified:!1,result:e};for(let t=0;t<n.length;t++)if(n[t]!==s[1])return{verified:!1,result:e}}if(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&(e[r.name]=t)),r instanceof P.Constructed){let n=0,s={verified:!1,result:{error:"Unknown error"}},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof mt&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return t?{verified:!0,result:e}:(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let o=0;o<i;o++)if(o-n>=t.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof mt){if(s=dt(e,t.valueBlock.value[o],r.valueBlock.value[0].value),!1===s.verified){if(!r.valueBlock.value[0].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&delete e[r.name]),s;n++}if(w in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};n="local"in r.valueBlock.value[0]&&r.valueBlock.value[0].local?t:e,void 0===n[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(t.valueBlock.value[o])}}else if(s=dt(e,t.valueBlock.value[o-n],r.valueBlock.value[o]),!1===s.verified){if(!r.valueBlock.value[o].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&delete e[r.name]),s;n++}if(!1===s.verified){const t={verified:!1,result:e};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if(r.primitiveSchema&&v in t.valueBlock){const n=j(t.valueBlock.valueHexView);if(-1===n.offset){const t={verified:!1,result:n.result};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,A),r.name&&(delete e[r.name],t.name=r.name)),t}return dt(e,n.result,r.primitiveSchema)}return{verified:!0,result:e}}var wt,vt,At=Object.freeze({__proto__:null,Any:pt,BaseBlock:I,BaseStringBlock:H,BitString:re,BmpString:We,Boolean:X,CharacterString:ot,Choice:gt,Constructed:G,DATE:ut,DateTime:ht,Duration:yt,EndOfContent:q,Enumerated:ye,GeneralString:it,GeneralizedTime:ct,GraphicString:nt,HexBlock:K,IA5String:rt,Integer:he,Null:W,NumericString:Ze,ObjectIdentifier:ge,OctetString:Q,Primitive:J,PrintableString:Qe,RawData:class{constructor({data:e=k}={}){this.dataView=o.BufferSourceConverter.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=o.BufferSourceConverter.toUint8Array(e)}fromBER(e,t,r){const n=t+r;return this.dataView=o.BufferSourceConverter.toUint8Array(e).subarray(t,n),n}toBER(e){return this.dataView.slice().buffer}},RelativeObjectIdentifier:Me,Repeated:mt,Sequence:$e,Set:Je,TIME:ft,TeletexString:et,TimeOfDay:lt,UTCTime:at,UniversalString:Xe,Utf8String:_e,ValueBlock:x,VideotexString:tt,ViewWriter:g,VisibleString:st,compareSchema:dt,fromBER:z,verifySchema:function(e,t){if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=j(o.BufferSourceConverter.toUint8Array(e));return-1===r.offset?{verified:!1,result:r.result}:dt(r.result,r.result,t)}});!function(e){e[e.Sequence=0]="Sequence",e[e.Set=1]="Set",e[e.Choice=2]="Choice"}(wt||(wt={})),function(e){e[e.Any=1]="Any",e[e.Boolean=2]="Boolean",e[e.OctetString=3]="OctetString",e[e.BitString=4]="BitString",e[e.Integer=5]="Integer",e[e.Enumerated=6]="Enumerated",e[e.ObjectIdentifier=7]="ObjectIdentifier",e[e.Utf8String=8]="Utf8String",e[e.BmpString=9]="BmpString",e[e.UniversalString=10]="UniversalString",e[e.NumericString=11]="NumericString",e[e.PrintableString=12]="PrintableString",e[e.TeletexString=13]="TeletexString",e[e.VideotexString=14]="VideotexString",e[e.IA5String=15]="IA5String",e[e.GraphicString=16]="GraphicString",e[e.VisibleString=17]="VisibleString",e[e.GeneralString=18]="GeneralString",e[e.CharacterString=19]="CharacterString",e[e.UTCTime=20]="UTCTime",e[e.GeneralizedTime=21]="GeneralizedTime",e[e.DATE=22]="DATE",e[e.TimeOfDay=23]="TimeOfDay",e[e.DateTime=24]="DateTime",e[e.Duration=25]="Duration",e[e.TIME=26]="TIME",e[e.Null=27]="Null"}(vt||(vt={}));const bt={fromASN:e=>e instanceof W?null:e.valueBeforeDecodeView,toASN:e=>{if(null===e)return new W;const t=z(e);if(t.result.error)throw new Error(t.result.error);return t.result}},kt={fromASN:e=>e.valueBlock.valueHexView.byteLength>=4?e.valueBlock.toString():e.valueBlock.valueDec,toASN:e=>new he({value:+e})},St={fromASN:e=>e.valueBlock.valueDec,toASN:e=>new ye({value:e})},Bt={fromASN:e=>e.valueBlock.valueHexView,toASN:e=>new re({valueHex:e})},Et={fromASN:e=>e.valueBlock.toString(),toASN:e=>new ge({value:e})},Kt={fromASN:e=>e.valueBlock.value,toASN:e=>new X({value:e})},Ct={fromASN:e=>e.valueBlock.valueHexView,toASN:e=>new Q({valueHex:e})};function xt(e){return{fromASN:e=>e.valueBlock.value,toASN:t=>new e({value:t})}}const Nt=xt(_e),Ut=xt(We),Pt=xt(Xe),It=xt(Ze),Ot=xt(Qe),Ht=xt(et),Tt=xt(tt),Lt=xt(rt),Dt=xt(nt),Vt=xt(st),Rt=xt(it),Mt=xt(ot),$t={fromASN:e=>e.toDate(),toASN:e=>new at({valueDate:e})},Jt={fromASN:e=>e.toDate(),toASN:e=>new ct({valueDate:e})},jt={fromASN:()=>null,toASN:()=>new W};function zt(e){switch(e){case vt.Any:return bt;case vt.BitString:return Bt;case vt.BmpString:return Ut;case vt.Boolean:return Kt;case vt.CharacterString:return Mt;case vt.Enumerated:return St;case vt.GeneralString:return Rt;case vt.GeneralizedTime:return Jt;case vt.GraphicString:return Dt;case vt.IA5String:return Lt;case vt.Integer:return kt;case vt.Null:return jt;case vt.NumericString:return It;case vt.ObjectIdentifier:return Et;case vt.OctetString:return Ct;case vt.PrintableString:return Ot;case vt.TeletexString:return Ht;case vt.UTCTime:return $t;case vt.UniversalString:return Pt;case vt.Utf8String:return Nt;case vt.VideotexString:return Tt;case vt.VisibleString:return Vt;default:return null}}function Ft(e){return"function"==typeof e&&e.prototype?!(!e.prototype.toASN||!e.prototype.fromASN)||Ft(e.prototype):!!(e&&"object"==typeof e&&"toASN"in e&&"fromASN"in e)}function Gt(e){var t;if(e){const r=Object.getPrototypeOf(e);return(null===(t=null==r?void 0:r.prototype)||void 0===t?void 0:t.constructor)===Array||Gt(r)}return!1}function _t(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let t=0;t<e.byteLength;t++)if(r[t]!==n[t])return!1;return!0}const qt=new class{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const r=this.items.get(e);if(!r)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!r.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return r}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:wt.Sequence,items:{}},r=this.findParentSchema(e);return r&&(Object.assign(t,r),t.items=Object.assign({},t.items,r.items)),t}create(e,t){const r=this.items.get(e)||this.createDefault(e),n=[];for(const e in r.items){const s=r.items[e],i=t?e:"";let o;if("number"==typeof s.type){const e=vt[s.type],t=At[e];if(!t)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new t({name:i})}else if(Ft(s.type)){o=(new s.type).toSchema(i)}else if(s.optional){this.get(s.type).type===wt.Choice?o=new pt({name:i}):(o=this.create(s.type,!1),o.name=i)}else o=new pt({name:i});const a=!!s.optional||void 0!==s.defaultValue;if(s.repeated){o.name="";o=new("set"===s.repeated?Je:$e)({name:"",value:[new mt({name:i,value:o})]})}if(null!==s.context&&void 0!==s.context)if(s.implicit)if("number"==typeof s.type||Ft(s.type)){const e=s.repeated?G:J;n.push(new e({name:i,optional:a,idBlock:{tagClass:3,tagNumber:s.context}}))}else{this.cache(s.type);const e=!!s.repeated;let t=e?o:this.get(s.type,!0).schema;t="valueBlock"in t?t.valueBlock.value:t.value,n.push(new G({name:e?"":i,optional:a,idBlock:{tagClass:3,tagNumber:s.context},value:t}))}else n.push(new G({optional:a,idBlock:{tagClass:3,tagNumber:s.context},value:[o]}));else o.optional=a,n.push(o)}switch(r.type){case wt.Sequence:return new $e({value:n,name:""});case wt.Set:return new Je({value:n,name:""});case wt.Choice:return new gt({value:n,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);if(t){return this.items.get(t)||this.findParentSchema(t)}return null}},Wt=e=>t=>{let r;qt.has(t)?r=qt.get(t):(r=qt.createDefault(t),qt.set(t,r)),Object.assign(r,e)},Yt=e=>(t,r)=>{let n;qt.has(t.constructor)?n=qt.get(t.constructor):(n=qt.createDefault(t.constructor),qt.set(t.constructor,n));const s=Object.assign({},e);if("number"==typeof s.type&&!s.converter){const n=zt(e.type);if(!n)throw new Error(`Cannot get default converter for property '${r}' of ${t.constructor.name}`);s.converter=n}n.items[r]=s};class Xt extends Error{constructor(){super(...arguments),this.schemas=[]}}class Zt{static parse(e,t){const r=z(e);if(r.result.error)throw new Error(r.result.error);return this.fromASN(r.result,t)}static fromASN(e,t){var r;try{if(Ft(t)){return(new t).fromASN(e)}const n=qt.get(t);qt.cache(t);let s=n.schema;if(e.constructor===G&&n.type!==wt.Choice){s=new G({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:n.schema.valueBlock.value});for(const t in n.items)delete e[t]}const i=dt({},e,s);if(!i.verified)throw new Xt(`Data does not match to ${t.name} ASN1 schema. ${i.result.error}`);const o=new t;if(Gt(t)){if(!("value"in e.valueBlock)||!Array.isArray(e.valueBlock.value))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const r=n.itemType;if("number"==typeof r){const n=zt(r);if(!n)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,(e=>n.fromASN(e)))}return t.from(e.valueBlock.value,(e=>this.fromASN(e,r)))}for(const e in n.items){const t=i.result[e];if(!t)continue;const s=n.items[e],a=s.type;if("number"==typeof a||Ft(a)){const n=null!==(r=s.converter)&&void 0!==r?r:Ft(a)?new a:null;if(!n)throw new Error("Converter is empty");if(s.repeated)if(s.implicit){const r=new("sequence"===s.repeated?$e:Je);r.valueBlock=t.valueBlock;const i=z(r.toBER(!1));if(-1===i.offset)throw new Error(`Cannot parse the child item. ${i.result.error}`);if(!("value"in i.result.valueBlock)||!Array.isArray(i.result.valueBlock.value))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const a=i.result.valueBlock.value;o[e]=Array.from(a,(e=>n.fromASN(e)))}else o[e]=Array.from(t,(e=>n.fromASN(e)));else{let r=t;if(s.implicit){let e;if(Ft(a))e=(new a).toSchema("");else{const t=vt[a],r=At[t];if(!r)throw new Error(`Cannot get '${t}' class from asn1js module`);e=new r}e.valueBlock=r.valueBlock,r=z(e.toBER(!1)).result}o[e]=n.fromASN(r)}}else if(s.repeated){if(!Array.isArray(t))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");o[e]=Array.from(t,(e=>this.fromASN(e,a)))}else o[e]=this.fromASN(t,a)}return o}catch(e){throw e instanceof Xt&&e.schemas.push(t.name),e}}}class Qt{static serialize(e){return e instanceof I?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&"object"==typeof e&&Ft(e))return e.toASN();if(!e||"object"!=typeof e)throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,r=qt.get(t);qt.cache(t);let n,s=[];if(r.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if("number"==typeof r.itemType){const n=zt(r.itemType);if(!n)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);s=e.map((e=>n.toASN(e)))}else s=e.map((e=>this.toAsnItem({type:r.itemType},"[]",t,e)))}else for(const n in r.items){const i=r.items[n],o=e[n];if(void 0===o||i.defaultValue===o||"object"==typeof i.defaultValue&&"object"==typeof o&&_t(this.serialize(i.defaultValue),this.serialize(o)))continue;const a=Qt.toAsnItem(i,n,t,o);if("number"==typeof i.context)if(i.implicit)if(i.repeated||"number"!=typeof i.type&&!Ft(i.type))s.push(new G({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:a.valueBlock.value}));else{const e={};e.valueHex=a instanceof W?a.valueBeforeDecodeView:a.valueBlock.toBER(),s.push(new J({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},...e}))}else s.push(new G({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[a]}));else i.repeated?s=s.concat(a):s.push(a)}switch(r.type){case wt.Sequence:n=new $e({value:s});break;case wt.Set:n=new Je({value:s});break;case wt.Choice:if(!s[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);n=s[0]}return n}static toAsnItem(e,t,r,n){let s;if("number"==typeof e.type){const i=e.converter;if(!i)throw new Error(`Property '${t}' doesn't have converter for type ${vt[e.type]} in schema '${r.name}'`);if(e.repeated){if(!Array.isArray(n))throw new TypeError("Parameter 'objProp' should be type of Array.");const t=Array.from(n,(e=>i.toASN(e)));s=new("sequence"===e.repeated?$e:Je)({value:t})}else s=i.toASN(n)}else if(e.repeated){if(!Array.isArray(n))throw new TypeError("Parameter 'objProp' should be type of Array.");const t=Array.from(n,(e=>this.toASN(e)));s=new("sequence"===e.repeated?$e:Je)({value:t})}else s=this.toASN(n);return s}}class er{static serialize(e){return Qt.serialize(e)}static parse(e,t){return Zt.parse(e,t)}static toString(e){const t=z(o.BufferSourceConverter.isBufferSource(e)?o.BufferSourceConverter.toArrayBuffer(e):er.serialize(e));if(-1===t.offset)throw new Error(`Cannot decode ASN.1 data. ${t.result.error}`);return t.result.toString()}}class tr extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class rr extends tr{constructor(e,t,r){super(t,r),this.schema=e}}class nr extends rr{constructor(e,t,r){super(e,`JSON doesn't match to '${e.target.name}' schema. ${t}`,r)}}class sr extends tr{}class ir extends tr{constructor(e,t,r){super(`Cannot serialize by '${e}' schema. ${t}`,r),this.schemaName=e}}class or extends nr{constructor(e,t,r={}){super(e,"Some keys doesn't match to schema"),this.keys=t,this.errors=r}}var ar;function cr(e,t){if(!function(e,t){switch(t){case ar.Boolean:return"boolean"==typeof e;case ar.Number:return"number"==typeof e;case ar.String:return"string"==typeof e}return!0}(e,t))throw new TypeError(`Value must be ${ar[t]}`)}function ur(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||ur(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}!function(e){e[e.Any=0]="Any",e[e.Boolean=1]="Boolean",e[e.Number=2]="Number",e[e.String=3]="String"}(ar||(ar={}));const lr="default",hr=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const e in r.names)t.names[e]=Object.assign({},r.names[e])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;if(t){return this.items.get(t)||this.findParentSchema(t)}return null}};class yr{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof e)throw new sr("Incoming value must be string");if(!t.exec(e))throw new sr(`Value doesn't match to pattern '${t.toString()}'`)}}class fr{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(cr(e,ar.Number),!(this.min<=e&&e<=this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new sr(`Value doesn't match to diapason [${e},${t}]`)}}}class pr{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(cr(e,ar.Number),!(this.min<e&&e<this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new sr(`Value doesn't match to diapason (${e},${t})`)}}}class gr{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(void 0===this.length){if(void 0!==this.minLength&&e.length<this.minLength)throw new sr(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&e.length>this.maxLength)throw new sr(`Value length must be less than ${this.maxLength}.`)}else if(e.length!==this.length)throw new sr(`Value length must be exactly ${this.length}.`)}}class mr{constructor(e){this.enumeration=e}validate(e){if(cr(e,ar.String),!this.enumeration.includes(e))throw new sr(`Value must be one of ${this.enumeration.map((e=>`'${e}'`)).join(", ")}`)}}class dr{static checkValues(e,t){const r=Array.isArray(e)?e:[e];for(const n of r)for(const r of t.validations)r instanceof gr&&t.repeated?r.validate(e):r.validate(n)}static checkTypes(e,t){if(t.repeated&&!Array.isArray(e))throw new TypeError("Value must be Array");if("number"==typeof t.type){const r=Array.isArray(e)?e:[e];for(const e of r)cr(e,t.type)}}static getSchemaByName(e,t=lr){return{...e.names[lr],...e.names[t]}}}class wr extends dr{static serialize(e,t,r,n){const s=this.toJSON(e,t);return JSON.stringify(s,r,n)}static toJSON(e,t={}){let r,n=t.targetSchema;const s=t.schemaName||lr;if(ur(e))return e.toJSON();if(Array.isArray(e)){r=[];for(const n of e)r.push(this.toJSON(n,t))}else if("object"==typeof e){if(n&&!hr.has(n))throw new tr("Cannot get schema for `targetSchema` param");if(n=n||e.constructor,hr.has(n)){const t=hr.get(n);r={};const i=this.getSchemaByName(t,s);for(const o in i)try{const t=i[o],a=e[o];let c;if(t.optional&&void 0===a||void 0!==t.defaultValue&&a===t.defaultValue)continue;if(!t.optional&&void 0===a)throw new ir(n.name,`Property '${o}' is required.`);c="number"==typeof t.type?t.converter?t.repeated?a.map((r=>t.converter.toJSON(r,e))):t.converter.toJSON(a,e):a:t.repeated?a.map((e=>this.toJSON(e,{schemaName:s}))):this.toJSON(a,{schemaName:s}),this.checkTypes(c,t),this.checkValues(c,t),r[t.name||o]=c}catch(e){throw e instanceof ir?e:new ir(t.target.name,`Property '${o}' is wrong. ${e.message}`,e)}}else{r={};for(const t in e)r[t]=this.toJSON(e[t],{schemaName:s})}}else r=e;return r}}class vr extends dr{static parse(e,t){const r=JSON.parse(e);return this.fromJSON(r,t)}static fromJSON(e,t){const r=t.targetSchema,n=t.schemaName||lr,s=new r;if(ur(s))return s.fromJSON(e);const i=hr.get(r),o=this.getSchemaByName(i,n),a={};t.strictProperty&&!Array.isArray(e)&&vr.checkStrictProperty(e,o,i);for(const r in o)try{const a=o[r],c=a.name||r,u=e[c];if(void 0===u&&(a.optional||void 0!==a.defaultValue))continue;if(!a.optional&&void 0===u)throw new nr(i,`Property '${c}' is required.`);if(this.checkTypes(u,a),this.checkValues(u,a),"number"==typeof a.type)a.converter?a.repeated?s[r]=u.map((e=>a.converter.fromJSON(e,s))):s[r]=a.converter.fromJSON(u,s):s[r]=u;else{const e={...t,targetSchema:a.type,schemaName:n};a.repeated?s[r]=u.map((t=>this.fromJSON(t,e))):s[r]=this.fromJSON(u,e)}}catch(e){if(e instanceof nr||(e=new nr(i,`Property '${r}' is wrong. ${e.message}`,e)),!t.strictAllKeys)throw e;a[r]=e}const c=Object.keys(a);if(c.length)throw new or(i,c,a);return s}static checkStrictProperty(e,t,r){const n=Object.keys(e),s=Object.keys(t),i=[];for(const e of n)-1===s.indexOf(e)&&i.push(e);if(i.length)throw new or(r,i)}}const Ar=(e={})=>(t,r)=>{const n=`Cannot set type for ${r} property of ${t.constructor.name} schema`;let s;hr.has(t.constructor)?(s=hr.get(t.constructor),s.target!==t.constructor&&(s=hr.create(t.constructor),hr.set(t.constructor,s))):(s=hr.create(t.constructor),hr.set(t.constructor,s));const i={type:ar.Any,validations:[]},o=Object.assign(i,e);if(o.validations=function(e){const t=[];return e.pattern&&t.push(new yr(e.pattern)),e.type!==ar.Number&&e.type!==ar.Any||(void 0===e.minInclusive&&void 0===e.maxInclusive||t.push(new fr(e.minInclusive,e.maxInclusive)),void 0===e.minExclusive&&void 0===e.maxExclusive||t.push(new pr(e.minExclusive,e.maxExclusive)),void 0!==e.enumeration&&t.push(new mr(e.enumeration))),(e.type===ar.String||e.repeated||e.type===ar.Any)&&(void 0===e.length&&void 0===e.minLength&&void 0===e.maxLength||t.push(new gr(e.length,e.minLength,e.maxLength))),t}(o),"number"!=typeof o.type&&!hr.has(o.type)&&!ur(o.type))throw new Error(`${n}. Assigning type doesn't have schema.`);let a;a=Array.isArray(e.schema)?e.schema:[e.schema||lr];for(const e of a){s.names[e]||(s.names[e]={});s.names[e][r]=o}}
/*!
 Copyright (c) Peculiar Ventures, LLC
*/;class br extends Error{}class kr extends br{}class Sr extends br{constructor(e){super("Unsupported operation: "+(e?`${e}`:""))}}class Br extends br{}class Er extends br{constructor(e){super(`${e}: Missing required property`)}}class Kr{static toArrayBuffer(e){const t=e.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return o.Convert.FromBase64(t)}static toUint8Array(e){const t=this.toArrayBuffer(e);return new Uint8Array(t)}static fromBufferSource(e,t){const r=o.Convert.ToBase64(e);let n,s=0;const i=[];for(;s<r.length&&(n=r.slice(s,s+64),n.length);)i.push(n),s+=64;const a=t.toUpperCase();return`-----BEGIN ${a}-----\n${i.join("\n")}\n-----END ${a}-----`}static isPEM(e){return/-----BEGIN .+-----[A-Za-z0-9+/+=\s\n]+-----END .+-----/i.test(e)}static getTagName(e){if(!this.isPEM(e))throw new Error("Bad parameter. Incoming data is not right PEM");const t=/-----BEGIN (.+)-----/.exec(e);if(!t)throw new Error("Cannot get tag from PEM");return t[1]}static hasTagName(e,t){const r=this.getTagName(e);return t.toLowerCase()===r.toLowerCase()}static isCertificate(e){return this.hasTagName(e,"certificate")}static isCertificateRequest(e){return this.hasTagName(e,"certificate request")}static isCRL(e){return this.hasTagName(e,"x509 crl")}static isPublicKey(e){return this.hasTagName(e,"public key")}}class Cr{async digest(...e){return this.checkDigest.apply(this,e),this.onDigest.apply(this,e)}checkDigest(e,t){this.checkAlgorithmName(e)}async onDigest(e,t){throw new Sr("digest")}async generateKey(...e){return this.checkGenerateKey.apply(this,e),this.onGenerateKey.apply(this,e)}checkGenerateKey(e,t,r,...n){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let s;s=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,s)}checkGenerateKeyParams(e){}async onGenerateKey(e,t,r,...n){throw new Sr("generateKey")}async sign(...e){return this.checkSign.apply(this,e),this.onSign.apply(this,e)}checkSign(e,t,r,...n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}async onSign(e,t,r,...n){throw new Sr("sign")}async verify(...e){return this.checkVerify.apply(this,e),this.onVerify.apply(this,e)}checkVerify(e,t,r,n,...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}async onVerify(e,t,r,n,...s){throw new Sr("verify")}async encrypt(...e){return this.checkEncrypt.apply(this,e),this.onEncrypt.apply(this,e)}checkEncrypt(e,t,r,n={},...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"encrypt":void 0)}async onEncrypt(e,t,r,...n){throw new Sr("encrypt")}async decrypt(...e){return this.checkDecrypt.apply(this,e),this.onDecrypt.apply(this,e)}checkDecrypt(e,t,r,n={},...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"decrypt":void 0)}async onDecrypt(e,t,r,...n){throw new Sr("decrypt")}async deriveBits(...e){return this.checkDeriveBits.apply(this,e),this.onDeriveBits.apply(this,e)}checkDeriveBits(e,t,r,n={},...s){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"deriveBits":void 0),r%8!=0)throw new Br("length: Is not multiple of 8")}async onDeriveBits(e,t,r,...n){throw new Sr("deriveBits")}async exportKey(...e){return this.checkExportKey.apply(this,e),this.onExportKey.apply(this,e)}checkExportKey(e,t,...r){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new br("key: Is not extractable")}async onExportKey(e,t,...r){throw new Sr("exportKey")}async importKey(...e){return this.checkImportKey.apply(this,e),this.onImportKey.apply(this,e)}checkImportKey(e,t,r,n,s,...i){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(s,this.usages)}async onImportKey(e,t,r,n,s,...i){throw new Sr("importKey")}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new kr("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(-1===t.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&-1===e.usages.indexOf(t))throw new br("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new Er(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new Br(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===e){if("object"!=typeof(r=t)||!("kty"in r))throw new TypeError("keyData: Is not JsonWebToken")}else if(!o.BufferSourceConverter.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");var r}prepareData(e){return o.BufferSourceConverter.toArrayBuffer(e)}}class xr extends Cr{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}let Nr=class extends xr{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}},Ur=class extends xr{constructor(){super(...arguments),this.name="AES-CMAC",this.usages=["sign","verify"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new Br("length: Must be more than 0")}},Pr=class extends xr{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new Br("length: Must be more than 0")}},Ir=class extends xr{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}},Or=class extends xr{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){var t;if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new Br("iv: Must have length more than 0 and less than 2^64 - 1");switch(null!==(t=e.tagLength)&&void 0!==t||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new Br("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}},Hr=class extends xr{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}};class Tr extends Cr{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new Br(`algorithm.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class Lr extends Cr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=o.Convert.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");if(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength%8||e.modulusLength<256||e.modulusLength>16384)throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384")}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}let Dr=class extends Lr{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}},Vr=class extends Lr{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),"number"!=typeof e.saltLength)throw new TypeError("saltLength: Is not a Number");if(e.saltLength<0)throw new RangeError("saltLength: Must be positive number")}},Rr=class extends Lr{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}};class Mr extends Cr{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new Br(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}let $r=class extends Mr{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}};const Jr=["secret","private","public"];let jr=class{static create(e,t,r,n){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=n,s}static isKeyType(e){return-1!==Jr.indexOf(e)}get[Symbol.toStringTag](){return"CryptoKey"}},zr=class extends Mr{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof jr))throw new TypeError("public: Is not a CryptoKey");if("public"!==e.public.type)throw new Br("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new Br(`public: Is not ${this.name} key`)}},Fr=class extends zr{constructor(){super(...arguments),this.name="ECDH-ES",this.namedCurves=["X25519","X448"]}},Gr=class extends Mr{constructor(){super(...arguments),this.name="EdDSA",this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["Ed25519","Ed448"]}},_r=class{constructor(e){e&&(this.value=e)}};n([Yt({type:vt.ObjectIdentifier})],_r.prototype,"value",void 0),_r=n([Wt({type:wt.Choice})],_r);class qr{constructor(e){Object.assign(this,e)}}n([Yt({type:vt.ObjectIdentifier})],qr.prototype,"algorithm",void 0),n([Yt({type:vt.Any,optional:!0})],qr.prototype,"parameters",void 0);class Wr{constructor(){this.version=0,this.privateKeyAlgorithm=new qr,this.privateKey=new ArrayBuffer(0)}}n([Yt({type:vt.Integer})],Wr.prototype,"version",void 0),n([Yt({type:qr})],Wr.prototype,"privateKeyAlgorithm",void 0),n([Yt({type:vt.OctetString})],Wr.prototype,"privateKey",void 0),n([Yt({type:vt.Any,optional:!0})],Wr.prototype,"attributes",void 0);class Yr{constructor(){this.publicKeyAlgorithm=new qr,this.publicKey=new ArrayBuffer(0)}}n([Yt({type:qr})],Yr.prototype,"publicKeyAlgorithm",void 0),n([Yt({type:vt.BitString})],Yr.prototype,"publicKey",void 0);const Xr={fromJSON:e=>o.Convert.FromBase64Url(e),toJSON:e=>o.Convert.ToBase64Url(new Uint8Array(e))},Zr={fromASN:e=>{const t=e.valueBlock.valueHex;return new Uint8Array(t)[0]?e.valueBlock.valueHex:e.valueBlock.valueHex.slice(1)},toASN:e=>{const t=new Uint8Array(e)[0]>127?o.combine(new Uint8Array([0]).buffer,e):e;return new he({valueHex:t})}};let Qr=class{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}};n([Yt({type:vt.Integer,converter:kt})],Qr.prototype,"version",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"n",converter:Xr})],Qr.prototype,"modulus",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"e",converter:Xr})],Qr.prototype,"publicExponent",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"d",converter:Xr})],Qr.prototype,"privateExponent",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"p",converter:Xr})],Qr.prototype,"prime1",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"q",converter:Xr})],Qr.prototype,"prime2",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"dp",converter:Xr})],Qr.prototype,"exponent1",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"dq",converter:Xr})],Qr.prototype,"exponent2",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"qi",converter:Xr})],Qr.prototype,"coefficient",void 0),n([Yt({type:vt.Any,optional:!0})],Qr.prototype,"otherPrimeInfos",void 0);let en=class{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}};n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"n",converter:Xr})],en.prototype,"modulus",void 0),n([Yt({type:vt.Integer,converter:Zr}),Ar({name:"e",converter:Xr})],en.prototype,"publicExponent",void 0);let tn=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(4!==e[0])throw new br("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");e=new Uint8Array(this.value.slice(1));const t=e.length/2;return{x:o.Convert.ToBase64Url(e.buffer.slice(0,0+t)),y:o.Convert.ToBase64Url(e.buffer.slice(0+t,0+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=o.Convert.FromBase64Url(e.x),r=o.Convert.FromBase64Url(e.y),n=o.combine(new Uint8Array([4]).buffer,t,r);return this.value=new Uint8Array(n).buffer,this}};n([Yt({type:vt.OctetString})],tn.prototype,"value",void 0),tn=n([Wt({type:wt.Choice})],tn);let rn=class{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=o.Convert.FromBase64Url(e.d),"x"in e){const t=new tn;t.fromJSON(e);const r=Qt.toASN(t);"valueHex"in r.valueBlock&&(this.publicKey=r.valueBlock.valueHex)}return this}toJSON(){const e={};return e.d=o.Convert.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new tn(this.publicKey).toJSON()),e}};n([Yt({type:vt.Integer,converter:kt})],rn.prototype,"version",void 0),n([Yt({type:vt.OctetString})],rn.prototype,"privateKey",void 0),n([Yt({context:0,type:vt.Any,optional:!0})],rn.prototype,"parameters",void 0),n([Yt({context:1,type:vt.BitString,optional:!0})],rn.prototype,"publicKey",void 0);const nn={fromASN:e=>{const t=new Uint8Array(e.valueBlock.valueHex);return 0===t[0]?t.buffer.slice(1):t.buffer},toASN:e=>{const t=new Uint8Array(e);if(t[0]>127){const e=new Uint8Array(t.length+1);return e.set(t,1),new he({valueHex:e.buffer})}return new he({valueHex:e})}};var sn=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:nn});class on{static decodePoint(e,t){const r=o.BufferSourceConverter.toUint8Array(e);if(0===r.length||4!==r[0])throw new Error("Only uncompressed point format supported");const n=(r.length-1)/2;if(n!==Math.ceil(t/8))throw new Error("Point does not match field size");return{x:r.slice(1,n+1),y:r.slice(n+1,n+1+n)}}static encodePoint(e,t){const r=Math.ceil(t/8);if(e.x.byteLength!==r||e.y.byteLength!==r)throw new Error("X,Y coordinates don't match point size criteria");const n=o.BufferSourceConverter.toUint8Array(e.x),s=o.BufferSourceConverter.toUint8Array(e.y),i=new Uint8Array(2*r+1);return i[0]=4,i.set(n,1),i.set(s,r+1),i}static getSize(e){return Math.ceil(e/8)}static encodeSignature(e,t){const r=this.getSize(t),n=o.BufferSourceConverter.toUint8Array(e.r),s=o.BufferSourceConverter.toUint8Array(e.s),i=new Uint8Array(2*r);return i.set(this.padStart(n,r)),i.set(this.padStart(s,r),r),i}static decodeSignature(e,t){const r=this.getSize(t),n=o.BufferSourceConverter.toUint8Array(e);if(n.length!==2*r)throw new Error("Incorrect size of the signature");const s=n.slice(0,r),i=n.slice(r);return{r:this.trimStart(s),s:this.trimStart(i)}}static trimStart(e){let t=0;for(;t<e.length-1&&0===e[t];)t++;return 0===t?e:e.slice(t,e.length)}static padStart(e,t){if(t===e.length)return e;const r=new Uint8Array(t);return r.set(e,t-e.length),r}}class an{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(e){const t=e.byteLength/2,r=on.decodeSignature(e,8*t),n=new an;return n.r=o.BufferSourceConverter.toArrayBuffer(r.r),n.s=o.BufferSourceConverter.toArrayBuffer(r.s),n}toWebCryptoSignature(e){null!=e||(e=8*Math.max(this.r.byteLength,this.s.byteLength));return on.encodeSignature(this,e).buffer}}n([Yt({type:vt.Integer,converter:nn})],an.prototype,"r",void 0),n([Yt({type:vt.Integer,converter:nn})],an.prototype,"s",void 0);class cn extends Wr{}n([Yt({context:1,implicit:!0,type:vt.BitString,optional:!0})],cn.prototype,"publicKey",void 0);let un=class{constructor(){this.value=new ArrayBuffer(0)}fromJSON(e){if(!e.d)throw new Error("d: Missing required property");return this.value=o.Convert.FromBase64Url(e.d),this}toJSON(){return{d:o.Convert.ToBase64Url(this.value)}}};n([Yt({type:vt.OctetString})],un.prototype,"value",void 0),un=n([Wt({type:wt.Choice})],un);let ln=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){return{x:o.Convert.ToBase64Url(this.value)}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");return this.value=o.Convert.FromBase64Url(e.x),this}};n([Yt({type:vt.BitString})],ln.prototype,"value",void 0),ln=n([Wt({type:wt.Choice})],ln);let hn=class{};n([Yt({type:vt.OctetString}),Ar({type:ar.String,converter:Xr})],hn.prototype,"d",void 0),hn=n([Wt({type:wt.Choice})],hn);const yn="1.2.840.10045.3.1.7",fn="1.3.132.0",pn=`${fn}.34`,gn=`${fn}.35`,mn=`${fn}.10`,dn="1.3.36.3.3.2.8.1.1",wn=`${dn}.1`,vn=`${dn}.2`,An=`${dn}.3`,bn=`${dn}.4`,kn=`${dn}.5`,Sn=`${dn}.6`,Bn=`${dn}.7`,En=`${dn}.8`,Kn=`${dn}.9`,Cn=`${dn}.10`,xn=`${dn}.11`,Nn=`${dn}.12`,Un=`${dn}.13`,Pn=`${dn}.14`;var In=Object.freeze({__proto__:null,AlgorithmIdentifier:qr,get CurvePrivateKey(){return hn},EcDsaSignature:an,EcPrivateKey:rn,get EcPublicKey(){return tn},get EdPrivateKey(){return un},get EdPublicKey(){return ln},get ObjectIdentifier(){return _r},OneAsymmetricKey:cn,PrivateKeyInfo:Wr,PublicKeyInfo:Yr,RsaPrivateKey:Qr,RsaPublicKey:en,converters:sn,idBrainpoolP160r1:wn,idBrainpoolP160t1:vn,idBrainpoolP192r1:An,idBrainpoolP192t1:bn,idBrainpoolP224r1:kn,idBrainpoolP224t1:Sn,idBrainpoolP256r1:Bn,idBrainpoolP256t1:En,idBrainpoolP320r1:Kn,idBrainpoolP320t1:Cn,idBrainpoolP384r1:xn,idBrainpoolP384t1:Nn,idBrainpoolP512r1:Un,idBrainpoolP512t1:Pn,idEd25519:"1.3.101.112",idEd448:"1.3.101.113",idEllipticCurve:fn,idSecp256k1:mn,idSecp256r1:yn,idSecp384r1:pn,idSecp521r1:gn,idVersionOne:dn,idX25519:"1.3.101.110",idX448:"1.3.101.111"});class On{constructor(){}static register(e){const t=new _r;t.value=e.id;const r=er.serialize(t);this.items.push({...e,raw:r}),this.names.push(e.name)}static find(e){e=e.toUpperCase();for(const t of this.items)if(t.name.toUpperCase()===e||t.id.toUpperCase()===e)return t;return null}static get(e){const t=this.find(e);if(!t)throw new Error(`Unsupported EC named curve '${e}'`);return t}}On.items=[],On.names=[],On.register({name:"P-256",id:yn,size:256}),On.register({name:"P-384",id:pn,size:384}),On.register({name:"P-521",id:gn,size:521}),On.register({name:"K-256",id:mn,size:256}),On.register({name:"brainpoolP160r1",id:wn,size:160}),On.register({name:"brainpoolP160t1",id:vn,size:160}),On.register({name:"brainpoolP192r1",id:An,size:192}),On.register({name:"brainpoolP192t1",id:bn,size:192}),On.register({name:"brainpoolP224r1",id:kn,size:224}),On.register({name:"brainpoolP224t1",id:Sn,size:224}),On.register({name:"brainpoolP256r1",id:Bn,size:256}),On.register({name:"brainpoolP256t1",id:En,size:256}),On.register({name:"brainpoolP320r1",id:Kn,size:320}),On.register({name:"brainpoolP320t1",id:Cn,size:320}),On.register({name:"brainpoolP384r1",id:xn,size:384}),On.register({name:"brainpoolP384t1",id:Nn,size:384}),On.register({name:"brainpoolP512r1",id:Un,size:512}),On.register({name:"brainpoolP512t1",id:Pn,size:512});let Hn=class extends Cr{constructor(){super(...arguments),this.name="X25519",this.usages={privateKey:["deriveKey","deriveBits"],publicKey:[]}}checkAlgorithmParams(e){this.checkRequiredProperty(e,"public")}},Tn=class extends Cr{constructor(){super(...arguments),this.name="Ed25519",this.usages={privateKey:["sign"],publicKey:["verify"]}}},Ln=class extends Cr{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(e){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${e}'`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),"length"in e){if("number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}},Dn=class extends Cr{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),"number"!=typeof e.iterations)throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,n,s,...i){if(super.checkImportKey(e,t,r,n,s,...i),n)throw new SyntaxError("extractable: Must be 'false'")}},Vn=class extends Cr{constructor(){super(...arguments),this.name="HKDF",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveKey","deriveBits"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!o.BufferSourceConverter.isBufferSource(e.salt))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"info"),!o.BufferSourceConverter.isBufferSource(e.info))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}checkImportKey(e,t,r,n,s,...i){if(super.checkImportKey(e,t,r,n,s,...i),n)throw new SyntaxError("extractable: Must be 'false'")}};class Rn extends Cr{constructor(){super(...arguments),this.usages=[],this.defaultLength=0}digest(...e){return e[0]={length:this.defaultLength,...e[0]},super.digest.apply(this,e)}checkDigest(e,t){super.checkDigest(e,t);const r=e.length||0;if("number"!=typeof r)throw new TypeError("length: Is not a Number");if(r<0)throw new TypeError("length: Is negative")}}let Mn=class extends Rn{constructor(){super(...arguments),this.name="shake128",this.defaultLength=16}},$n=class extends Rn{constructor(){super(...arguments),this.name="shake256",this.defaultLength=32}},Jn=class{get[Symbol.toStringTag](){return"Crypto"}randomUUID(){const e=this.getRandomValues(new Uint8Array(16));e[6]=15&e[6]|64,e[8]=63&e[8]|128;const t=o.Convert.ToHex(e).toLowerCase();return`${t.substring(0,8)}-${t.substring(8,12)}-${t.substring(12,16)}-${t.substring(16,20)}-${t.substring(20)}`}};class jn{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}const zn={jwk:["private","public","secret"],pkcs8:["private"],spki:["public"],raw:["secret","public"]},Fn=["pkcs8","spki","raw"];let Gn=class e{constructor(){this.providers=new jn}static isHashedAlgorithm(e){return!!(e&&"object"==typeof e&&"name"in e&&"hash"in e)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...e){this.checkRequiredArguments(e,2,"digest");const[t,r,...n]=e,s=this.prepareAlgorithm(t),i=o.BufferSourceConverter.toArrayBuffer(r),a=this.getProvider(s.name);return await a.digest(s,i,...n)}async generateKey(...e){this.checkRequiredArguments(e,3,"generateKey");const[t,r,n,...s]=e,i=this.prepareAlgorithm(t),o=this.getProvider(i.name);return await o.generateKey({...i,name:o.name},r,n,...s)}async sign(...e){this.checkRequiredArguments(e,3,"sign");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=o.BufferSourceConverter.toArrayBuffer(n),c=this.getProvider(i.name);return await c.sign({...i,name:c.name},r,a,...s)}async verify(...e){this.checkRequiredArguments(e,4,"verify");const[t,r,n,s,...i]=e;this.checkCryptoKey(r);const a=this.prepareAlgorithm(t),c=o.BufferSourceConverter.toArrayBuffer(s),u=o.BufferSourceConverter.toArrayBuffer(n),l=this.getProvider(a.name);return await l.verify({...a,name:l.name},r,u,c,...i)}async encrypt(...e){this.checkRequiredArguments(e,3,"encrypt");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=o.BufferSourceConverter.toArrayBuffer(n),c=this.getProvider(i.name);return await c.encrypt({...i,name:c.name},r,a,{keyUsage:!0},...s)}async decrypt(...e){this.checkRequiredArguments(e,3,"decrypt");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=o.BufferSourceConverter.toArrayBuffer(n),c=this.getProvider(i.name);return await c.decrypt({...i,name:c.name},r,a,{keyUsage:!0},...s)}async deriveBits(...e){this.checkRequiredArguments(e,3,"deriveBits");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),o=this.getProvider(i.name);return await o.deriveBits({...i,name:o.name},r,n,{keyUsage:!0},...s)}async deriveKey(...e){this.checkRequiredArguments(e,5,"deriveKey");const[t,r,n,s,i,...o]=e,a=this.prepareAlgorithm(n);this.getProvider(a.name).checkDerivedKeyParams(a);const c=this.prepareAlgorithm(t),u=this.getProvider(c.name);u.checkCryptoKey(r,"deriveKey");const l=await u.deriveBits({...c,name:u.name},r,n.length||512,{keyUsage:!1},...o);return this.importKey("raw",l,n,s,i,...o)}async exportKey(...e){this.checkRequiredArguments(e,2,"exportKey");const[t,r,...n]=e;if(this.checkCryptoKey(r),!zn[t])throw new TypeError("Invalid keyFormat argument");if(!zn[t].includes(r.type))throw new DOMException("The key is not of the expected type");const s=this.getProvider(r.algorithm.name);return await s.exportKey(t,r,...n)}async importKey(...e){this.checkRequiredArguments(e,5,"importKey");const[t,r,n,s,i,...a]=e,c=this.prepareAlgorithm(n),u=this.getProvider(c.name);if("jwk"===t){if("object"!=typeof r||!r.kty)throw new TypeError("Key data must be an object for JWK import")}else{if(!Fn.includes(t))throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView or JsonWebKey)'");if(!o.BufferSourceConverter.isBufferSource(r))throw new TypeError("Key data must be a BufferSource for non-JWK formats")}return u.importKey(t,r,{...c,name:u.name},s,i,...a)}async wrapKey(e,t,r,n,...s){let i=await this.exportKey(e,t,...s);if("jwk"===e){const e=JSON.stringify(i);i=o.Convert.FromUtf8String(e)}const a=this.prepareAlgorithm(n),c=o.BufferSourceConverter.toArrayBuffer(i),u=this.getProvider(a.name);return u.encrypt({...a,name:u.name},r,c,{keyUsage:!1},...s)}async unwrapKey(e,t,r,n,s,i,a,...c){const u=this.prepareAlgorithm(n),l=o.BufferSourceConverter.toArrayBuffer(t),h=this.getProvider(u.name);let y=await h.decrypt({...u,name:h.name},r,l,{keyUsage:!1},...c);if("jwk"===e)try{y=JSON.parse(o.Convert.ToUtf8String(y))}catch(e){const t=new TypeError("wrappedKey: Is not a JSON");throw t.internal=e,t}return this.importKey(e,y,s,i,a,...c)}checkRequiredArguments(e,t,r){if(e.length<t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(t){if("string"==typeof t)return{name:t};if(e.isHashedAlgorithm(t)){const e={...t};return e.hash=this.prepareAlgorithm(t.hash),e}return{...t}}getProvider(e){const t=this.providers.get(e);if(!t)throw new kr("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof jr))throw new TypeError("Key is not of type 'CryptoKey'")}};const _n={fromJSON:t=>e.from(o.Convert.FromBase64Url(t)),toJSON:e=>o.Convert.ToBase64Url(e)};class qn extends jr{constructor(){super(...arguments),this.data=e.alloc(0),this.algorithm={name:""},this.extractable=!1,this.type="secret",this.usages=[],this.kty="oct",this.alg=""}}n([Ar({name:"ext",type:ar.Boolean,optional:!0})],qn.prototype,"extractable",void 0),n([Ar({name:"key_ops",type:ar.String,repeated:!0,optional:!0})],qn.prototype,"usages",void 0),n([Ar({type:ar.String})],qn.prototype,"kty",void 0),n([Ar({type:ar.String,optional:!0})],qn.prototype,"alg",void 0);class Wn extends qn{constructor(){super(...arguments),this.kty="oct",this.type="secret"}}class Yn extends qn{}class Xn extends Wn{get alg(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-KW":return`A${this.algorithm.length}KW`;case"AES-CMAC":return`A${this.algorithm.length}CMAC`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new kr("Unsupported algorithm name")}}set alg(e){}}n([Ar({name:"k",converter:_n})],Xn.prototype,"data",void 0);class Zn{static async generateKey(e,r,n){const s=new Xn;return s.algorithm=e,s.extractable=r,s.usages=n,s.data=t.randomBytes(e.length>>3),s}static async exportKey(e,t){if(!(t instanceof Xn))throw new Error("key: Is not AesCryptoKey");switch(e.toLowerCase()){case"jwk":return wr.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new Br("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,n,s,i){let o;switch(t.toLowerCase()){case"jwk":o=vr.fromJSON(r,{targetSchema:Xn});break;case"raw":o=new Xn,o.data=e.from(r);break;default:throw new Br("format: Must be 'jwk' or 'raw'")}switch(o.algorithm=n,o.algorithm.length=o.data.length<<3,o.extractable=s,o.usages=i,o.algorithm.length){case 128:case 192:case 256:break;default:throw new Br("keyData: Is wrong key length")}return o}static async encrypt(t,r,n){switch(t.name.toUpperCase()){case"AES-CBC":return this.encryptAesCBC(t,r,e.from(n));case"AES-CTR":return this.encryptAesCTR(t,r,e.from(n));case"AES-GCM":return this.encryptAesGCM(t,r,e.from(n));case"AES-KW":return this.encryptAesKW(t,r,e.from(n));case"AES-ECB":return this.encryptAesECB(t,r,e.from(n));default:throw new Br("algorithm: Is not recognized")}}static async decrypt(t,r,n){if(!(r instanceof Xn))throw new Error("key: Is not AesCryptoKey");switch(t.name.toUpperCase()){case"AES-CBC":return this.decryptAesCBC(t,r,e.from(n));case"AES-CTR":return this.decryptAesCTR(t,r,e.from(n));case"AES-GCM":return this.decryptAesGCM(t,r,e.from(n));case"AES-KW":return this.decryptAesKW(t,r,e.from(n));case"AES-ECB":return this.decryptAesECB(t,r,e.from(n));default:throw new Br("algorithm: Is not recognized")}}static async encryptAesCBC(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-cbc`,n.data,new Uint8Array(r.iv));let o=i.update(s);o=e.concat([o,i.final()]);return new Uint8Array(o).buffer}static async decryptAesCBC(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-cbc`,n.data,new Uint8Array(r.iv));let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}static async encryptAesCTR(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-ctr`,n.data,e.from(r.counter));let o=i.update(s);o=e.concat([o,i.final()]);return new Uint8Array(o).buffer}static async decryptAesCTR(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-ctr`,n.data,new Uint8Array(r.counter));let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}static async encryptAesGCM(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-gcm`,n.data,e.from(r.iv),{authTagLength:(r.tagLength||128)>>3});r.additionalData&&i.setAAD(e.from(r.additionalData));let o=i.update(s);o=e.concat([o,i.final(),i.getAuthTag()]);return new Uint8Array(o).buffer}static async decryptAesGCM(r,n,s){const i=(r.tagLength||128)>>3,o=t.createDecipheriv(`aes-${n.algorithm.length}-gcm`,n.data,new Uint8Array(r.iv),{authTagLength:i}),a=s.slice(0,s.length-i),c=s.slice(s.length-i);r.additionalData&&o.setAAD(e.from(r.additionalData)),o.setAuthTag(c);let u=o.update(a);return u=e.concat([u,o.final()]),new Uint8Array(u).buffer}static async encryptAesKW(r,n,s){const i=t.createCipheriv(`id-aes${n.algorithm.length}-wrap`,n.data,this.AES_KW_IV);let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}static async decryptAesKW(r,n,s){const i=t.createDecipheriv(`id-aes${n.algorithm.length}-wrap`,n.data,this.AES_KW_IV);let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}static async encryptAesECB(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-ecb`,n.data,new Uint8Array(0));let o=i.update(s);o=e.concat([o,i.final()]);return new Uint8Array(o).buffer}static async decryptAesECB(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-ecb`,n.data,new Uint8Array(0));let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}}Zn.AES_KW_IV=e.from("A6A6A6A6A6A6A6A6","hex");const Qn=new WeakMap;function es(e){const t=Qn.get(e);if(!t)throw new Br("Cannot get CryptoKey from secure storage");return t}function ts(e){const t=jr.create(e.algorithm,e.type,e.extractable,e.usages);return Object.freeze(t),Qn.set(t,e),t}class rs extends Nr{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return Zn.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Zn.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}const ns=e.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),ss=e.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,135]),is=16;function os(t){const r=e.alloc(t.length),n=t.length-1;for(let e=0;e<n;e++)r[e]=t[e]<<1,128&t[e+1]&&(r[e]+=1);return r[n]=t[n]<<1,r}function as(t,r){const n=Math.min(t.length,r.length),s=e.alloc(n);for(let e=0;e<n;e++)s[e]=t[e]^r[e];return s}function cs(e,r){const n=t.createCipheriv("aes"+(e.length<<3),e,ns),s=n.update(r);return n.final(),s}function us(t,r){const n=e.alloc(is),s=r*is,i=s+is;return t.copy(n,0,s,i),n}function ls(t,r){const n=function(e){const t=cs(e,ns);let r=os(t);128&t[0]&&(r=as(r,ss));let n=os(r);return 128&r[0]&&(n=as(n,ss)),{subkey1:r,subkey2:n}}(t);let s,i,o=Math.ceil(r.length/is);0===o?(o=1,s=!1):s=r.length%is==0;const a=o-1;i=s?as(us(r,a),n.subkey1):as(function(t,r){const n=e.alloc(is),s=r*is,i=t.length;return n.fill(0),t.copy(n,0,s,i),n[i-s]=128,n}(r,a),n.subkey2);let c,u=ns;for(let e=0;e<a;e++)c=as(u,us(r,e)),u=cs(t,c);return c=as(i,u),cs(t,c)}class hs extends Ur{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onSign(t,r,n){const s=ls(es(r).data,e.from(n));return new Uint8Array(s).buffer}async onVerify(t,r,n,s){const i=await this.sign(t,r,s);return 0===e.from(n).compare(e.from(i))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}class ys extends Pr{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return Zn.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Zn.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}class fs extends Or{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return Zn.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Zn.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}class ps extends Hr{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}async onEncrypt(e,t,r){return Zn.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Zn.decrypt(e,es(t),new Uint8Array(r))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}class gs extends Ir{async onGenerateKey(e,t,r){return ts(await Zn.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return Zn.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Zn.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return Zn.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Zn.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Xn))throw new TypeError("key: Is not a AesCryptoKey")}}class ms extends Wn{get alg(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new kr("Unsupported algorithm name")}}set alg(e){}}n([Ar({name:"k",converter:_n})],ms.prototype,"data",void 0);class ds{static async generateKey(e,r,n){const s=new ms;return s.algorithm=e,s.extractable=r,s.usages=n,s.data=t.randomBytes(e.length>>3),s}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return wr.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new Br("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,n,s,i){let o;switch(t.toLowerCase()){case"jwk":o=vr.fromJSON(r,{targetSchema:ms});break;case"raw":o=new ms,o.data=e.from(r);break;default:throw new Br("format: Must be 'jwk' or 'raw'")}return o.algorithm=n,o.extractable=s,o.usages=i,o}static async encrypt(t,r,n){switch(t.name.toUpperCase()){case"DES-CBC":return this.encryptDesCBC(t,r,e.from(n));case"DES-EDE3-CBC":return this.encryptDesEDE3CBC(t,r,e.from(n));default:throw new Br("algorithm: Is not recognized")}}static async decrypt(t,r,n){if(!(r instanceof ms))throw new Error("key: Is not DesCryptoKey");switch(t.name.toUpperCase()){case"DES-CBC":return this.decryptDesCBC(t,r,e.from(n));case"DES-EDE3-CBC":return this.decryptDesEDE3CBC(t,r,e.from(n));default:throw new Br("algorithm: Is not recognized")}}static async encryptDesCBC(r,n,s){const i=t.createCipheriv("des-cbc",n.data,new Uint8Array(r.iv));let o=i.update(s);o=e.concat([o,i.final()]);return new Uint8Array(o).buffer}static async decryptDesCBC(r,n,s){const i=t.createDecipheriv("des-cbc",n.data,new Uint8Array(r.iv));let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}static async encryptDesEDE3CBC(r,n,s){const i=t.createCipheriv("des-ede3-cbc",n.data,e.from(r.iv));let o=i.update(s);o=e.concat([o,i.final()]);return new Uint8Array(o).buffer}static async decryptDesEDE3CBC(r,n,s){const i=t.createDecipheriv("des-ede3-cbc",n.data,new Uint8Array(r.iv));let o=i.update(s);return o=e.concat([o,i.final()]),new Uint8Array(o).buffer}}class ws extends Tr{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}async onGenerateKey(e,t,r){return ts(await ds.generateKey({name:this.name,length:this.keySizeBits},t,r))}async onEncrypt(e,t,r){return ds.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return ds.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return ds.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){const i=await ds.importKey(e,t,{name:this.name,length:this.keySizeBits},n,s);if(i.data.length!==this.keySizeBits>>3)throw new Br("keyData: Wrong key size");return ts(i)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof ms))throw new TypeError("key: Is not a DesCryptoKey")}}class vs extends Tr{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}async onGenerateKey(e,t,r){return ts(await ds.generateKey({name:this.name,length:this.keySizeBits},t,r))}async onEncrypt(e,t,r){return ds.encrypt(e,es(t),new Uint8Array(r))}async onDecrypt(e,t,r){return ds.decrypt(e,es(t),new Uint8Array(r))}async onExportKey(e,t){return ds.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){const i=await ds.importKey(e,t,{name:this.name,length:this.keySizeBits},n,s);if(i.data.length!==this.keySizeBits>>3)throw new Br("keyData: Wrong key size");return ts(i)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof ms))throw new TypeError("key: Is not a DesCryptoKey")}}function As(e){switch(e.name.toUpperCase()){case"RSA-OAEP":{const t=/(\d+)$/.exec(e.hash.name)[1];return"RSA-OAEP"+("1"!==t?`-${t}`:"")}case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PKCS1":return"RS1";default:throw new Br("algorithm: Is not recognized")}}class bs extends Yn{constructor(){super(...arguments),this.type="private"}getKey(){const e=Zt.parse(this.data,In.PrivateKeyInfo);return Zt.parse(e.privateKey,In.RsaPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:As(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,wr.toJSON(e))}fromJSON(t){const r=vr.fromJSON(t,{targetSchema:In.RsaPrivateKey}),n=new In.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.privateKeyAlgorithm.parameters=null,n.privateKey=Qt.serialize(r),this.data=e.from(Qt.serialize(n))}}class ks extends Yn{constructor(){super(...arguments),this.type="public"}getKey(){const e=Zt.parse(this.data,In.PublicKeyInfo);return Zt.parse(e.publicKey,In.RsaPublicKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:As(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,wr.toJSON(e))}fromJSON(t){const r=vr.fromJSON(t,{targetSchema:In.RsaPublicKey}),n=new In.PublicKeyInfo;n.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.publicKeyAlgorithm.parameters=null,n.publicKey=Qt.serialize(r),this.data=e.from(Qt.serialize(n))}}class Ss{static async generateKey(r,n,s){const i=new bs;i.algorithm=r,i.extractable=n,i.usages=s.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const o=new ks;o.algorithm=r,o.extractable=!0,o.usages=s.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const a=e.concat([e.alloc(4-r.publicExponent.byteLength,0),e.from(r.publicExponent)]).readInt32BE(0),c=t.generateKeyPairSync("rsa",{modulusLength:r.modulusLength,publicExponent:a,publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});i.data=c.privateKey,o.data=c.publicKey;return{privateKey:i,publicKey:o}}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return wr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;default:throw new Br("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":if(t.d){const e=vr.fromJSON(t,{targetSchema:In.RsaPrivateKey});return this.importPrivateKey(e,r,n,s)}{const e=vr.fromJSON(t,{targetSchema:In.RsaPublicKey});return this.importPublicKey(e,r,n,s)}case"spki":{const e=Zt.parse(new Uint8Array(t),In.PublicKeyInfo),i=Zt.parse(e.publicKey,In.RsaPublicKey);return this.importPublicKey(i,r,n,s)}case"pkcs8":{const e=Zt.parse(new Uint8Array(t),In.PrivateKeyInfo),i=Zt.parse(e.privateKey,In.RsaPrivateKey);return this.importPrivateKey(i,r,n,s)}default:throw new Br("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async sign(e,t,r){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.signRsa(e,t,r);default:throw new Br("algorithm: Is not recognized")}}static async verify(e,t,r,n){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.verifySSA(e,t,n,r);default:throw new Br("algorithm: Is not recognized")}}static async encrypt(e,t,r){if("RSA-OAEP"===e.name.toUpperCase())return this.encryptOAEP(e,t,r);throw new Br("algorithm: Is not recognized")}static async decrypt(e,t,r){if("RSA-OAEP"===e.name.toUpperCase())return this.decryptOAEP(e,t,r);throw new Br("algorithm: Is not recognized")}static importPrivateKey(t,r,n,s){const i=new In.PrivateKeyInfo;i.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",i.privateKeyAlgorithm.parameters=null,i.privateKey=Qt.serialize(t);const o=new bs;return o.data=e.from(Qt.serialize(i)),o.algorithm=Object.assign({},r),o.algorithm.publicExponent=new Uint8Array(t.publicExponent),o.algorithm.modulusLength=t.modulus.byteLength<<3,o.extractable=n,o.usages=s,o}static importPublicKey(t,r,n,s){const i=new In.PublicKeyInfo;i.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",i.publicKeyAlgorithm.parameters=null,i.publicKey=Qt.serialize(t);const o=new ks;return o.data=e.from(Qt.serialize(i)),o.algorithm=Object.assign({},r),o.algorithm.publicExponent=new Uint8Array(t.publicExponent),o.algorithm.modulusLength=t.modulus.byteLength<<3,o.extractable=n,o.usages=s,o}static getCryptoAlgorithm(e){switch(e.hash.name.toUpperCase()){case"SHA-1":return"RSA-SHA1";case"SHA-256":return"RSA-SHA256";case"SHA-384":return"RSA-SHA384";case"SHA-512":return"RSA-SHA512";case"SHA3-256":return"RSA-SHA3-256";case"SHA3-384":return"RSA-SHA3-384";case"SHA3-512":return"RSA-SHA3-512";default:throw new Br("algorithm.hash: Is not recognized")}}static signRsa(r,n,s){const i=this.getCryptoAlgorithm(n.algorithm),o=t.createSign(i);o.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const a={key:n.pem};"RSA-PSS"===r.name.toUpperCase()&&(a.padding=t.constants.RSA_PKCS1_PSS_PADDING,a.saltLength=r.saltLength);const c=o.sign(a);return new Uint8Array(c).buffer}static verifySSA(r,n,s,i){const o=this.getCryptoAlgorithm(n.algorithm),a=t.createVerify(o);a.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const c={key:n.pem};"RSA-PSS"===r.name.toUpperCase()&&(c.padding=t.constants.RSA_PKCS1_PSS_PADDING,c.saltLength=r.saltLength);return a.verify(c,i)}static encryptOAEP(e,r,n){const s={key:`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`,padding:t.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(t.publicEncrypt(s,n)).buffer}static decryptOAEP(e,r,n){const s={key:`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`,padding:t.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(t.privateDecrypt(s,n)).buffer}}Ss.publicKeyUsages=["verify","encrypt","wrapKey"],Ss.privateKeyUsages=["sign","decrypt","unwrapKey"];class Bs extends Dr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await Ss.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onSign(e,t,r){return Ss.sign(e,es(t),new Uint8Array(r))}async onVerify(e,t,r,n){return Ss.verify(e,es(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return Ss.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ss.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof bs||r instanceof ks))throw new TypeError("key: Is not RSA CryptoKey")}}class Es extends Vr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await Ss.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onSign(e,t,r){return Ss.sign(e,es(t),new Uint8Array(r))}async onVerify(e,t,r,n){return Ss.verify(e,es(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return Ss.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ss.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof bs||r instanceof ks))throw new TypeError("key: Is not RSA CryptoKey")}}class Ks{static size(e){switch(e.name.toUpperCase()){case"SHA-1":return 160;case"SHA-256":case"SHA3-256":return 256;case"SHA-384":case"SHA3-384":return 384;case"SHA-512":case"SHA3-512":return 512;default:throw new Error("Unrecognized name")}}static getAlgorithmName(e){switch(e.name.toUpperCase()){case"SHA-1":return"sha1";case"SHA-256":return"sha256";case"SHA-384":return"sha384";case"SHA-512":return"sha512";case"SHA3-256":return"sha3-256";case"SHA3-384":return"sha3-384";case"SHA3-512":return"sha3-512";default:throw new Error("Unrecognized name")}}static digest(r,n){const s=this.getAlgorithmName(r),i=t.createHash(s).update(e.from(n)).digest();return new Uint8Array(i).buffer}}class Cs extends Rr{async onGenerateKey(e,t,r){const n=await Ss.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onEncrypt(r,n,s){const i=es(n),a=new Uint8Array(s),c=Math.ceil(i.algorithm.modulusLength>>3),u=Ks.size(i.algorithm.hash)>>3,l=a.byteLength,h=c-l-2*u-2;if(l>c-2*u-2)throw new Error("Data too large");const y=new Uint8Array(c),f=y.subarray(1,u+1),p=y.subarray(u+1);p.set(a,u+h+1);const g=t.createHash(i.algorithm.hash.name.replace("-","")).update(o.BufferSourceConverter.toUint8Array(r.label||new Uint8Array(0))).digest();p.set(g,0),p[u+h]=1,t.randomFillSync(f);const m=this.mgf1(i.algorithm.hash,f,p.length);for(let e=0;e<p.length;e++)p[e]^=m[e];const d=this.mgf1(i.algorithm.hash,p,f.length);for(let e=0;e<f.length;e++)f[e]^=d[e];i.pem||(i.pem=`-----BEGIN PUBLIC KEY-----\n${i.data.toString("base64")}\n-----END PUBLIC KEY-----`);const w=t.publicEncrypt({key:i.pem,padding:t.constants.RSA_NO_PADDING},e.from(y));return new Uint8Array(w).buffer}async onDecrypt(r,n,s){const i=es(n),a=Math.ceil(i.algorithm.modulusLength>>3),c=Ks.size(i.algorithm.hash)>>3;if(s.byteLength!==a)throw new Error("Bad data");i.pem||(i.pem=`-----BEGIN PRIVATE KEY-----\n${i.data.toString("base64")}\n-----END PRIVATE KEY-----`);let u=t.privateDecrypt({key:i.pem,padding:t.constants.RSA_NO_PADDING},e.from(s));const l=u[0],h=u.subarray(1,c+1),y=u.subarray(c+1);if(0!==l)throw new Error("Decryption failed");const f=this.mgf1(i.algorithm.hash,y,h.length);for(let e=0;e<h.length;e++)h[e]^=f[e];const p=this.mgf1(i.algorithm.hash,h,y.length);for(let e=0;e<y.length;e++)y[e]^=p[e];const g=t.createHash(i.algorithm.hash.name.replace("-","")).update(o.BufferSourceConverter.toUint8Array(r.label||new Uint8Array(0))).digest();for(let e=0;e<c;e++)if(g[e]!==y[e])throw new Error("Decryption failed");let m=c;for(;m<y.length;m++){const e=y[m];if(1===e)break;if(0!==e)throw new Error("Decryption failed")}if(m===y.length)throw new Error("Decryption failed");return u=y.subarray(m+1),new Uint8Array(u).buffer}async onExportKey(e,t){return Ss.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ss.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof bs||r instanceof ks))throw new TypeError("key: Is not RSA CryptoKey")}mgf1(e,r,n=0){const s=Ks.size(e)>>3,i=new Uint8Array(n),o=new Uint8Array(4),a=Math.ceil(n/s);for(let n=0;n<a;n++){o[0]=n>>>24,o[1]=n>>>16&255,o[2]=n>>>8&255,o[3]=255&n;const a=i.subarray(n*s);let c=t.createHash(e.name.replace("-","")).update(r).update(o).digest();c.length>a.length&&(c=c.subarray(0,a.length)),a.set(c)}return i}}class xs extends Cr{constructor(){super(...arguments),this.name="RSAES-PKCS1-v1_5",this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]}}async onGenerateKey(e,t,r){const n=await Ss.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=o.Convert.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}async onEncrypt(e,r,n){const s=this.toCryptoOptions(r),i=t.publicEncrypt(s,new Uint8Array(n));return new Uint8Array(i).buffer}async onDecrypt(e,r,n){const s=this.toCryptoOptions(r),i=t.privateDecrypt(s,new Uint8Array(n));return new Uint8Array(i).buffer}async onExportKey(e,t){return Ss.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ss.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof bs||r instanceof ks))throw new TypeError("key: Is not RSA CryptoKey")}toCryptoOptions(e){const r=e.type.toUpperCase();return{key:`-----BEGIN ${r} KEY-----\n${es(e).data.toString("base64")}\n-----END ${r} KEY-----`,padding:t.constants.RSA_PKCS1_PADDING}}}const Ns={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10",brainpoolP160r1:"1.3.36.3.3.2.8.1.1.1","1.3.36.3.3.2.8.1.1.1":"brainpoolP160r1",brainpoolP160t1:"1.3.36.3.3.2.8.1.1.2","1.3.36.3.3.2.8.1.1.2":"brainpoolP160t1",brainpoolP192r1:"1.3.36.3.3.2.8.1.1.3","1.3.36.3.3.2.8.1.1.3":"brainpoolP192r1",brainpoolP192t1:"1.3.36.3.3.2.8.1.1.4","1.3.36.3.3.2.8.1.1.4":"brainpoolP192t1",brainpoolP224r1:"1.3.36.3.3.2.8.1.1.5","1.3.36.3.3.2.8.1.1.5":"brainpoolP224r1",brainpoolP224t1:"1.3.36.3.3.2.8.1.1.6","1.3.36.3.3.2.8.1.1.6":"brainpoolP224t1",brainpoolP256r1:"1.3.36.3.3.2.8.1.1.7","1.3.36.3.3.2.8.1.1.7":"brainpoolP256r1",brainpoolP256t1:"1.3.36.3.3.2.8.1.1.8","1.3.36.3.3.2.8.1.1.8":"brainpoolP256t1",brainpoolP320r1:"1.3.36.3.3.2.8.1.1.9","1.3.36.3.3.2.8.1.1.9":"brainpoolP320r1",brainpoolP320t1:"1.3.36.3.3.2.8.1.1.10","1.3.36.3.3.2.8.1.1.10":"brainpoolP320t1",brainpoolP384r1:"1.3.36.3.3.2.8.1.1.11","1.3.36.3.3.2.8.1.1.11":"brainpoolP384r1",brainpoolP384t1:"1.3.36.3.3.2.8.1.1.12","1.3.36.3.3.2.8.1.1.12":"brainpoolP384t1",brainpoolP512r1:"1.3.36.3.3.2.8.1.1.13","1.3.36.3.3.2.8.1.1.13":"brainpoolP512r1",brainpoolP512t1:"1.3.36.3.3.2.8.1.1.14","1.3.36.3.3.2.8.1.1.14":"brainpoolP512t1"};function Us(e){const t=Ns[e];if(!t)throw new Br(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Ps extends Yn{constructor(){super(...arguments),this.type="private"}getKey(){const e=Zt.parse(this.data,In.PrivateKeyInfo);return Zt.parse(e.privateKey,In.EcPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,wr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Br("Cannot get named curve from JWK. Property 'crv' is required");const r=new In.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",r.privateKeyAlgorithm.parameters=Qt.serialize(new In.ObjectIdentifier(Us(t.crv)));const n=vr.fromJSON(t,{targetSchema:In.EcPrivateKey});return r.privateKey=Qt.serialize(n),this.data=e.from(Qt.serialize(r)),this}}class Is extends Yn{constructor(){super(...arguments),this.type="public"}getKey(){const e=Zt.parse(this.data,In.PublicKeyInfo);return new In.EcPublicKey(e.publicKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,wr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Br("Cannot get named curve from JWK. Property 'crv' is required");const r=vr.fromJSON(t,{targetSchema:In.EcPublicKey}),n=new In.PublicKeyInfo;return n.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1",n.publicKeyAlgorithm.parameters=Qt.serialize(new In.ObjectIdentifier(Us(t.crv))),n.publicKey=Qt.toASN(r).valueHex,this.data=e.from(Qt.serialize(n)),this}}class Os extends Cr{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Hs extends Cr{constructor(){super(...arguments),this.name="SHA-256",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Ts extends Cr{constructor(){super(...arguments),this.name="SHA-384",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Ls extends Cr{constructor(){super(...arguments),this.name="SHA-512",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Ds extends Cr{constructor(){super(...arguments),this.name="SHA3-256",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Vs extends Cr{constructor(){super(...arguments),this.name="SHA3-384",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Rs extends Cr{constructor(){super(...arguments),this.name="SHA3-512",this.usages=[]}async onDigest(e,t){return Ks.digest(e,t)}}class Ms{static async generateKey(e,r,n){const s=new Ps;s.algorithm=e,s.extractable=r,s.usages=n.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const i=new Is;i.algorithm=e,i.extractable=!0,i.usages=n.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const o=t.generateKeyPairSync("ec",{namedCurve:this.getOpenSSLNamedCurve(e.namedCurve),publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});s.data=o.privateKey,i.data=o.publicKey;return{privateKey:s,publicKey:i}}static async sign(r,n,s){const i=Ks.getAlgorithmName(r.hash),o=t.createSign(i);o.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const a={key:n.pem},c=o.sign(a),u=Zt.parse(c,In.EcDsaSignature);return on.encodeSignature(u,On.get(n.algorithm.namedCurve).size).buffer}static async verify(r,n,s,i){const a=Ks.getAlgorithmName(r.hash),c=t.createVerify(a);c.update(e.from(i)),n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const u={key:n.pem},l=new In.EcDsaSignature,h=On.get(n.algorithm.namedCurve),y=on.decodeSignature(s,h.size);l.r=o.BufferSourceConverter.toArrayBuffer(y.r),l.s=o.BufferSourceConverter.toArrayBuffer(y.s);const f=e.from(Qt.serialize(l));return c.verify(u,f)}static async deriveBits(r,n,s){const i=this.getOpenSSLNamedCurve(n.algorithm.namedCurve),o=t.createECDH(i),a=Zt.parse(n.data,In.PrivateKeyInfo),c=Zt.parse(a.privateKey,In.EcPrivateKey);o.setPrivateKey(e.from(c.privateKey));const u=Zt.parse(r.public.data,In.PublicKeyInfo),l=o.computeSecret(e.from(u.publicKey));return null===s?l:new Uint8Array(l).buffer.slice(0,s>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return wr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return Zt.parse(t.data,In.PublicKeyInfo).publicKey;default:throw new Br("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":if(t.d){const e=vr.fromJSON(t,{targetSchema:In.EcPrivateKey});return this.importPrivateKey(e,r,n,s)}{const e=vr.fromJSON(t,{targetSchema:In.EcPublicKey});return this.importPublicKey(e,r,n,s)}case"raw":{const e=new In.EcPublicKey(t);return this.importPublicKey(e,r,n,s)}case"spki":{const e=Zt.parse(new Uint8Array(t),In.PublicKeyInfo),i=new In.EcPublicKey(e.publicKey);return this.assertKeyParameters(e.publicKeyAlgorithm.parameters,r.namedCurve),this.importPublicKey(i,r,n,s)}case"pkcs8":{const e=Zt.parse(new Uint8Array(t),In.PrivateKeyInfo),i=Zt.parse(e.privateKey,In.EcPrivateKey);return this.assertKeyParameters(e.privateKeyAlgorithm.parameters,r.namedCurve),this.importPrivateKey(i,r,n,s)}default:throw new Br("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static assertKeyParameters(e,t){if(!e)throw new br("Key info doesn't have required parameters");let r="";try{r=Zt.parse(e,In.ObjectIdentifier).value}catch(e){throw new br("Cannot read key info parameters")}if(Us(t)!==r)throw new br("Key info parameter doesn't match to named curve")}static async importPrivateKey(t,r,n,s){const i=new In.PrivateKeyInfo;i.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",i.privateKeyAlgorithm.parameters=Qt.serialize(new In.ObjectIdentifier(Us(r.namedCurve))),i.privateKey=Qt.serialize(t);const o=new Ps;return o.data=e.from(Qt.serialize(i)),o.algorithm=Object.assign({},r),o.extractable=n,o.usages=s,o}static async importPublicKey(t,r,n,s){const i=new In.PublicKeyInfo;i.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1";const o=Us(r.namedCurve);i.publicKeyAlgorithm.parameters=Qt.serialize(new In.ObjectIdentifier(o)),i.publicKey=t.value;const a=new Is;return a.data=e.from(Qt.serialize(i)),a.algorithm=Object.assign({},r),a.extractable=n,a.usages=s,a}static getOpenSSLNamedCurve(e){switch(e.toUpperCase()){case"P-256":return"prime256v1";case"K-256":return"secp256k1";case"P-384":return"secp384r1";case"P-521":return"secp521r1";default:return e}}}Ms.publicKeyUsages=["verify"],Ms.privateKeyUsages=["sign","deriveKey","deriveBits"];class $s extends $r{constructor(){super(...arguments),this.namedCurves=On.names,this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await Ms.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onSign(e,t,r){return Ms.sign(e,es(t),new Uint8Array(r))}async onVerify(e,t,r,n){return Ms.verify(e,es(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return Ms.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ms.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof Ps||r instanceof Is))throw new TypeError("key: Is not EC CryptoKey")}}class Js extends zr{constructor(){super(...arguments),this.namedCurves=On.names}async onGenerateKey(e,t,r){const n=await Ms.generateKey({...e,name:this.name},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onExportKey(e,t){return Ms.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await Ms.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=es(e);if(!(r instanceof Ps||r instanceof Is))throw new TypeError("key: Is not EC CryptoKey")}async onDeriveBits(e,t,r){return await Ms.deriveBits({...e,public:es(e.public)},es(t),r)}}const js={[In.idEd448]:"Ed448",ed448:In.idEd448,[In.idX448]:"X448",x448:In.idX448,[In.idEd25519]:"Ed25519",ed25519:In.idEd25519,[In.idX25519]:"X25519",x25519:In.idX25519};function zs(e){const t=js[e.toLowerCase()];if(!t)throw new Br(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Fs extends Yn{constructor(){super(...arguments),this.type="private"}getKey(){const e=Zt.parse(this.data,In.PrivateKeyInfo);return Zt.parse(e.privateKey,In.CurvePrivateKey)}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,wr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Br("Cannot get named curve from JWK. Property 'crv' is required");const r=new In.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm=zs(t.crv);const n=vr.fromJSON(t,{targetSchema:In.CurvePrivateKey});return r.privateKey=Qt.serialize(n),this.data=e.from(Qt.serialize(r)),this}}class Gs extends Yn{constructor(){super(...arguments),this.type="public"}getKey(){return Zt.parse(this.data,In.PublicKeyInfo).publicKey}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,{x:o.Convert.ToBase64Url(e)})}fromJSON(t){if(!t.crv)throw new Br("Cannot get named curve from JWK. Property 'crv' is required");if(!t.x)throw new Br("Cannot get property from JWK. Property 'x' is required");const r=new In.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm=zs(t.crv),r.publicKey=o.Convert.FromBase64Url(t.x),this.data=e.from(Qt.serialize(r)),this}}class _s{static async generateKey(e,r,n){const s=new Fs;s.algorithm=e,s.extractable=r,s.usages=n.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const i=new Gs;i.algorithm=e,i.extractable=!0,i.usages=n.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const o=e.namedCurve.toLowerCase(),a=t.generateKeyPairSync(o,{publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});s.data=a.privateKey,i.data=a.publicKey;return{privateKey:s,publicKey:i}}static async sign(r,n,s){n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const i={key:n.pem},a=t.sign(null,e.from(s),i);return o.BufferSourceConverter.toArrayBuffer(a)}static async verify(r,n,s,i){n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const o={key:n.pem};return t.verify(null,e.from(i),o,e.from(s))}static async deriveBits(e,r,n){const s=t.createPublicKey({key:e.public.data,format:"der",type:"spki"}),i=t.createPrivateKey({key:r.data,format:"der",type:"pkcs8"}),o=t.diffieHellman({publicKey:s,privateKey:i});return new Uint8Array(o).buffer.slice(0,n>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return wr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return Zt.parse(t.data,In.PublicKeyInfo).publicKey;default:throw new Br("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":{const e=t;if(e.d){const e=vr.fromJSON(t,{targetSchema:In.CurvePrivateKey});return this.importPrivateKey(e,r,n,s)}if(!e.x)throw new TypeError("keyData: Cannot get required 'x' filed");return this.importPublicKey(o.Convert.FromBase64Url(e.x),r,n,s)}case"raw":return this.importPublicKey(t,r,n,s);case"spki":{const e=Zt.parse(new Uint8Array(t),In.PublicKeyInfo);return this.importPublicKey(e.publicKey,r,n,s)}case"pkcs8":{const e=Zt.parse(new Uint8Array(t),In.PrivateKeyInfo),i=Zt.parse(e.privateKey,In.CurvePrivateKey);return this.importPrivateKey(i,r,n,s)}default:throw new Br("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static importPrivateKey(e,t,r,n){const s=new Fs;return s.fromJSON({crv:t.namedCurve,d:o.Convert.ToBase64Url(e.d)}),s.algorithm=Object.assign({},t),s.extractable=r,s.usages=n,s}static async importPublicKey(e,t,r,n){const s=new Gs;return s.fromJSON({crv:t.namedCurve,x:o.Convert.ToBase64Url(e)}),s.algorithm=Object.assign({},t),s.extractable=r,s.usages=n,s}}_s.publicKeyUsages=["verify"],_s.privateKeyUsages=["sign","deriveKey","deriveBits"];class qs extends Gr{async onGenerateKey(e,t,r){const n=await _s.generateKey({name:this.name,namedCurve:e.namedCurve.replace(/^ed/i,"Ed")},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onSign(e,t,r){return _s.sign(e,es(t),new Uint8Array(r))}async onVerify(e,t,r,n){return _s.verify(e,es(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return _s.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await _s.importKey(e,t,{...r,name:this.name},n,s))}}class Ws extends Fr{async onGenerateKey(e,t,r){const n=await _s.generateKey({name:this.name,namedCurve:e.namedCurve.toUpperCase()},t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onDeriveBits(e,t,r){return await _s.deriveBits({...e,public:es(e.public)},es(t),r)}async onExportKey(e,t){return _s.exportKey(e,es(t))}async onImportKey(e,t,r,n,s){return ts(await _s.importKey(e,t,{...r,name:this.name},n,s))}}class Ys extends qn{constructor(t,r,n,s){super(),this.algorithm=t,this.extractable=r,this.usages=n,this.data=e.from(s)}toJWK(){return{kty:"OKP",crv:this.algorithm.name,key_ops:this.usages,ext:this.extractable}}}class Xs extends Ys{constructor(){super(...arguments),this.type="private"}toJWK(){const r=t.createPublicKey({key:this.data,format:"pem"}).export({format:"jwk"}),n=Kr.toUint8Array(this.data.toString()),s=er.parse(n,In.PrivateKeyInfo),i=er.parse(s.privateKey,In.EdPrivateKey).value;return{...super.toJWK(),...r,d:e.from(new Uint8Array(i)).toString("base64url")}}}class Zs extends Ys{constructor(){super(...arguments),this.type="public"}toJWK(){const e=t.createPublicKey({key:this.data,format:"pem"}).export({format:"jwk"});return{...super.toJWK(),...e}}}class Qs{static async generateKey(e,r,n){const s=e.name.toLowerCase(),i=t.generateKeyPairSync(s,{publicKeyEncoding:{format:"pem",type:"spki"},privateKeyEncoding:{format:"pem",type:"pkcs8"}}),o={name:"ed25519"===s?"Ed25519":"X25519"},a=n.filter((e=>this.privateKeyUsages.includes(e))),c=n.filter((e=>this.publicKeyUsages.includes(e)));return{privateKey:new Xs(o,r,a,i.privateKey),publicKey:new Zs(o,!0,c,i.publicKey)}}static async sign(r,n,s){const i=t.sign(null,e.from(s),n.data);return o.BufferSourceConverter.toArrayBuffer(i)}static async verify(r,n,s,i){return t.verify(null,e.from(i),n.data,s)}static async exportKey(e,t){switch(e){case"jwk":return t.toJWK();case"pkcs8":case"spki":return Kr.toArrayBuffer(t.data.toString());case"raw":{const e=t.toJWK();return o.Convert.FromBase64Url(e.x)}default:return Promise.reject(new Br("format: Must be 'jwk', 'raw', pkcs8' or 'spki'"))}}static async importKey(r,n,s,i,a){switch(r){case"jwk":{const r=n;if(r.d){const t=new In.EdPrivateKey;t.value=o.BufferSourceConverter.toArrayBuffer(e.from(r.d,"base64url"));const n=new In.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="ed25519"===s.name.toLowerCase()?In.idEd25519:In.idX25519,n.privateKey=er.serialize(t);const c=er.serialize(n),u=Kr.fromBufferSource(c,"PRIVATE KEY");return new Xs(s,i,a,u)}if(r.x){const e=t.createPublicKey({format:"jwk",key:r}).export({format:"pem",type:"spki"});return new Zs(s,i,a,e)}throw new Br("keyData: Cannot import JWK. 'd' or 'x' must be presented")}case"pkcs8":{const e=Kr.fromBufferSource(n,"PRIVATE KEY");return new Xs(s,i,a,e)}case"spki":{const e=Kr.fromBufferSource(n,"PUBLIC KEY");return new Zs(s,i,a,e)}case"raw":{const e=n,r=t.createPublicKey({format:"jwk",key:{kty:"OKP",crv:"ed25519"===s.name.toLowerCase()?"Ed25519":"X25519",x:o.Convert.ToBase64Url(e)}}).export({format:"pem",type:"spki"});return new Zs(s,i,a,r)}default:return Promise.reject(new Br("format: Must be 'jwk', 'raw', pkcs8' or 'spki'"))}}}Qs.privateKeyUsages=["sign","deriveBits","deriveKey"],Qs.publicKeyUsages=["verify"];class ei extends Tn{async onGenerateKey(e,t,r){const n=await Qs.generateKey(e,t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onSign(e,t,r){const n=es(t);return Qs.sign(e,n,new Uint8Array(r))}onVerify(e,t,r,n){const s=es(t);return Qs.verify(e,s,new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){const r=es(t);return Qs.exportKey(e,r)}async onImportKey(e,t,r,n,s){return ts(await Qs.importKey(e,t,r,n,s))}}class ti extends Hn{async onGenerateKey(e,t,r){const n=await Qs.generateKey(e,t,r);return{privateKey:ts(n.privateKey),publicKey:ts(n.publicKey)}}async onDeriveBits(e,r,n){const s=es(r),i=es(e.public),o=t.createPublicKey({key:i.data.toString(),format:"pem",type:"spki"}),a=t.createPrivateKey({key:s.data.toString(),format:"pem",type:"pkcs8"}),c=t.diffieHellman({publicKey:o,privateKey:a});return new Uint8Array(c).buffer.slice(0,n>>3)}async onExportKey(e,t){const r=es(t);return Qs.exportKey(e,r)}async onImportKey(e,t,r,n,s){return ts(await Qs.importKey(e,t,r,n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof Ys))throw new TypeError("key: Is not a Ed25519CryptoKey")}}class ri extends qn{}class ni extends Dn{async onDeriveBits(r,n,s){return new Promise(((i,a)=>{const c=o.BufferSourceConverter.toArrayBuffer(r.salt),u=r.hash.name.replace("-","");t.pbkdf2(es(n).data,e.from(c),r.iterations,s>>3,u,((e,t)=>{e?a(e):i(new Uint8Array(t).buffer)}))}))}async onImportKey(t,r,n,s,i){if("raw"===t){const t=new ri;return t.data=e.from(r),t.algorithm={name:this.name},t.extractable=!1,t.usages=i,ts(t)}throw new Br("format: Must be 'raw'")}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof ri))throw new TypeError("key: Is not PBKDF CryptoKey")}}class si extends qn{get alg(){return`HS${this.algorithm.hash.name.toUpperCase().replace("SHA-","")}`}set alg(e){}}n([Ar({name:"k",converter:_n})],si.prototype,"data",void 0);class ii extends Ln{async onGenerateKey(e,r,n){const s=(e.length||this.getDefaultLength(e.hash.name))>>3<<3,i=new si;return i.algorithm={...e,length:s,name:this.name},i.extractable=r,i.usages=n,i.data=t.randomBytes(s>>3),ts(i)}async onSign(r,n,s){const i=Ks.getAlgorithmName(n.algorithm.hash),o=t.createHmac(i,es(n).data).update(e.from(s)).digest();return new Uint8Array(o).buffer}async onVerify(r,n,s,i){const o=Ks.getAlgorithmName(n.algorithm.hash);return 0===t.createHmac(o,es(n).data).update(e.from(i)).digest().compare(e.from(s))}async onImportKey(t,r,n,s,i){let o;switch(t.toLowerCase()){case"jwk":o=vr.fromJSON(r,{targetSchema:si});break;case"raw":o=new si,o.data=e.from(r);break;default:throw new Br("format: Must be 'jwk' or 'raw'")}return o.algorithm={hash:{name:n.hash.name},name:this.name,length:o.data.length<<3},o.extractable=s,o.usages=i,ts(o)}async onExportKey(e,t){switch(e.toLowerCase()){case"jwk":return wr.toJSON(es(t));case"raw":return new Uint8Array(es(t).data).buffer;default:throw new Br("format: Must be 'jwk' or 'raw'")}}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof si))throw new TypeError("key: Is not HMAC CryptoKey")}}class oi extends qn{}class ai extends Vn{async onImportKey(t,r,n,s,i){if("raw"!==t.toLowerCase())throw new Br("Operation not supported");const o=new oi;return o.data=e.from(r),o.algorithm={name:this.name},o.extractable=s,o.usages=i,ts(o)}async onDeriveBits(r,n,s){const i=r.hash.name.replace("-",""),a=t.createHash(i).digest().length,c=s/8,u=o.BufferSourceConverter.toUint8Array(r.info),l=t.createHmac(i,o.BufferSourceConverter.toUint8Array(r.salt)).update(o.BufferSourceConverter.toUint8Array(es(n).data)).digest(),h=[e.alloc(0)],y=Math.ceil(c/a)+1;for(let r=1;r<y;++r)h.push(t.createHmac(i,l).update(e.concat([h[r-1],u,e.from([r])])).digest());return e.concat(h).slice(0,c)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(es(e)instanceof oi))throw new TypeError("key: Is not HKDF CryptoKey")}}class ci{static digest(r,n){const s=t.createHash(r.name.toLowerCase(),{outputLength:r.length}).update(e.from(n)).digest();return new Uint8Array(s).buffer}}class ui extends Mn{async onDigest(e,t){return ci.digest(e,t)}}class li extends $n{async onDigest(e,t){return ci.digest(e,t)}}class hi extends Gn{constructor(){var e;super(),this.providers.set(new rs),this.providers.set(new ys),this.providers.set(new fs),this.providers.set(new hs),this.providers.set(new ps),this.providers.set(new gs);t.getCiphers().includes("des-cbc")&&this.providers.set(new ws),this.providers.set(new vs),this.providers.set(new Bs),this.providers.set(new Es),this.providers.set(new Cs),this.providers.set(new xs),this.providers.set(new $s),this.providers.set(new Js),this.providers.set(new Os),this.providers.set(new Hs),this.providers.set(new Ts),this.providers.set(new Ls),this.providers.set(new ni),this.providers.set(new ii),this.providers.set(new ai);const n=null===(e=/^v(\d+)/.exec(r))||void 0===e?void 0:e[1];n&&parseInt(n,10)>=12&&(this.providers.set(new ui),this.providers.set(new li));const s=t.getHashes();s.includes("sha3-256")&&this.providers.set(new Ds),s.includes("sha3-384")&&this.providers.set(new Vs),s.includes("sha3-512")&&this.providers.set(new Rs),n&&parseInt(n,10)>=14&&(this.providers.set(new qs),this.providers.set(new Ws),this.providers.set(new ei),this.providers.set(new ti))}}class yi extends Jn{constructor(){super(...arguments),this.subtle=new hi}getRandomValues(r){if(!ArrayBuffer.isView(r))throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");const n=e.from(r.buffer,r.byteOffset,r.byteLength);return t.randomFillSync(n),r}}export{yi as Crypto,jr as CryptoKey};
