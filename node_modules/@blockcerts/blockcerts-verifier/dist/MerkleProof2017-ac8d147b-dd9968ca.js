import{h as e,j as t,k as i,l as s,m as r,n as o,o as a}from"./main.js";import"./pako.esm-7a9981ef-ce496ef7.js";import{j as n}from"./jsonld-6909fb49-1ef9cd75.js";import{s as c}from"./sha256-71400caa-e7398231.js";import{e as h}from"./ensureValidIssuingKey-b950fb8b-b8fdc4d0.js";import"./index-0469d008-3e0eb763.js";import{S as u}from"./Suite-e65d26ad-9eb797e9.js";function p(e){e=e.trim();const t=[];for(let i=0;i<e.length;i+=2)t.push(parseInt(e.substring(i,i+2),16));return t}function f(e){const t=o(e);return"proof"in t?function(e){const t=o(e);if(!Array.isArray(e.proof))return delete t.proof,t;const i=e.proof.find((e=>"ChainedProof2021"!==e.type));return t.proof=i,t}(t):("signature"in t&&delete t.signature,t)}async function l(e){e["@context"].find((e=>i(e)&&"@vocab"in e))||e["@context"].push({"@vocab":"http://fallback.org/"});const t=f(e),o={algorithm:"URDNA2015",format:"application/nquads",documentLoader:function(e){return e in a?{contextUrl:null,document:a[e],documentUrl:e}:n.documentLoader(e)}};let h;try{h=await n.normalize(t,o)}catch(e){throw console.error(e),new s("computeLocalHash",r("errors","failedJsonLdNormalization"))}const u=function(e){const t=e.split("\n"),i=/<http:\/\/fallback\.org\/(.*)>/,s=t.map((e=>i.exec(e))).filter((e=>null!=e));if(s.length>0){const e=s.map((e=>e[1])).sort();return Array.from(new Set(e))}return null}(h);if(u)throw new s("computeLocalHash",`${r("errors","foundUnmappedFields")}: ${u.join(", ")}`);return c(function(e){const t=[];for(let i=0;i<e.length;i++){let s=e.charCodeAt(i);s<128?t.push(s):s<2048?t.push(192|s>>6,128|63&s):s<55296||s>=57344?t.push(224|s>>12,128|s>>6&63,128|63&s):(i++,s=65536+((1023&s)<<10|1023&e.charCodeAt(i)),t.push(240|s>>18,128|s>>12&63,128|s>>6&63,128|63&s))}return t}(h))}var d;!function(e){e.getTransactionId="getTransactionId",e.computeLocalHash="computeLocalHash",e.fetchRemoteHash="fetchRemoteHash",e.parseIssuerKeys="parseIssuerKeys",e.compareHashes="compareHashes",e.checkMerkleRoot="checkMerkleRoot",e.checkReceipt="checkReceipt",e.checkAuthenticity="checkAuthenticity"}(d||(d={}));class y extends u{verificationProcess=[d.getTransactionId,d.computeLocalHash,d.fetchRemoteHash,d.compareHashes,d.checkMerkleRoot,d.checkReceipt,d.parseIssuerKeys,d.checkAuthenticity];transactionId;localHash;documentToVerify;txData;chain;explorerAPIs;receipt;issuerPublicKeyList;issuer;proof;type="MerkleProof2017";constructor(t){super(t),t.executeStep&&(this.executeStep=t.executeStep),this.documentToVerify=t.document,this.explorerAPIs=t.explorerAPIs,this.issuer=t.issuer,this.proof=t.proof,this.validateProofType(),this.receipt=this.documentToVerify.signature,this.chain=e.certificates.getChain("",this.receipt),this.transactionId=e.certificates.getTransactionId(this.receipt),this.adaptVerificationProcessToChain()}async init(){}async verifyProof(){for(const e of this.verificationProcess){if(!this[e])return void console.error("verification logic for",e,"not implemented");await this[e]()}}async verifyIdentity(){}getProofVerificationSteps(t){return this.verificationProcess.map((i=>e.verifier.convertToVerificationSubsteps(t,i)))}getIdentityVerificationSteps(){return[]}getIssuerPublicKey(){return e.chains.isMockChain(this.chain)?"This mock chain does not support issuing addresses":this.txData?this.txData.issuingAddress:void console.error("Trying to access issuing address when txData not available yet. Did you run the `verify` method yet?")}getIssuerName(){return this.issuer.name}getIssuerProfileDomain(){const e=new URL(this.getIssuerProfileUrl());return e?.hostname}getIssuerProfileUrl(){return this.issuer.id}getSigningDate(){return this.documentToVerify.issuedOn}getChain(){return this.chain}getReceipt(){return this.receipt}getTransactionIdString(){return e.certificates.getTransactionId(this.getReceipt())}getTransactionLink(){return e.certificates.getTransactionLink(this.getTransactionIdString(),this.getChain()).transactionLink}getRawTransactionLink(){return e.certificates.getTransactionLink(this.getTransactionIdString(),this.getChain()).rawTransactionLink}validateProofType(){if(this.proof.type[0]!==this.type)throw new Error(`Incompatible proof type passed. Expected: ${this.type}, Got: ${this.proof.type[0]}`)}adaptVerificationProcessToChain(){e.chains.isMockChain(this.chain)&&(t(this.verificationProcess,d.getTransactionId),t(this.verificationProcess,d.fetchRemoteHash),t(this.verificationProcess,d.parseIssuerKeys),t(this.verificationProcess,d.checkMerkleRoot),t(this.verificationProcess,d.checkAuthenticity))}async executeStep(e,t,i){throw new Error("doAction method needs to be overwritten by injecting from CVJS")}async getTransactionId(){await this.executeStep(d.getTransactionId,(()=>function(e){if("string"==typeof e&&e.length>0)return e;throw new s("getTransactionId",r("errors","isTransactionIdValid"))}(this.transactionId)),this.type)}async computeLocalHash(){this.localHash=await this.executeStep(d.computeLocalHash,(async()=>await l(this.documentToVerify)),this.type)}async fetchRemoteHash(){this.txData=await this.executeStep(d.fetchRemoteHash,(async()=>await e.verifier.lookForTx({transactionId:this.transactionId,chain:this.chain.code,explorerAPIs:this.explorerAPIs})),this.type)}async compareHashes(){await this.executeStep(d.compareHashes,(()=>function(e,t){if(e!==t)throw new s("compareHashes",r("errors","ensureHashesEqual"));return!0}(this.localHash,this.receipt.targetHash)),this.type)}async checkMerkleRoot(){await this.executeStep(d.checkMerkleRoot,(()=>function(e,t){if(e!==t)throw new s("checkMerkleRoot",r("errors","ensureMerkleRootEqual"));return!0}(this.receipt.merkleRoot,this.txData.remoteHash)),this.type)}async checkReceipt(){await this.executeStep(d.checkReceipt,(()=>function(e){let t=e.targetHash;const i=e.merkleRoot;try{const i=e.proof||e.path;if(i)for(const e in i){const r=i[e];let o;if(void 0!==r.left)o=p(`${r.left}${t}`),t=c(o);else{if(void 0===r.right)throw new s("checkReceipt","Trigger catch error.");o=p(`${t}${r.right}`),t=c(o)}}}catch(e){throw new s("checkReceipt",r("errors","ensureValidReceipt"))}if(t!==i)throw new s("checkReceipt",r("errors","invalidMerkleReceipt"))}(this.receipt)),this.type)}async parseIssuerKeys(){this.issuerPublicKeyList=await this.executeStep(d.parseIssuerKeys,(()=>e.verifier.parseIssuerKeys(this.issuer)),this.type)}async checkAuthenticity(){await this.executeStep(d.checkAuthenticity,(()=>h(this.issuerPublicKeyList,this.txData.issuingAddress,this.txData.time)),this.type)}}export{y as default};
