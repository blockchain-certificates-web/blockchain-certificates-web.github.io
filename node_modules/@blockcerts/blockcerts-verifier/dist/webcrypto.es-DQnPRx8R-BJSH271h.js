import{B as e,c as t,H as r}from"./main.js";import{_ as n}from"./tslib.es6-CNEFicEt-CmLYFWVC.js";class s{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=s.toUint8Array(e),n=s.toUint8Array(t);if(r.length!==n.byteLength)return!1;for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0}static concat(...e){let t;t=!Array.isArray(e[0])||e[1]instanceof Function?Array.isArray(e[0])&&e[1]instanceof Function?e[0]:e[e.length-1]instanceof Function?e.slice(0,e.length-1):e:e[0];let r=0;for(const e of t)r+=e.byteLength;const n=new Uint8Array(r);let s=0;for(const e of t){const t=this.toUint8Array(e);n.set(t,s),s+=t.length}return e[e.length-1]instanceof Function?this.toView(n,e[e.length-1]):n.buffer}}const i="string",a=/^[0-9a-f]+$/i,o=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,c=/^[a-zA-Z0-9-_]+$/;class l{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static toString(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return decodeURIComponent(escape(r))}}class u{static toString(e,t=!1){const r=s.toArrayBuffer(e),n=new DataView(r);let i="";for(let e=0;e<r.byteLength;e+=2){const r=n.getUint16(e,t);i+=String.fromCharCode(r)}return i}static fromString(e,t=!1){const r=new ArrayBuffer(2*e.length),n=new DataView(r);for(let r=0;r<e.length;r++)n.setUint16(2*r,e.charCodeAt(r),t);return r}}class h{static isHex(e){return typeof e===i&&a.test(e)}static isBase64(e){return typeof e===i&&o.test(e)}static isBase64Url(e){return typeof e===i&&c.test(e)}static ToString(e,t="utf8"){const r=s.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return u.toString(r,!0);case"utf16":case"utf16be":return u.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return u.fromString(e,!0);case"utf16":case"utf16be":return u.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(t){const r=s.toUint8Array(t);if("undefined"!=typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return e.from(r).toString("base64")}static FromBase64(t){const r=this.formatString(t);if(!r)return new ArrayBuffer(0);if(!h.isBase64(r))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(r)):new Uint8Array(e.from(r,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!h.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=h.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return l.fromString(e);case"utf16":case"utf16be":return u.fromString(e);case"utf16le":case"usc2":return u.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=h.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return l.toString(e);case"utf16":case"utf16be":return u.toString(e);case"utf16le":case"usc2":return u.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToBinary(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=s.toUint8Array(e);let r="";const n=t.length;for(let e=0;e<n;e++){const n=t[e];n<16&&(r+="0"),r+=n.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!h.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const n=t.slice(e,e+2);r[e/2]=parseInt(n,16)}return r.buffer}static ToUtf16String(e,t=!1){return u.toString(e,t)}static FromUtf16String(e,t=!1){return u.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}h.DEFAULT_UTF8_ENCODING="utf8";var y=s,f=h,p=function(...e){const t=e.map((e=>e.byteLength)).reduce(((e,t)=>e+t)),r=new Uint8Array(t);let n=0;return e.map((e=>new Uint8Array(e))).forEach((e=>{for(const t of e)r[n++]=t})),r.buffer};
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function g(e,t){let r=0;if(1===e.length)return e[0];for(let n=e.length-1;n>=0;n--)r+=e[e.length-1-n]*Math.pow(2,t*n);return r}function m(e,t,r=-1){const n=r;let s=e,i=0,a=Math.pow(2,t);for(let r=1;r<8;r++){if(e<a){let e;if(n<0)e=new ArrayBuffer(r),i=r;else{if(n<r)return new ArrayBuffer(0);e=new ArrayBuffer(n),i=n}const a=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);a[i-e-1]=Math.floor(s/r),s-=a[i-e-1]*r}return e}a*=Math.pow(2,t)}return new ArrayBuffer(0)}function d(...e){let t=0,r=0;for(const r of e)t+=r.length;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const t of e)s.set(t,r),r+=t.length;return s}function w(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&!(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const n=g(r,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];i[0]&=127;return g(i,8)-n}function v(e,t){const r=e.toString(10);if(t<r.length)return"";const n=t-r.length,s=new Array(n);for(let e=0;e<n;e++)s[e]="0";return s.join("").concat(r)}
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function A(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function b(e){let t=0,r=0;for(let r=0;r<e.length;r++){t+=e[r].byteLength}const n=new Uint8Array(t);for(let t=0;t<e.length;t++){const s=e[t];n.set(new Uint8Array(s),r),r+=s.byteLength}return n.buffer}function k(e,t,r,n){return t instanceof Uint8Array?t.byteLength?r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):n<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-n<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class S{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return b(this.items)}}const B=[new Uint8Array([1])],E="0123456789",K="name",x="valueHexView",C="",N=new ArrayBuffer(0),U=new Uint8Array(0),P="EndOfContent",I="OCTET STRING",O="BIT STRING";function H(e){var t;return(t=class extends e{constructor(...e){var t;super(...e);const r=e[0]||{};this.isHexOnly=null!==(t=r.isHexOnly)&&void 0!==t&&t,this.valueHexView=r.valueHex?y.toUint8Array(r.valueHex):U}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}fromBER(e,t,r){const n=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!k(this,n,t,r))return-1;const s=t+r;return this.valueHexView=n.subarray(t,s),this.valueHexView.length?(this.blockLength=r,s):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",N)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:f.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class T{constructor({blockLength:e=0,error:t="",warnings:r=[],valueBeforeDecode:n=U}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=y.toUint8Array(n)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:f.ToHex(this.valueBeforeDecodeView)}}}T.NAME="baseBlock";class L extends T{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}L.NAME="valueBlock";class D extends(H(T)){constructor({idBlock:e={}}={}){var t,r,n,s;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?y.toUint8Array(e.valueHex):U,this.tagClass=null!==(r=e.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(n=e.tagNumber)&&void 0!==n?n:-1,this.isConstructed=null!==(s=e.isConstructed)&&void 0!==s&&s):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",N}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,r[0]=t}return r.buffer}if(!this.isHexOnly){const r=m(this.tagNumber,7),n=new Uint8Array(r),s=r.byteLength,i=new Uint8Array(s+1);if(i[0]=31|t,!e){for(let e=0;e<s-1;e++)i[e+1]=128|n[e];i[s]=n[s-1]}return i.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHexView.byteLength]=e[e.length-1]}return r.buffer}fromBER(e,t,r){const n=y.toUint8Array(e);if(!k(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;switch(192&s[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=!(32&~s[0]),this.isHexOnly=!1;const i=31&s[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),r=255;for(;128&s[e];){if(t[e-1]=127&s[e],e++,e>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(e===r){r+=255;const e=new Uint8Array(r);for(let r=0;r<t.length;r++)e[r]=t[r];t=this.valueHexView=new Uint8Array(r)}}this.blockLength=e+1,t[e-1]=127&s[e];const n=new Uint8Array(e);for(let r=0;r<e;r++)n[r]=t[r];t=this.valueHexView=new Uint8Array(e),t.set(n),this.blockLength<=9?this.tagNumber=g(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}D.NAME="identificationBlock";class V extends T{constructor({lenBlock:e={}}={}){var t,r,n;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(r=e.longFormUsed)&&void 0!==r&&r,this.length=null!==(n=e.length)&&void 0!==n?n:0}fromBER(e,t,r){const n=y.toUint8Array(e);if(!k(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,t+this.blockLength;const i=127&s[0];if(i>8)return this.error="Too big integer",-1;if(i+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,o=n.subarray(a,a+i);return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=g(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const n=m(this.length,8);if(n.byteLength>127)return this.error="Too big length",N;if(t=new ArrayBuffer(n.byteLength+1),e)return t;const s=new Uint8Array(n);r=new Uint8Array(t),r[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}V.NAME="lengthBlock";const R={};class M extends T{constructor({name:e="",optional:t=!1,primitiveSchema:r,...n}={},s){super(n),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new D(n),this.lenBlock=new V(n),this.valueBlock=s?new s(n):new L(n)}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}toBER(e,t){const r=t||new S;t||$(this);const n=this.idBlock.toBER(e);if(r.write(n),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const n=this.lenBlock.toBER(e);r.write(n),r.write(t)}return t?N:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():f.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${f.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;return function(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0}(this.toBER(),e.toBER())}}function $(e){if(e instanceof R.Constructed)for(const t of e.valueBlock.value)$(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!e.lenBlock.isIndefiniteForm}M.NAME="BaseBlock";class J extends M{constructor({value:e="",...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}J.NAME="BaseStringBlock";class j extends(H(L)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var z,F,G,_,q,W;j.NAME="PrimitiveValueBlock";class Y extends M{constructor(e={}){super(e,j),this.idBlock.isConstructed=!1}}function X(e,t=0,r=e.length){const n=t;let s=new M({},L);const i=new T;if(!k(i,e,t,r))return s.error=i.error,{offset:-1,result:s};if(!e.subarray(t,t+r).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(e,t,r);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),-1===a)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,r-=s.idBlock.blockLength,a=s.lenBlock.fromBER(e,t,r),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),-1===a)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,r-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let o=M;if(1===s.idBlock.tagClass){if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};o=R.EndOfContent;break;case 1:o=R.Boolean;break;case 2:o=R.Integer;break;case 3:o=R.BitString;break;case 4:o=R.OctetString;break;case 5:o=R.Null;break;case 6:o=R.ObjectIdentifier;break;case 10:o=R.Enumerated;break;case 12:o=R.Utf8String;break;case 13:o=R.RelativeObjectIdentifier;break;case 14:o=R.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:o=R.Sequence;break;case 17:o=R.Set;break;case 18:o=R.NumericString;break;case 19:o=R.PrintableString;break;case 20:o=R.TeletexString;break;case 21:o=R.VideotexString;break;case 22:o=R.IA5String;break;case 23:o=R.UTCTime;break;case 24:o=R.GeneralizedTime;break;case 25:o=R.GraphicString;break;case 26:o=R.VisibleString;break;case 27:o=R.GeneralString;break;case 28:o=R.UniversalString;break;case 29:o=R.CharacterString;break;case 30:o=R.BmpString;break;case 31:o=R.DATE;break;case 32:o=R.TimeOfDay;break;case 33:o=R.DateTime;break;case 34:o=R.Duration;break;default:{const e=s.idBlock.isConstructed?new R.Constructed:new R.Primitive;e.idBlock=s.idBlock,e.lenBlock=s.lenBlock,e.warnings=s.warnings,s=e}}}else o=s.idBlock.isConstructed?R.Constructed:R.Primitive;return s=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecodeView=e.valueBeforeDecodeView,r}(s,o),a=s.fromBER(e,t,s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecodeView=e.subarray(n,n+s.blockLength),{offset:a,result:s}}function Z(e){if(!e.byteLength){const e=new M({},L);return e.error="Input buffer has zero length",{offset:-1,result:e}}return X(y.toUint8Array(e).slice(),0,e.byteLength)}z=Y,R.Primitive=z,Y.NAME="PRIMITIVE";class Q extends L{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const n=y.toUint8Array(e);if(!k(this,n,t,r))return-1;if(this.valueBeforeDecodeView=n.subarray(t,t+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let s=t;for(;i=this.isIndefiniteForm,a=r,(i?1:a)>0;){const e=X(n,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===P)break}var i,a;return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===P?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const r=t||new S;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,r);return t?N:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}Q.NAME="ConstructedValueBlock";class ee extends M{constructor(e={}){super(e,Q),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map((e=>`  ${e}`)).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}F=ee,R.Constructed=F,ee.NAME="CONSTRUCTED";class te extends L{fromBER(e,t,r){return t}toBER(e){return N}}te.override="EndOfContentValueBlock";class re extends M{constructor(e={}){super(e,te),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}G=re,R.EndOfContent=G,re.NAME=P;class ne extends M{constructor(e={}){super(e,L),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const e=new Uint8Array(r);e[0]=5,e[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}_=ne,R.Null=_,ne.NAME="NULL";class se extends(H(L)){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=y.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const n=y.toUint8Array(e);return k(this,n,t,r)?(this.valueHexView=n.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,w.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}se.NAME="BooleanValueBlock";class ie extends M{constructor(e={}){super(e,se),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}q=ie,R.Boolean=q,ie.NAME="BOOLEAN";class ae extends(H(Q)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let n=0;if(this.isConstructed){if(this.isHexOnly=!1,n=Q.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===P){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==I)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(e,t,r),this.blockLength=r;return n}toBER(e,t){return this.isConstructed?Q.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}ae.NAME="OctetStringValueBlock";let oe=class e extends M{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},ae),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const n=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(n.byteLength){const e=X(n,0,n.byteLength);-1!==e.offset&&e.offset===r&&(this.valueBlock.value=[e.result])}}catch(e){}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?ee.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${f.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const t=[];for(const r of this.valueBlock.value)r instanceof e&&t.push(r.valueBlock.valueHexView);return y.concat(t)}};W=oe,R.OctetString=W,oe.NAME=I;class ce extends(H(Q)){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let n=-1;if(this.isConstructed){if(n=Q.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(const e of this.value){const t=e.constructor.NAME;if(t===P){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==O)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=e.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return n}const s=y.toUint8Array(e);if(!k(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=X(e,0,e.byteLength);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}}catch(e){}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+r}toBER(e,t){if(this.isConstructed)return Q.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return N;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}var le;ce.NAME="BitStringValueBlock";let ue=class extends M{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},ce),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return ee.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const r of t)e.push(r.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}};var he,ye,fe,pe;function ge(e,t){const r=new Uint8Array([0]),n=new Uint8Array(e),s=new Uint8Array(t);let i=n.slice(0);const a=i.length-1,o=s.slice(0),c=o.length-1;let l=0;let u=0;for(let e=c<a?a:c;e>=0;e--,u++){if(!0==u<o.length)l=i[a-u]+o[c-u]+r[0];else l=i[a-u]+r[0];if(r[0]=l/10,!0==u>=i.length)i=d(new Uint8Array([l%10]),i);else i[a-u]=l%10}return r[0]>0&&(i=d(r,i)),i}function me(e){if(e>=B.length)for(let t=B.length;t<=e;t++){const e=new Uint8Array([0]);let r=B[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const n=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=n[0]/10,r[t]=n[0]%10}e[0]>0&&(r=d(e,r)),B.push(r)}return B[e]}function de(e,t){let r=0;const n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0),a=i.length-1,o=s.slice(0),c=o.length-1;let l,u=0;for(let e=c;e>=0;e--,u++)if(l=i[a-u]-o[c-u]-r,!0==l<0)r=1,i[a-u]=l+10;else r=0,i[a-u]=l;if(r>0)for(let e=a-c+1;e>=0;e--,u++){if(l=i[a-u]-r,!(l<0)){r=0,i[a-u]=l;break}r=1,i[a-u]=l+10}return i.slice()}le=ue,R.BitString=le,ue.NAME=O;class we extends(H(L)){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=w.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(e){const t=e<0?-1*e:e;let r=128;for(let n=1;n<8;n++){if(t<=r){if(e<0){const e=m(r-t,8,n);return new Uint8Array(e)[0]|=128,e}let s=m(t,8,n),i=new Uint8Array(s);if(128&i[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,n=0){const s=this.fromBER(e,t,r);if(-1===s)return s;const i=this.valueHexView;return 0===i[0]&&128&i[1]?this.valueHexView=i.subarray(1):0!==n&&i.length<n&&(n-i.length>1&&(n=i.length+1),this.valueHexView=i.subarray(n-i.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case!!(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&!(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,r){const n=super.fromBER(e,t,r);return-1===n||this.setValueHex(),n}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,r=new Uint8Array(8*this.valueHexView.length/3),n=0;const s=this.valueHexView;let i="",a=!1;for(let a=s.byteLength-1;a>=0;a--){t=s[a];for(let s=0;s<8;s++){if(!(1&~t))if(n===e)r=de(me(n),r),i="-";else r=ge(r,me(n));n++,t>>=1}}for(let e=0;e<r.length;e++)r[e]&&(a=!0),a&&(i+=E.charAt(r[e]));return!1===a&&(i+=E.charAt(0)),i}}he=we,we.NAME="IntegerValueBlock",Object.defineProperty(he.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class ve extends M{constructor(e={}){super(e,we),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return A(),BigInt(this.valueBlock.toString())}static fromBigInt(e){A();const t=BigInt(e),r=new S,n=t.toString(16).replace(/^-/,""),s=new Uint8Array(f.FromHex(n));if(t<0){const e=new Uint8Array(s.length+(128&s[0]?1:0));e[0]|=128;const n=BigInt(`0x${f.ToHex(e)}`)+t,i=y.toUint8Array(f.FromHex(n.toString(16)));i[0]|=128,r.write(i)}else 128&s[0]&&r.write(new Uint8Array([0])),r.write(s);return new ve({valueHex:r.final()})}convertToDER(){const e=new ve({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new ve({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}ye=ve,R.Integer=ye,ve.NAME="INTEGER";class Ae extends ve{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}fe=Ae,R.Enumerated=fe,Ae.NAME="ENUMERATED";class be extends(H(L)){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const n=y.toUint8Array(e);if(!k(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=g(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){A();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let e=0;e<r.length;e++)r[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=m(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",N;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r}toString(){let e="";if(this.isHexOnly)e=f.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}be.NAME="sidBlock";class ke extends L{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new be;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,N;t.push(n)}return b(t)}fromString(e){this.value=[];let t=0,r=0,n="",s=!1;do{if(r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const r=parseInt(n,10);if(isNaN(r))return;e.valueDec=r+t,s=!1}else{const e=new be;if(n>Number.MAX_SAFE_INTEGER){A();const t=BigInt(n);e.valueBigInt=t}else if(e.valueDec=parseInt(n,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==r)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,this.value[r].isFirstSid?e=`2.{${n} - 80}`:e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}ke.NAME="ObjectIdentifierValueBlock";let Se=class extends M{constructor(e={}){super(e,ke),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};pe=Se,R.ObjectIdentifier=pe,Se.NAME="OBJECT IDENTIFIER";class Be extends(H(T)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(0===r)return t;const n=y.toUint8Array(e);if(!k(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=g(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=m(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",N;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r.buffer}toString(){let e="";return e=this.isHexOnly?f.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Be.NAME="relativeSidBlock";class Ee extends L{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new Be;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e,t){const r=[];for(let t=0;t<this.value.length;t++){const n=this.value[t].toBER(e);if(0===n.byteLength)return this.error=this.value[t].error,N;r.push(n)}return b(r)}fromString(e){this.value=[];let t=0,r=0,n="";do{r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1;const s=new Be;if(s.valueDec=parseInt(n,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}var Ke,xe,Ce,Ne,Ue,Pe,Ie,Oe,He,Te,Le,De,Ve,Re,Me,$e,Je,je,ze,Fe,Ge,_e;Ee.NAME="RelativeObjectIdentifierValueBlock";class qe extends M{constructor(e={}){super(e,Ee),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Ke=qe,R.RelativeObjectIdentifier=Ke,qe.NAME="RelativeObjectIdentifier";class We extends ee{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}xe=We,R.Sequence=xe,We.NAME="SEQUENCE";class Ye extends ee{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}Ce=Ye,R.Set=Ce,Ye.NAME="SET";class Xe extends(H(L)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=C}toJSON(){return{...super.toJSON(),value:this.value}}}Xe.NAME="StringValueBlock";class Ze extends Xe{}Ze.NAME="SimpleStringValueBlock";class Qe extends J{constructor({...e}={}){super(e,Ze)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,y.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);this.valueBlock.value=e}}Qe.NAME="SIMPLE STRING";class et extends Qe{fromBuffer(e){this.valueBlock.valueHexView=y.toUint8Array(e);try{this.valueBlock.value=f.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=f.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(f.FromUtf8String(e)),this.valueBlock.value=e}}et.NAME="Utf8StringValueBlock";class tt extends et{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}Ne=tt,R.Utf8String=Ne,tt.NAME="UTF8String";class rt extends Qe{fromBuffer(e){this.valueBlock.value=f.ToUtf16String(e),this.valueBlock.valueHexView=y.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(f.FromUtf16String(e))}}rt.NAME="BmpStringValueBlock";class nt extends rt{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}Ue=nt,R.BmpString=Ue,nt.NAME="BMPString";class st extends Qe{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let n=0;n<t;n++){const t=m(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>4)continue;const i=4-s.length;for(let e=s.length-1;e>=0;e--)r[4*n+e+i]=s[e]}this.valueBlock.value=e}}st.NAME="UniversalStringValueBlock";class it extends st{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}Pe=it,R.UniversalString=Pe,it.NAME="UniversalString";class at extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}Ie=at,R.NumericString=Ie,at.NAME="NumericString";class ot extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Oe=ot,R.PrintableString=Oe,ot.NAME="PrintableString";class ct extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}He=ct,R.TeletexString=He,ct.NAME="TeletexString";class lt extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}Te=lt,R.VideotexString=Te,lt.NAME="VideotexString";class ut extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Le=ut,R.IA5String=Le,ut.NAME="IA5String";class ht extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}De=ht,R.GraphicString=De,ht.NAME="GraphicString";class yt extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Ve=yt,R.VisibleString=Ve,yt.NAME="VisibleString";class ft extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}Re=ft,R.GeneralString=Re,ft.NAME="GeneralString";class pt extends Qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Me=pt,R.CharacterString=Me,pt.NAME="CharacterString";class gt extends yt{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,y.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=v(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=v(this.month,2),e[2]=v(this.day,2),e[3]=v(this.hour,2),e[4]=v(this.minute,2),e[5]=v(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}$e=gt,R.UTCTime=$e,gt.NAME="UTCTime";class mt extends gt{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,n="",s="",i=0,a=0,o=0;if("Z"===e[e.length-1])n=e.substring(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=n.indexOf("+"),r="";if(-1===t&&(t=n.indexOf("-"),e=-1),-1!==t){if(r=n.substring(t+1),n=n.substring(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let s=parseInt(r.substring(0,2),10);if(isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");if(a=e*s,4===r.length){if(s=parseInt(r.substring(2,4),10),isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");o=e*s}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const e=new Number(`0${n.substring(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");i=e.valueOf(),s=n.substring(0,c)}else s=n;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for conversion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const l=t.exec(s);if(null===l)throw new Error("Wrong input string for conversion");for(let e=1;e<l.length;e++)switch(e){case 1:this.year=parseInt(l[e],10);break;case 2:this.month=parseInt(l[e],10);break;case 3:this.day=parseInt(l[e],10);break;case 4:this.hour=parseInt(l[e],10)+a;break;case 5:this.minute=parseInt(l[e],10)+o;break;case 6:this.second=parseInt(l[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(v(this.year,4)),e.push(v(this.month,2)),e.push(v(this.day,2)),e.push(v(this.hour,2)),e.push(v(this.minute,2)),e.push(v(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(v(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}Je=mt,R.GeneralizedTime=Je,mt.NAME="GeneralizedTime";class dt extends tt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}je=dt,R.DATE=je,dt.NAME="DATE";class wt extends tt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}ze=wt,R.TimeOfDay=ze,wt.NAME="TimeOfDay";class vt extends tt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}Fe=vt,R.DateTime=Fe,vt.NAME="DateTime";class At extends tt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Ge=At,R.Duration=Ge,At.NAME="Duration";class bt extends tt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}_e=bt,R.TIME=_e,bt.NAME="TIME";class kt{constructor({name:e="",optional:t=!1}={}){this.name=e,this.optional=t}}class St extends kt{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Bt extends kt{constructor({value:e=new kt,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}function Et(e,t,r){if(r instanceof St){for(let n=0;n<r.value.length;n++){if(Et(e,t,r.value[n]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty(K)&&(e.name=r.name),e}}if(r instanceof kt)return r.hasOwnProperty(K)&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if(!("isHexOnly"in r.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(r.idBlock.isHexOnly){if(x in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.valueHexView,s=t.idBlock.valueHexView;if(n.length!==s.length)return{verified:!1,result:e};for(let t=0;t<n.length;t++)if(n[t]!==s[1])return{verified:!1,result:e}}if(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&(e[r.name]=t)),r instanceof R.Constructed){let n=0,s={verified:!1,result:{error:"Unknown error"}},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof Bt&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return t?{verified:!0,result:e}:(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let a=0;a<i;a++)if(a-n>=t.valueBlock.value.length){if(!1===r.valueBlock.value[a].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof Bt){if(s=Et(e,t.valueBlock.value[a],r.valueBlock.value[0].value),!1===s.verified){if(!r.valueBlock.value[0].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&delete e[r.name]),s;n++}if(K in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};n="local"in r.valueBlock.value[0]&&r.valueBlock.value[0].local?t:e,void 0===n[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(t.valueBlock.value[a])}}else if(s=Et(e,t.valueBlock.value[a-n],r.valueBlock.value[a]),!1===s.verified){if(!r.valueBlock.value[a].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&delete e[r.name]),s;n++}if(!1===s.verified){const t={verified:!1,result:e};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if(r.primitiveSchema&&x in t.valueBlock){const n=X(t.valueBlock.valueHexView);if(-1===n.offset){const t={verified:!1,result:n.result};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,C),r.name&&(delete e[r.name],t.name=r.name)),t}return Et(e,n.result,r.primitiveSchema)}return{verified:!0,result:e}}var Kt,xt,Ct=Object.freeze({__proto__:null,Any:kt,BaseBlock:M,BaseStringBlock:J,BitString:ue,BmpString:nt,Boolean:ie,CharacterString:pt,Choice:St,Constructed:ee,DATE:dt,DateTime:vt,Duration:At,EndOfContent:re,Enumerated:Ae,GeneralString:ft,GeneralizedTime:mt,GraphicString:ht,HexBlock:H,IA5String:ut,Integer:ve,Null:ne,NumericString:at,ObjectIdentifier:Se,OctetString:oe,Primitive:Y,PrintableString:ot,RawData:class{constructor({data:e=U}={}){this.dataView=y.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=y.toUint8Array(e)}fromBER(e,t,r){const n=t+r;return this.dataView=y.toUint8Array(e).subarray(t,n),n}toBER(e){return this.dataView.slice().buffer}},RelativeObjectIdentifier:qe,Repeated:Bt,Sequence:We,Set:Ye,TIME:bt,TeletexString:ct,TimeOfDay:wt,UTCTime:gt,UniversalString:it,Utf8String:tt,ValueBlock:L,VideotexString:lt,ViewWriter:S,VisibleString:yt,compareSchema:Et,fromBER:Z,verifySchema:function(e,t){if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=X(y.toUint8Array(e));return-1===r.offset?{verified:!1,result:r.result}:Et(r.result,r.result,t)}});!function(e){e[e.Sequence=0]="Sequence",e[e.Set=1]="Set",e[e.Choice=2]="Choice"}(Kt||(Kt={})),function(e){e[e.Any=1]="Any",e[e.Boolean=2]="Boolean",e[e.OctetString=3]="OctetString",e[e.BitString=4]="BitString",e[e.Integer=5]="Integer",e[e.Enumerated=6]="Enumerated",e[e.ObjectIdentifier=7]="ObjectIdentifier",e[e.Utf8String=8]="Utf8String",e[e.BmpString=9]="BmpString",e[e.UniversalString=10]="UniversalString",e[e.NumericString=11]="NumericString",e[e.PrintableString=12]="PrintableString",e[e.TeletexString=13]="TeletexString",e[e.VideotexString=14]="VideotexString",e[e.IA5String=15]="IA5String",e[e.GraphicString=16]="GraphicString",e[e.VisibleString=17]="VisibleString",e[e.GeneralString=18]="GeneralString",e[e.CharacterString=19]="CharacterString",e[e.UTCTime=20]="UTCTime",e[e.GeneralizedTime=21]="GeneralizedTime",e[e.DATE=22]="DATE",e[e.TimeOfDay=23]="TimeOfDay",e[e.DateTime=24]="DateTime",e[e.Duration=25]="Duration",e[e.TIME=26]="TIME",e[e.Null=27]="Null"}(xt||(xt={}));const Nt={fromASN:e=>e instanceof ne?null:e.valueBeforeDecodeView,toASN:e=>{if(null===e)return new ne;const t=Z(e);if(t.result.error)throw new Error(t.result.error);return t.result}},Ut={fromASN:e=>e.valueBlock.valueHexView.byteLength>=4?e.valueBlock.toString():e.valueBlock.valueDec,toASN:e=>new ve({value:+e})},Pt={fromASN:e=>e.valueBlock.valueDec,toASN:e=>new Ae({value:e})},It={fromASN:e=>e.valueBlock.valueHexView,toASN:e=>new ue({valueHex:e})},Ot={fromASN:e=>e.valueBlock.toString(),toASN:e=>new Se({value:e})},Ht={fromASN:e=>e.valueBlock.value,toASN:e=>new ie({value:e})},Tt={fromASN:e=>e.valueBlock.valueHexView,toASN:e=>new oe({valueHex:e})};function Lt(e){return{fromASN:e=>e.valueBlock.value,toASN:t=>new e({value:t})}}const Dt=Lt(tt),Vt=Lt(nt),Rt=Lt(it),Mt=Lt(at),$t=Lt(ot),Jt=Lt(ct),jt=Lt(lt),zt=Lt(ut),Ft=Lt(ht),Gt=Lt(yt),_t=Lt(ft),qt=Lt(pt),Wt={fromASN:e=>e.toDate(),toASN:e=>new gt({valueDate:e})},Yt={fromASN:e=>e.toDate(),toASN:e=>new mt({valueDate:e})},Xt={fromASN:()=>null,toASN:()=>new ne};function Zt(e){switch(e){case xt.Any:return Nt;case xt.BitString:return It;case xt.BmpString:return Vt;case xt.Boolean:return Ht;case xt.CharacterString:return qt;case xt.Enumerated:return Pt;case xt.GeneralString:return _t;case xt.GeneralizedTime:return Yt;case xt.GraphicString:return Ft;case xt.IA5String:return zt;case xt.Integer:return Ut;case xt.Null:return Xt;case xt.NumericString:return Mt;case xt.ObjectIdentifier:return Ot;case xt.OctetString:return Tt;case xt.PrintableString:return $t;case xt.TeletexString:return Jt;case xt.UTCTime:return Wt;case xt.UniversalString:return Rt;case xt.Utf8String:return Dt;case xt.VideotexString:return jt;case xt.VisibleString:return Gt;default:return null}}function Qt(e){return"function"==typeof e&&e.prototype?!(!e.prototype.toASN||!e.prototype.fromASN)||Qt(e.prototype):!!(e&&"object"==typeof e&&"toASN"in e&&"fromASN"in e)}function er(e){var t;if(e){const r=Object.getPrototypeOf(e);return(null===(t=null==r?void 0:r.prototype)||void 0===t?void 0:t.constructor)===Array||er(r)}return!1}function tr(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let t=0;t<e.byteLength;t++)if(r[t]!==n[t])return!1;return!0}const rr=new class{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const r=this.items.get(e);if(!r)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!r.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return r}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:Kt.Sequence,items:{}},r=this.findParentSchema(e);return r&&(Object.assign(t,r),t.items=Object.assign({},t.items,r.items)),t}create(e,t){const r=this.items.get(e)||this.createDefault(e),n=[];for(const e in r.items){const s=r.items[e],i=t?e:"";let a;if("number"==typeof s.type){const e=xt[s.type],t=Ct[e];if(!t)throw new Error(`Cannot get ASN1 class by name '${e}'`);a=new t({name:i})}else if(Qt(s.type)){a=(new s.type).toSchema(i)}else if(s.optional){this.get(s.type).type===Kt.Choice?a=new kt({name:i}):(a=this.create(s.type,!1),a.name=i)}else a=new kt({name:i});const o=!!s.optional||void 0!==s.defaultValue;if(s.repeated){a.name="";a=new("set"===s.repeated?Ye:We)({name:"",value:[new Bt({name:i,value:a})]})}if(null!==s.context&&void 0!==s.context)if(s.implicit)if("number"==typeof s.type||Qt(s.type)){const e=s.repeated?ee:Y;n.push(new e({name:i,optional:o,idBlock:{tagClass:3,tagNumber:s.context}}))}else{this.cache(s.type);const e=!!s.repeated;let t=e?a:this.get(s.type,!0).schema;t="valueBlock"in t?t.valueBlock.value:t.value,n.push(new ee({name:e?"":i,optional:o,idBlock:{tagClass:3,tagNumber:s.context},value:t}))}else n.push(new ee({optional:o,idBlock:{tagClass:3,tagNumber:s.context},value:[a]}));else a.optional=o,n.push(a)}switch(r.type){case Kt.Sequence:return new We({value:n,name:""});case Kt.Set:return new Ye({value:n,name:""});case Kt.Choice:return new St({value:n,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);if(t){return this.items.get(t)||this.findParentSchema(t)}return null}},nr=e=>t=>{let r;rr.has(t)?r=rr.get(t):(r=rr.createDefault(t),rr.set(t,r)),Object.assign(r,e)},sr=e=>(t,r)=>{let n;rr.has(t.constructor)?n=rr.get(t.constructor):(n=rr.createDefault(t.constructor),rr.set(t.constructor,n));const s=Object.assign({},e);if("number"==typeof s.type&&!s.converter){const n=Zt(e.type);if(!n)throw new Error(`Cannot get default converter for property '${r}' of ${t.constructor.name}`);s.converter=n}n.items[r]=s};class ir extends Error{constructor(){super(...arguments),this.schemas=[]}}class ar{static parse(e,t){const r=Z(e);if(r.result.error)throw new Error(r.result.error);return this.fromASN(r.result,t)}static fromASN(e,t){var r;try{if(Qt(t)){return(new t).fromASN(e)}const n=rr.get(t);rr.cache(t);let s=n.schema;if(e.constructor===ee&&n.type!==Kt.Choice){s=new ee({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:n.schema.valueBlock.value});for(const t in n.items)delete e[t]}const i=Et({},e,s);if(!i.verified)throw new ir(`Data does not match to ${t.name} ASN1 schema. ${i.result.error}`);const a=new t;if(er(t)){if(!("value"in e.valueBlock)||!Array.isArray(e.valueBlock.value))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const r=n.itemType;if("number"==typeof r){const n=Zt(r);if(!n)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,(e=>n.fromASN(e)))}return t.from(e.valueBlock.value,(e=>this.fromASN(e,r)))}for(const e in n.items){const t=i.result[e];if(!t)continue;const s=n.items[e],o=s.type;if("number"==typeof o||Qt(o)){const n=null!==(r=s.converter)&&void 0!==r?r:Qt(o)?new o:null;if(!n)throw new Error("Converter is empty");if(s.repeated)if(s.implicit){const r=new("sequence"===s.repeated?We:Ye);r.valueBlock=t.valueBlock;const i=Z(r.toBER(!1));if(-1===i.offset)throw new Error(`Cannot parse the child item. ${i.result.error}`);if(!("value"in i.result.valueBlock)||!Array.isArray(i.result.valueBlock.value))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const o=i.result.valueBlock.value;a[e]=Array.from(o,(e=>n.fromASN(e)))}else a[e]=Array.from(t,(e=>n.fromASN(e)));else{let r=t;if(s.implicit){let e;if(Qt(o))e=(new o).toSchema("");else{const t=xt[o],r=Ct[t];if(!r)throw new Error(`Cannot get '${t}' class from asn1js module`);e=new r}e.valueBlock=r.valueBlock,r=Z(e.toBER(!1)).result}a[e]=n.fromASN(r)}}else if(s.repeated){if(!Array.isArray(t))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[e]=Array.from(t,(e=>this.fromASN(e,o)))}else a[e]=this.fromASN(t,o)}return a}catch(e){throw e instanceof ir&&e.schemas.push(t.name),e}}}class or{static serialize(e){return e instanceof M?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&"object"==typeof e&&Qt(e))return e.toASN();if(!e||"object"!=typeof e)throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,r=rr.get(t);rr.cache(t);let n,s=[];if(r.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if("number"==typeof r.itemType){const n=Zt(r.itemType);if(!n)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);s=e.map((e=>n.toASN(e)))}else s=e.map((e=>this.toAsnItem({type:r.itemType},"[]",t,e)))}else for(const n in r.items){const i=r.items[n],a=e[n];if(void 0===a||i.defaultValue===a||"object"==typeof i.defaultValue&&"object"==typeof a&&tr(this.serialize(i.defaultValue),this.serialize(a)))continue;const o=or.toAsnItem(i,n,t,a);if("number"==typeof i.context)if(i.implicit)if(i.repeated||"number"!=typeof i.type&&!Qt(i.type))s.push(new ee({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:o.valueBlock.value}));else{const e={};e.valueHex=o instanceof ne?o.valueBeforeDecodeView:o.valueBlock.toBER(),s.push(new Y({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},...e}))}else s.push(new ee({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[o]}));else i.repeated?s=s.concat(o):s.push(o)}switch(r.type){case Kt.Sequence:n=new We({value:s});break;case Kt.Set:n=new Ye({value:s});break;case Kt.Choice:if(!s[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);n=s[0]}return n}static toAsnItem(e,t,r,n){let s;if("number"==typeof e.type){const i=e.converter;if(!i)throw new Error(`Property '${t}' doesn't have converter for type ${xt[e.type]} in schema '${r.name}'`);if(e.repeated){if(!Array.isArray(n))throw new TypeError("Parameter 'objProp' should be type of Array.");const t=Array.from(n,(e=>i.toASN(e)));s=new("sequence"===e.repeated?We:Ye)({value:t})}else s=i.toASN(n)}else if(e.repeated){if(!Array.isArray(n))throw new TypeError("Parameter 'objProp' should be type of Array.");const t=Array.from(n,(e=>this.toASN(e)));s=new("sequence"===e.repeated?We:Ye)({value:t})}else s=this.toASN(n);return s}}class cr{static serialize(e){return or.serialize(e)}static parse(e,t){return ar.parse(e,t)}static toString(e){const t=Z(y.isBufferSource(e)?y.toArrayBuffer(e):cr.serialize(e));if(-1===t.offset)throw new Error(`Cannot decode ASN.1 data. ${t.result.error}`);return t.result.toString()}}class lr extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class ur extends lr{constructor(e,t,r){super(t,r),this.schema=e}}class hr extends ur{constructor(e,t,r){super(e,`JSON doesn't match to '${e.target.name}' schema. ${t}`,r)}}class yr extends lr{}class fr extends lr{constructor(e,t,r){super(`Cannot serialize by '${e}' schema. ${t}`,r),this.schemaName=e}}class pr extends hr{constructor(e,t,r={}){super(e,"Some keys doesn't match to schema"),this.keys=t,this.errors=r}}var gr;function mr(e,t){if(!function(e,t){switch(t){case gr.Boolean:return"boolean"==typeof e;case gr.Number:return"number"==typeof e;case gr.String:return"string"==typeof e}return!0}(e,t))throw new TypeError(`Value must be ${gr[t]}`)}function dr(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||dr(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}!function(e){e[e.Any=0]="Any",e[e.Boolean=1]="Boolean",e[e.Number=2]="Number",e[e.String=3]="String"}(gr||(gr={}));const wr="default",vr=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const e in r.names)t.names[e]=Object.assign({},r.names[e])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;if(t){return this.items.get(t)||this.findParentSchema(t)}return null}};class Ar{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof e)throw new yr("Incoming value must be string");if(!t.exec(e))throw new yr(`Value doesn't match to pattern '${t.toString()}'`)}}class br{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(mr(e,gr.Number),!(this.min<=e&&e<=this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new yr(`Value doesn't match to diapason [${e},${t}]`)}}}class kr{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(mr(e,gr.Number),!(this.min<e&&e<this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new yr(`Value doesn't match to diapason (${e},${t})`)}}}class Sr{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(void 0===this.length){if(void 0!==this.minLength&&e.length<this.minLength)throw new yr(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&e.length>this.maxLength)throw new yr(`Value length must be less than ${this.maxLength}.`)}else if(e.length!==this.length)throw new yr(`Value length must be exactly ${this.length}.`)}}class Br{constructor(e){this.enumeration=e}validate(e){if(mr(e,gr.String),!this.enumeration.includes(e))throw new yr(`Value must be one of ${this.enumeration.map((e=>`'${e}'`)).join(", ")}`)}}class Er{static checkValues(e,t){const r=Array.isArray(e)?e:[e];for(const n of r)for(const r of t.validations)r instanceof Sr&&t.repeated?r.validate(e):r.validate(n)}static checkTypes(e,t){if(t.repeated&&!Array.isArray(e))throw new TypeError("Value must be Array");if("number"==typeof t.type){const r=Array.isArray(e)?e:[e];for(const e of r)mr(e,t.type)}}static getSchemaByName(e,t=wr){return{...e.names[wr],...e.names[t]}}}class Kr extends Er{static serialize(e,t,r,n){const s=this.toJSON(e,t);return JSON.stringify(s,r,n)}static toJSON(e,t={}){let r,n=t.targetSchema;const s=t.schemaName||wr;if(dr(e))return e.toJSON();if(Array.isArray(e)){r=[];for(const n of e)r.push(this.toJSON(n,t))}else if("object"==typeof e){if(n&&!vr.has(n))throw new lr("Cannot get schema for `targetSchema` param");if(n=n||e.constructor,vr.has(n)){const t=vr.get(n);r={};const i=this.getSchemaByName(t,s);for(const a in i)try{const t=i[a],o=e[a];let c;if(t.optional&&void 0===o||void 0!==t.defaultValue&&o===t.defaultValue)continue;if(!t.optional&&void 0===o)throw new fr(n.name,`Property '${a}' is required.`);c="number"==typeof t.type?t.converter?t.repeated?o.map((r=>t.converter.toJSON(r,e))):t.converter.toJSON(o,e):o:t.repeated?o.map((e=>this.toJSON(e,{schemaName:s}))):this.toJSON(o,{schemaName:s}),this.checkTypes(c,t),this.checkValues(c,t),r[t.name||a]=c}catch(e){throw e instanceof fr?e:new fr(t.target.name,`Property '${a}' is wrong. ${e.message}`,e)}}else{r={};for(const t in e)r[t]=this.toJSON(e[t],{schemaName:s})}}else r=e;return r}}class xr extends Er{static parse(e,t){const r=JSON.parse(e);return this.fromJSON(r,t)}static fromJSON(e,t){const r=t.targetSchema,n=t.schemaName||wr,s=new r;if(dr(s))return s.fromJSON(e);const i=vr.get(r),a=this.getSchemaByName(i,n),o={};t.strictProperty&&!Array.isArray(e)&&xr.checkStrictProperty(e,a,i);for(const r in a)try{const o=a[r],c=o.name||r,l=e[c];if(void 0===l&&(o.optional||void 0!==o.defaultValue))continue;if(!o.optional&&void 0===l)throw new hr(i,`Property '${c}' is required.`);if(this.checkTypes(l,o),this.checkValues(l,o),"number"==typeof o.type)o.converter?o.repeated?s[r]=l.map((e=>o.converter.fromJSON(e,s))):s[r]=o.converter.fromJSON(l,s):s[r]=l;else{const e={...t,targetSchema:o.type,schemaName:n};o.repeated?s[r]=l.map((t=>this.fromJSON(t,e))):s[r]=this.fromJSON(l,e)}}catch(e){if(e instanceof hr||(e=new hr(i,`Property '${r}' is wrong. ${e.message}`,e)),!t.strictAllKeys)throw e;o[r]=e}const c=Object.keys(o);if(c.length)throw new pr(i,c,o);return s}static checkStrictProperty(e,t,r){const n=Object.keys(e),s=Object.keys(t),i=[];for(const e of n)-1===s.indexOf(e)&&i.push(e);if(i.length)throw new pr(r,i)}}const Cr=(e={})=>(t,r)=>{const n=`Cannot set type for ${r} property of ${t.constructor.name} schema`;let s;vr.has(t.constructor)?(s=vr.get(t.constructor),s.target!==t.constructor&&(s=vr.create(t.constructor),vr.set(t.constructor,s))):(s=vr.create(t.constructor),vr.set(t.constructor,s));const i={type:gr.Any,validations:[]},a=Object.assign(i,e);if(a.validations=function(e){const t=[];return e.pattern&&t.push(new Ar(e.pattern)),e.type!==gr.Number&&e.type!==gr.Any||(void 0===e.minInclusive&&void 0===e.maxInclusive||t.push(new br(e.minInclusive,e.maxInclusive)),void 0===e.minExclusive&&void 0===e.maxExclusive||t.push(new kr(e.minExclusive,e.maxExclusive)),void 0!==e.enumeration&&t.push(new Br(e.enumeration))),(e.type===gr.String||e.repeated||e.type===gr.Any)&&(void 0===e.length&&void 0===e.minLength&&void 0===e.maxLength||t.push(new Sr(e.length,e.minLength,e.maxLength))),t}(a),"number"!=typeof a.type&&!vr.has(a.type)&&!dr(a.type))throw new Error(`${n}. Assigning type doesn't have schema.`);let o;o=Array.isArray(e.schema)?e.schema:[e.schema||wr];for(const e of o){s.names[e]||(s.names[e]={});s.names[e][r]=a}}
/*!
 Copyright (c) Peculiar Ventures, LLC
*/;class Nr extends Error{}class Ur extends Nr{}class Pr extends Nr{constructor(e){super("Unsupported operation: "+(e?`${e}`:""))}}class Ir extends Nr{}class Or extends Nr{constructor(e){super(`${e}: Missing required property`)}}class Hr{static toArrayBuffer(e){const t=e.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return f.FromBase64(t)}static toUint8Array(e){const t=this.toArrayBuffer(e);return new Uint8Array(t)}static fromBufferSource(e,t){const r=f.ToBase64(e);let n,s=0;const i=[];for(;s<r.length&&(n=r.slice(s,s+64),n.length);)i.push(n),s+=64;const a=t.toUpperCase();return`-----BEGIN ${a}-----\n${i.join("\n")}\n-----END ${a}-----`}static isPEM(e){return/-----BEGIN .+-----[A-Za-z0-9+/+=\s\n]+-----END .+-----/i.test(e)}static getTagName(e){if(!this.isPEM(e))throw new Error("Bad parameter. Incoming data is not right PEM");const t=/-----BEGIN (.+)-----/.exec(e);if(!t)throw new Error("Cannot get tag from PEM");return t[1]}static hasTagName(e,t){const r=this.getTagName(e);return t.toLowerCase()===r.toLowerCase()}static isCertificate(e){return this.hasTagName(e,"certificate")}static isCertificateRequest(e){return this.hasTagName(e,"certificate request")}static isCRL(e){return this.hasTagName(e,"x509 crl")}static isPublicKey(e){return this.hasTagName(e,"public key")}}class Tr{async digest(...e){return this.checkDigest.apply(this,e),this.onDigest.apply(this,e)}checkDigest(e,t){this.checkAlgorithmName(e)}async onDigest(e,t){throw new Pr("digest")}async generateKey(...e){return this.checkGenerateKey.apply(this,e),this.onGenerateKey.apply(this,e)}checkGenerateKey(e,t,r,...n){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let s;s=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,s)}checkGenerateKeyParams(e){}async onGenerateKey(e,t,r,...n){throw new Pr("generateKey")}async sign(...e){return this.checkSign.apply(this,e),this.onSign.apply(this,e)}checkSign(e,t,r,...n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}async onSign(e,t,r,...n){throw new Pr("sign")}async verify(...e){return this.checkVerify.apply(this,e),this.onVerify.apply(this,e)}checkVerify(e,t,r,n,...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}async onVerify(e,t,r,n,...s){throw new Pr("verify")}async encrypt(...e){return this.checkEncrypt.apply(this,e),this.onEncrypt.apply(this,e)}checkEncrypt(e,t,r,n={},...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"encrypt":void 0)}async onEncrypt(e,t,r,...n){throw new Pr("encrypt")}async decrypt(...e){return this.checkDecrypt.apply(this,e),this.onDecrypt.apply(this,e)}checkDecrypt(e,t,r,n={},...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"decrypt":void 0)}async onDecrypt(e,t,r,...n){throw new Pr("decrypt")}async deriveBits(...e){return this.checkDeriveBits.apply(this,e),this.onDeriveBits.apply(this,e)}checkDeriveBits(e,t,r,n={},...s){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"deriveBits":void 0),r%8!=0)throw new Ir("length: Is not multiple of 8")}async onDeriveBits(e,t,r,...n){throw new Pr("deriveBits")}async exportKey(...e){return this.checkExportKey.apply(this,e),this.onExportKey.apply(this,e)}checkExportKey(e,t,...r){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new Nr("key: Is not extractable")}async onExportKey(e,t,...r){throw new Pr("exportKey")}async importKey(...e){return this.checkImportKey.apply(this,e),this.onImportKey.apply(this,e)}checkImportKey(e,t,r,n,s,...i){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(s,this.usages)}async onImportKey(e,t,r,n,s,...i){throw new Pr("importKey")}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new Ur("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(-1===t.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&-1===e.usages.indexOf(t))throw new Nr("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new Or(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new Ir(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===e){if("object"!=typeof(r=t)||!("kty"in r))throw new TypeError("keyData: Is not JsonWebToken")}else if(!y.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");var r}prepareData(e){return y.toArrayBuffer(e)}}class Lr extends Tr{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}let Dr=class extends Lr{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}},Vr=class extends Lr{constructor(){super(...arguments),this.name="AES-CMAC",this.usages=["sign","verify"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new Ir("length: Must be more than 0")}},Rr=class extends Lr{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new Ir("length: Must be more than 0")}},Mr=class extends Lr{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}},$r=class extends Lr{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){var t;if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new Ir("iv: Must have length more than 0 and less than 2^64 - 1");switch(null!==(t=e.tagLength)&&void 0!==t||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new Ir("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}},Jr=class extends Lr{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}};class jr extends Tr{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new Ir(`algorithm.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class zr extends Tr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=f.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");if(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength%8||e.modulusLength<256||e.modulusLength>16384)throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384")}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}let Fr=class extends zr{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}},Gr=class extends zr{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),"number"!=typeof e.saltLength)throw new TypeError("saltLength: Is not a Number");if(e.saltLength<0)throw new RangeError("saltLength: Must be positive number")}},_r=class extends zr{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}};class qr extends Tr{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new Ir(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}let Wr=class extends qr{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}};const Yr=["secret","private","public"];let Xr=class{static create(e,t,r,n){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=n,s}static isKeyType(e){return-1!==Yr.indexOf(e)}get[Symbol.toStringTag](){return"CryptoKey"}},Zr=class extends qr{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof Xr))throw new TypeError("public: Is not a CryptoKey");if("public"!==e.public.type)throw new Ir("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new Ir(`public: Is not ${this.name} key`)}},Qr=class extends Zr{constructor(){super(...arguments),this.name="ECDH-ES",this.namedCurves=["X25519","X448"]}},en=class extends qr{constructor(){super(...arguments),this.name="EdDSA",this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["Ed25519","Ed448"]}},tn=class{constructor(e){e&&(this.value=e)}};n([sr({type:xt.ObjectIdentifier})],tn.prototype,"value",void 0),tn=n([nr({type:Kt.Choice})],tn);class rn{constructor(e){Object.assign(this,e)}}n([sr({type:xt.ObjectIdentifier})],rn.prototype,"algorithm",void 0),n([sr({type:xt.Any,optional:!0})],rn.prototype,"parameters",void 0);class nn{constructor(){this.version=0,this.privateKeyAlgorithm=new rn,this.privateKey=new ArrayBuffer(0)}}n([sr({type:xt.Integer})],nn.prototype,"version",void 0),n([sr({type:rn})],nn.prototype,"privateKeyAlgorithm",void 0),n([sr({type:xt.OctetString})],nn.prototype,"privateKey",void 0),n([sr({type:xt.Any,optional:!0})],nn.prototype,"attributes",void 0);class sn{constructor(){this.publicKeyAlgorithm=new rn,this.publicKey=new ArrayBuffer(0)}}n([sr({type:rn})],sn.prototype,"publicKeyAlgorithm",void 0),n([sr({type:xt.BitString})],sn.prototype,"publicKey",void 0);const an={fromJSON:e=>f.FromBase64Url(e),toJSON:e=>f.ToBase64Url(new Uint8Array(e))},on={fromASN:e=>{const t=e.valueBlock.valueHex;return new Uint8Array(t)[0]?e.valueBlock.valueHex:e.valueBlock.valueHex.slice(1)},toASN:e=>{const t=new Uint8Array(e)[0]>127?p(new Uint8Array([0]).buffer,e):e;return new ve({valueHex:t})}};let cn=class{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}};n([sr({type:xt.Integer,converter:Ut})],cn.prototype,"version",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"n",converter:an})],cn.prototype,"modulus",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"e",converter:an})],cn.prototype,"publicExponent",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"d",converter:an})],cn.prototype,"privateExponent",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"p",converter:an})],cn.prototype,"prime1",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"q",converter:an})],cn.prototype,"prime2",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"dp",converter:an})],cn.prototype,"exponent1",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"dq",converter:an})],cn.prototype,"exponent2",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"qi",converter:an})],cn.prototype,"coefficient",void 0),n([sr({type:xt.Any,optional:!0})],cn.prototype,"otherPrimeInfos",void 0);let ln=class{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}};n([sr({type:xt.Integer,converter:on}),Cr({name:"n",converter:an})],ln.prototype,"modulus",void 0),n([sr({type:xt.Integer,converter:on}),Cr({name:"e",converter:an})],ln.prototype,"publicExponent",void 0);let un=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(4!==e[0])throw new Nr("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");e=new Uint8Array(this.value.slice(1));const t=e.length/2;return{x:f.ToBase64Url(e.buffer.slice(0,0+t)),y:f.ToBase64Url(e.buffer.slice(0+t,0+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=f.FromBase64Url(e.x),r=f.FromBase64Url(e.y),n=p(new Uint8Array([4]).buffer,t,r);return this.value=new Uint8Array(n).buffer,this}};n([sr({type:xt.OctetString})],un.prototype,"value",void 0),un=n([nr({type:Kt.Choice})],un);let hn=class{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=f.FromBase64Url(e.d),"x"in e){const t=new un;t.fromJSON(e);const r=or.toASN(t);"valueHex"in r.valueBlock&&(this.publicKey=r.valueBlock.valueHex)}return this}toJSON(){const e={};return e.d=f.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new un(this.publicKey).toJSON()),e}};n([sr({type:xt.Integer,converter:Ut})],hn.prototype,"version",void 0),n([sr({type:xt.OctetString})],hn.prototype,"privateKey",void 0),n([sr({context:0,type:xt.Any,optional:!0})],hn.prototype,"parameters",void 0),n([sr({context:1,type:xt.BitString,optional:!0})],hn.prototype,"publicKey",void 0);const yn={fromASN:e=>{const t=new Uint8Array(e.valueBlock.valueHex);return 0===t[0]?t.buffer.slice(1):t.buffer},toASN:e=>{const t=new Uint8Array(e);if(t[0]>127){const e=new Uint8Array(t.length+1);return e.set(t,1),new ve({valueHex:e.buffer})}return new ve({valueHex:e})}};var fn=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:yn});class pn{static decodePoint(e,t){const r=y.toUint8Array(e);if(0===r.length||4!==r[0])throw new Error("Only uncompressed point format supported");const n=(r.length-1)/2;if(n!==Math.ceil(t/8))throw new Error("Point does not match field size");return{x:r.slice(1,n+1),y:r.slice(n+1,n+1+n)}}static encodePoint(e,t){const r=Math.ceil(t/8);if(e.x.byteLength!==r||e.y.byteLength!==r)throw new Error("X,Y coordinates don't match point size criteria");const n=y.toUint8Array(e.x),s=y.toUint8Array(e.y),i=new Uint8Array(2*r+1);return i[0]=4,i.set(n,1),i.set(s,r+1),i}static getSize(e){return Math.ceil(e/8)}static encodeSignature(e,t){const r=this.getSize(t),n=y.toUint8Array(e.r),s=y.toUint8Array(e.s),i=new Uint8Array(2*r);return i.set(this.padStart(n,r)),i.set(this.padStart(s,r),r),i}static decodeSignature(e,t){const r=this.getSize(t),n=y.toUint8Array(e);if(n.length!==2*r)throw new Error("Incorrect size of the signature");const s=n.slice(0,r),i=n.slice(r);return{r:this.trimStart(s),s:this.trimStart(i)}}static trimStart(e){let t=0;for(;t<e.length-1&&0===e[t];)t++;return 0===t?e:e.slice(t,e.length)}static padStart(e,t){if(t===e.length)return e;const r=new Uint8Array(t);return r.set(e,t-e.length),r}}class gn{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(e){const t=e.byteLength/2,r=pn.decodeSignature(e,8*t),n=new gn;return n.r=y.toArrayBuffer(r.r),n.s=y.toArrayBuffer(r.s),n}toWebCryptoSignature(e){null!=e||(e=8*Math.max(this.r.byteLength,this.s.byteLength));return pn.encodeSignature(this,e).buffer}}n([sr({type:xt.Integer,converter:yn})],gn.prototype,"r",void 0),n([sr({type:xt.Integer,converter:yn})],gn.prototype,"s",void 0);class mn extends nn{}n([sr({context:1,implicit:!0,type:xt.BitString,optional:!0})],mn.prototype,"publicKey",void 0);let dn=class{constructor(){this.value=new ArrayBuffer(0)}fromJSON(e){if(!e.d)throw new Error("d: Missing required property");return this.value=f.FromBase64Url(e.d),this}toJSON(){return{d:f.ToBase64Url(this.value)}}};n([sr({type:xt.OctetString})],dn.prototype,"value",void 0),dn=n([nr({type:Kt.Choice})],dn);let wn=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){return{x:f.ToBase64Url(this.value)}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");return this.value=f.FromBase64Url(e.x),this}};n([sr({type:xt.BitString})],wn.prototype,"value",void 0),wn=n([nr({type:Kt.Choice})],wn);let vn=class{};n([sr({type:xt.OctetString}),Cr({type:gr.String,converter:an})],vn.prototype,"d",void 0),vn=n([nr({type:Kt.Choice})],vn);const An="1.2.840.10045.3.1.7",bn="1.3.132.0",kn=`${bn}.34`,Sn=`${bn}.35`,Bn=`${bn}.10`,En="1.3.36.3.3.2.8.1.1",Kn=`${En}.1`,xn=`${En}.2`,Cn=`${En}.3`,Nn=`${En}.4`,Un=`${En}.5`,Pn=`${En}.6`,In=`${En}.7`,On=`${En}.8`,Hn=`${En}.9`,Tn=`${En}.10`,Ln=`${En}.11`,Dn=`${En}.12`,Vn=`${En}.13`,Rn=`${En}.14`;var Mn=Object.freeze({__proto__:null,AlgorithmIdentifier:rn,get CurvePrivateKey(){return vn},EcDsaSignature:gn,EcPrivateKey:hn,get EcPublicKey(){return un},get EdPrivateKey(){return dn},get EdPublicKey(){return wn},get ObjectIdentifier(){return tn},OneAsymmetricKey:mn,PrivateKeyInfo:nn,PublicKeyInfo:sn,RsaPrivateKey:cn,RsaPublicKey:ln,converters:fn,idBrainpoolP160r1:Kn,idBrainpoolP160t1:xn,idBrainpoolP192r1:Cn,idBrainpoolP192t1:Nn,idBrainpoolP224r1:Un,idBrainpoolP224t1:Pn,idBrainpoolP256r1:In,idBrainpoolP256t1:On,idBrainpoolP320r1:Hn,idBrainpoolP320t1:Tn,idBrainpoolP384r1:Ln,idBrainpoolP384t1:Dn,idBrainpoolP512r1:Vn,idBrainpoolP512t1:Rn,idEd25519:"1.3.101.112",idEd448:"1.3.101.113",idEllipticCurve:bn,idSecp256k1:Bn,idSecp256r1:An,idSecp384r1:kn,idSecp521r1:Sn,idVersionOne:En,idX25519:"1.3.101.110",idX448:"1.3.101.111"});class $n{constructor(){}static register(e){const t=new tn;t.value=e.id;const r=cr.serialize(t);this.items.push({...e,raw:r}),this.names.push(e.name)}static find(e){e=e.toUpperCase();for(const t of this.items)if(t.name.toUpperCase()===e||t.id.toUpperCase()===e)return t;return null}static get(e){const t=this.find(e);if(!t)throw new Error(`Unsupported EC named curve '${e}'`);return t}}$n.items=[],$n.names=[],$n.register({name:"P-256",id:An,size:256}),$n.register({name:"P-384",id:kn,size:384}),$n.register({name:"P-521",id:Sn,size:521}),$n.register({name:"K-256",id:Bn,size:256}),$n.register({name:"brainpoolP160r1",id:Kn,size:160}),$n.register({name:"brainpoolP160t1",id:xn,size:160}),$n.register({name:"brainpoolP192r1",id:Cn,size:192}),$n.register({name:"brainpoolP192t1",id:Nn,size:192}),$n.register({name:"brainpoolP224r1",id:Un,size:224}),$n.register({name:"brainpoolP224t1",id:Pn,size:224}),$n.register({name:"brainpoolP256r1",id:In,size:256}),$n.register({name:"brainpoolP256t1",id:On,size:256}),$n.register({name:"brainpoolP320r1",id:Hn,size:320}),$n.register({name:"brainpoolP320t1",id:Tn,size:320}),$n.register({name:"brainpoolP384r1",id:Ln,size:384}),$n.register({name:"brainpoolP384t1",id:Dn,size:384}),$n.register({name:"brainpoolP512r1",id:Vn,size:512}),$n.register({name:"brainpoolP512t1",id:Rn,size:512});let Jn=class extends Tr{constructor(){super(...arguments),this.name="X25519",this.usages={privateKey:["deriveKey","deriveBits"],publicKey:[]}}checkAlgorithmParams(e){this.checkRequiredProperty(e,"public")}},jn=class extends Tr{constructor(){super(...arguments),this.name="Ed25519",this.usages={privateKey:["sign"],publicKey:["verify"]}}},zn=class extends Tr{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(e){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${e}'`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),"length"in e){if("number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}},Fn=class extends Tr{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),"number"!=typeof e.iterations)throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,n,s,...i){if(super.checkImportKey(e,t,r,n,s,...i),n)throw new SyntaxError("extractable: Must be 'false'")}},Gn=class extends Tr{constructor(){super(...arguments),this.name="HKDF",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveKey","deriveBits"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!y.isBufferSource(e.salt))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"info"),!y.isBufferSource(e.info))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}checkImportKey(e,t,r,n,s,...i){if(super.checkImportKey(e,t,r,n,s,...i),n)throw new SyntaxError("extractable: Must be 'false'")}};class _n extends Tr{constructor(){super(...arguments),this.usages=[],this.defaultLength=0}digest(...e){return e[0]={length:this.defaultLength,...e[0]},super.digest.apply(this,e)}checkDigest(e,t){super.checkDigest(e,t);const r=e.length||0;if("number"!=typeof r)throw new TypeError("length: Is not a Number");if(r<0)throw new TypeError("length: Is negative")}}let qn=class extends _n{constructor(){super(...arguments),this.name="shake128",this.defaultLength=16}},Wn=class extends _n{constructor(){super(...arguments),this.name="shake256",this.defaultLength=32}},Yn=class{get[Symbol.toStringTag](){return"Crypto"}randomUUID(){const e=this.getRandomValues(new Uint8Array(16));e[6]=15&e[6]|64,e[8]=63&e[8]|128;const t=f.ToHex(e).toLowerCase();return`${t.substring(0,8)}-${t.substring(8,12)}-${t.substring(12,16)}-${t.substring(16,20)}-${t.substring(20)}`}};class Xn{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}const Zn={jwk:["private","public","secret"],pkcs8:["private"],spki:["public"],raw:["secret","public"]},Qn=["pkcs8","spki","raw"];let es=class e{constructor(){this.providers=new Xn}static isHashedAlgorithm(e){return!!(e&&"object"==typeof e&&"name"in e&&"hash"in e)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...e){this.checkRequiredArguments(e,2,"digest");const[t,r,...n]=e,s=this.prepareAlgorithm(t),i=y.toArrayBuffer(r),a=this.getProvider(s.name);return await a.digest(s,i,...n)}async generateKey(...e){this.checkRequiredArguments(e,3,"generateKey");const[t,r,n,...s]=e,i=this.prepareAlgorithm(t),a=this.getProvider(i.name);return await a.generateKey({...i,name:a.name},r,n,...s)}async sign(...e){this.checkRequiredArguments(e,3,"sign");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=y.toArrayBuffer(n),o=this.getProvider(i.name);return await o.sign({...i,name:o.name},r,a,...s)}async verify(...e){this.checkRequiredArguments(e,4,"verify");const[t,r,n,s,...i]=e;this.checkCryptoKey(r);const a=this.prepareAlgorithm(t),o=y.toArrayBuffer(s),c=y.toArrayBuffer(n),l=this.getProvider(a.name);return await l.verify({...a,name:l.name},r,c,o,...i)}async encrypt(...e){this.checkRequiredArguments(e,3,"encrypt");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=y.toArrayBuffer(n),o=this.getProvider(i.name);return await o.encrypt({...i,name:o.name},r,a,{keyUsage:!0},...s)}async decrypt(...e){this.checkRequiredArguments(e,3,"decrypt");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=y.toArrayBuffer(n),o=this.getProvider(i.name);return await o.decrypt({...i,name:o.name},r,a,{keyUsage:!0},...s)}async deriveBits(...e){this.checkRequiredArguments(e,3,"deriveBits");const[t,r,n,...s]=e;this.checkCryptoKey(r);const i=this.prepareAlgorithm(t),a=this.getProvider(i.name);return await a.deriveBits({...i,name:a.name},r,n,{keyUsage:!0},...s)}async deriveKey(...e){this.checkRequiredArguments(e,5,"deriveKey");const[t,r,n,s,i,...a]=e,o=this.prepareAlgorithm(n);this.getProvider(o.name).checkDerivedKeyParams(o);const c=this.prepareAlgorithm(t),l=this.getProvider(c.name);l.checkCryptoKey(r,"deriveKey");const u=await l.deriveBits({...c,name:l.name},r,n.length||512,{keyUsage:!1},...a);return this.importKey("raw",u,n,s,i,...a)}async exportKey(...e){this.checkRequiredArguments(e,2,"exportKey");const[t,r,...n]=e;if(this.checkCryptoKey(r),!Zn[t])throw new TypeError("Invalid keyFormat argument");if(!Zn[t].includes(r.type))throw new DOMException("The key is not of the expected type");const s=this.getProvider(r.algorithm.name);return await s.exportKey(t,r,...n)}async importKey(...e){this.checkRequiredArguments(e,5,"importKey");const[t,r,n,s,i,...a]=e,o=this.prepareAlgorithm(n),c=this.getProvider(o.name);if("jwk"===t){if("object"!=typeof r||!r.kty)throw new TypeError("Key data must be an object for JWK import")}else{if(!Qn.includes(t))throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView or JsonWebKey)'");if(!y.isBufferSource(r))throw new TypeError("Key data must be a BufferSource for non-JWK formats")}return c.importKey(t,r,{...o,name:c.name},s,i,...a)}async wrapKey(e,t,r,n,...s){let i=await this.exportKey(e,t,...s);if("jwk"===e){const e=JSON.stringify(i);i=f.FromUtf8String(e)}const a=this.prepareAlgorithm(n),o=y.toArrayBuffer(i),c=this.getProvider(a.name);return c.encrypt({...a,name:c.name},r,o,{keyUsage:!1},...s)}async unwrapKey(e,t,r,n,s,i,a,...o){const c=this.prepareAlgorithm(n),l=y.toArrayBuffer(t),u=this.getProvider(c.name);let h=await u.decrypt({...c,name:u.name},r,l,{keyUsage:!1},...o);if("jwk"===e)try{h=JSON.parse(f.ToUtf8String(h))}catch(e){const t=new TypeError("wrappedKey: Is not a JSON");throw t.internal=e,t}return this.importKey(e,h,s,i,a,...o)}checkRequiredArguments(e,t,r){if(e.length<t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(t){if("string"==typeof t)return{name:t};if(e.isHashedAlgorithm(t)){const e={...t};return e.hash=this.prepareAlgorithm(t.hash),e}return{...t}}getProvider(e){const t=this.providers.get(e);if(!t)throw new Ur("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof Xr))throw new TypeError("Key is not of type 'CryptoKey'")}};const ts={fromJSON:t=>e.from(f.FromBase64Url(t)),toJSON:e=>f.ToBase64Url(e)};class rs extends Xr{constructor(){super(...arguments),this.data=e.alloc(0),this.algorithm={name:""},this.extractable=!1,this.type="secret",this.usages=[],this.kty="oct",this.alg=""}}n([Cr({name:"ext",type:gr.Boolean,optional:!0})],rs.prototype,"extractable",void 0),n([Cr({name:"key_ops",type:gr.String,repeated:!0,optional:!0})],rs.prototype,"usages",void 0),n([Cr({type:gr.String})],rs.prototype,"kty",void 0),n([Cr({type:gr.String,optional:!0})],rs.prototype,"alg",void 0);class ns extends rs{constructor(){super(...arguments),this.kty="oct",this.type="secret"}}class ss extends rs{}class is extends ns{get alg(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-KW":return`A${this.algorithm.length}KW`;case"AES-CMAC":return`A${this.algorithm.length}CMAC`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new Ur("Unsupported algorithm name")}}set alg(e){}}n([Cr({name:"k",converter:ts})],is.prototype,"data",void 0);class as{static async generateKey(e,r,n){const s=new is;return s.algorithm=e,s.extractable=r,s.usages=n,s.data=t.randomBytes(e.length>>3),s}static async exportKey(e,t){if(!(t instanceof is))throw new Error("key: Is not AesCryptoKey");switch(e.toLowerCase()){case"jwk":return Kr.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new Ir("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,n,s,i){let a;switch(t.toLowerCase()){case"jwk":a=xr.fromJSON(r,{targetSchema:is});break;case"raw":a=new is,a.data=e.from(r);break;default:throw new Ir("format: Must be 'jwk' or 'raw'")}switch(a.algorithm=n,a.algorithm.length=a.data.length<<3,a.extractable=s,a.usages=i,a.algorithm.length){case 128:case 192:case 256:break;default:throw new Ir("keyData: Is wrong key length")}return a}static async encrypt(t,r,n){switch(t.name.toUpperCase()){case"AES-CBC":return this.encryptAesCBC(t,r,e.from(n));case"AES-CTR":return this.encryptAesCTR(t,r,e.from(n));case"AES-GCM":return this.encryptAesGCM(t,r,e.from(n));case"AES-KW":return this.encryptAesKW(t,r,e.from(n));case"AES-ECB":return this.encryptAesECB(t,r,e.from(n));default:throw new Ir("algorithm: Is not recognized")}}static async decrypt(t,r,n){if(!(r instanceof is))throw new Error("key: Is not AesCryptoKey");switch(t.name.toUpperCase()){case"AES-CBC":return this.decryptAesCBC(t,r,e.from(n));case"AES-CTR":return this.decryptAesCTR(t,r,e.from(n));case"AES-GCM":return this.decryptAesGCM(t,r,e.from(n));case"AES-KW":return this.decryptAesKW(t,r,e.from(n));case"AES-ECB":return this.decryptAesECB(t,r,e.from(n));default:throw new Ir("algorithm: Is not recognized")}}static async encryptAesCBC(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-cbc`,n.data,new Uint8Array(r.iv));let a=i.update(s);a=e.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptAesCBC(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-cbc`,n.data,new Uint8Array(r.iv));let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}static async encryptAesCTR(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-ctr`,n.data,e.from(r.counter));let a=i.update(s);a=e.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptAesCTR(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-ctr`,n.data,new Uint8Array(r.counter));let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}static async encryptAesGCM(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-gcm`,n.data,e.from(r.iv),{authTagLength:(r.tagLength||128)>>3});r.additionalData&&i.setAAD(e.from(r.additionalData));let a=i.update(s);a=e.concat([a,i.final(),i.getAuthTag()]);return new Uint8Array(a).buffer}static async decryptAesGCM(r,n,s){const i=(r.tagLength||128)>>3,a=t.createDecipheriv(`aes-${n.algorithm.length}-gcm`,n.data,new Uint8Array(r.iv),{authTagLength:i}),o=s.slice(0,s.length-i),c=s.slice(s.length-i);r.additionalData&&a.setAAD(e.from(r.additionalData)),a.setAuthTag(c);let l=a.update(o);return l=e.concat([l,a.final()]),new Uint8Array(l).buffer}static async encryptAesKW(r,n,s){const i=t.createCipheriv(`id-aes${n.algorithm.length}-wrap`,n.data,this.AES_KW_IV);let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}static async decryptAesKW(r,n,s){const i=t.createDecipheriv(`id-aes${n.algorithm.length}-wrap`,n.data,this.AES_KW_IV);let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}static async encryptAesECB(r,n,s){const i=t.createCipheriv(`aes-${n.algorithm.length}-ecb`,n.data,new Uint8Array(0));let a=i.update(s);a=e.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptAesECB(r,n,s){const i=t.createDecipheriv(`aes-${n.algorithm.length}-ecb`,n.data,new Uint8Array(0));let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}}as.AES_KW_IV=e.from("A6A6A6A6A6A6A6A6","hex");const os=new WeakMap;function cs(e){const t=os.get(e);if(!t)throw new Ir("Cannot get CryptoKey from secure storage");return t}function ls(e){const t=Xr.create(e.algorithm,e.type,e.extractable,e.usages);return Object.freeze(t),os.set(t,e),t}class us extends Dr{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return as.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return as.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}const hs=e.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),ys=e.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,135]),fs=16;function ps(t){const r=e.alloc(t.length),n=t.length-1;for(let e=0;e<n;e++)r[e]=t[e]<<1,128&t[e+1]&&(r[e]+=1);return r[n]=t[n]<<1,r}function gs(t,r){const n=Math.min(t.length,r.length),s=e.alloc(n);for(let e=0;e<n;e++)s[e]=t[e]^r[e];return s}function ms(e,r){const n=t.createCipheriv("aes"+(e.length<<3),e,hs),s=n.update(r);return n.final(),s}function ds(t,r){const n=e.alloc(fs),s=r*fs,i=s+fs;return t.copy(n,0,s,i),n}function ws(t,r){const n=function(e){const t=ms(e,hs);let r=ps(t);128&t[0]&&(r=gs(r,ys));let n=ps(r);return 128&r[0]&&(n=gs(n,ys)),{subkey1:r,subkey2:n}}(t);let s,i,a=Math.ceil(r.length/fs);0===a?(a=1,s=!1):s=r.length%fs==0;const o=a-1;i=s?gs(ds(r,o),n.subkey1):gs(function(t,r){const n=e.alloc(fs),s=r*fs,i=t.length;return n.fill(0),t.copy(n,0,s,i),n[i-s]=128,n}(r,o),n.subkey2);let c,l=hs;for(let e=0;e<o;e++)c=gs(l,ds(r,e)),l=ms(t,c);return c=gs(i,l),ms(t,c)}class vs extends Vr{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onSign(t,r,n){const s=ws(cs(r).data,e.from(n));return new Uint8Array(s).buffer}async onVerify(t,r,n,s){const i=await this.sign(t,r,s);return 0===e.from(n).compare(e.from(i))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}class As extends Rr{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return as.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return as.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}class bs extends $r{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return as.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return as.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}class ks extends Jr{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}async onEncrypt(e,t,r){return as.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return as.decrypt(e,cs(t),new Uint8Array(r))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}class Ss extends Mr{async onGenerateKey(e,t,r){return ls(await as.generateKey({name:this.name,length:e.length},t,r))}async onEncrypt(e,t,r){return as.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return as.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return as.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await as.importKey(e,t,{name:r.name},n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof is))throw new TypeError("key: Is not a AesCryptoKey")}}class Bs extends ns{get alg(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new Ur("Unsupported algorithm name")}}set alg(e){}}n([Cr({name:"k",converter:ts})],Bs.prototype,"data",void 0);class Es{static async generateKey(e,r,n){const s=new Bs;return s.algorithm=e,s.extractable=r,s.usages=n,s.data=t.randomBytes(e.length>>3),s}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return Kr.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new Ir("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,n,s,i){let a;switch(t.toLowerCase()){case"jwk":a=xr.fromJSON(r,{targetSchema:Bs});break;case"raw":a=new Bs,a.data=e.from(r);break;default:throw new Ir("format: Must be 'jwk' or 'raw'")}return a.algorithm=n,a.extractable=s,a.usages=i,a}static async encrypt(t,r,n){switch(t.name.toUpperCase()){case"DES-CBC":return this.encryptDesCBC(t,r,e.from(n));case"DES-EDE3-CBC":return this.encryptDesEDE3CBC(t,r,e.from(n));default:throw new Ir("algorithm: Is not recognized")}}static async decrypt(t,r,n){if(!(r instanceof Bs))throw new Error("key: Is not DesCryptoKey");switch(t.name.toUpperCase()){case"DES-CBC":return this.decryptDesCBC(t,r,e.from(n));case"DES-EDE3-CBC":return this.decryptDesEDE3CBC(t,r,e.from(n));default:throw new Ir("algorithm: Is not recognized")}}static async encryptDesCBC(r,n,s){const i=t.createCipheriv("des-cbc",n.data,new Uint8Array(r.iv));let a=i.update(s);a=e.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptDesCBC(r,n,s){const i=t.createDecipheriv("des-cbc",n.data,new Uint8Array(r.iv));let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}static async encryptDesEDE3CBC(r,n,s){const i=t.createCipheriv("des-ede3-cbc",n.data,e.from(r.iv));let a=i.update(s);a=e.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptDesEDE3CBC(r,n,s){const i=t.createDecipheriv("des-ede3-cbc",n.data,new Uint8Array(r.iv));let a=i.update(s);return a=e.concat([a,i.final()]),new Uint8Array(a).buffer}}class Ks extends jr{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}async onGenerateKey(e,t,r){return ls(await Es.generateKey({name:this.name,length:this.keySizeBits},t,r))}async onEncrypt(e,t,r){return Es.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Es.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return Es.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){const i=await Es.importKey(e,t,{name:this.name,length:this.keySizeBits},n,s);if(i.data.length!==this.keySizeBits>>3)throw new Ir("keyData: Wrong key size");return ls(i)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof Bs))throw new TypeError("key: Is not a DesCryptoKey")}}class xs extends jr{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}async onGenerateKey(e,t,r){return ls(await Es.generateKey({name:this.name,length:this.keySizeBits},t,r))}async onEncrypt(e,t,r){return Es.encrypt(e,cs(t),new Uint8Array(r))}async onDecrypt(e,t,r){return Es.decrypt(e,cs(t),new Uint8Array(r))}async onExportKey(e,t){return Es.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){const i=await Es.importKey(e,t,{name:this.name,length:this.keySizeBits},n,s);if(i.data.length!==this.keySizeBits>>3)throw new Ir("keyData: Wrong key size");return ls(i)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof Bs))throw new TypeError("key: Is not a DesCryptoKey")}}function Cs(e){switch(e.name.toUpperCase()){case"RSA-OAEP":{const t=/(\d+)$/.exec(e.hash.name)[1];return"RSA-OAEP"+("1"!==t?`-${t}`:"")}case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PKCS1":return"RS1";default:throw new Ir("algorithm: Is not recognized")}}class Ns extends ss{constructor(){super(...arguments),this.type="private"}getKey(){const e=ar.parse(this.data,Mn.PrivateKeyInfo);return ar.parse(e.privateKey,Mn.RsaPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:Cs(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,Kr.toJSON(e))}fromJSON(t){const r=xr.fromJSON(t,{targetSchema:Mn.RsaPrivateKey}),n=new Mn.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.privateKeyAlgorithm.parameters=null,n.privateKey=or.serialize(r),this.data=e.from(or.serialize(n))}}class Us extends ss{constructor(){super(...arguments),this.type="public"}getKey(){const e=ar.parse(this.data,Mn.PublicKeyInfo);return ar.parse(e.publicKey,Mn.RsaPublicKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:Cs(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,Kr.toJSON(e))}fromJSON(t){const r=xr.fromJSON(t,{targetSchema:Mn.RsaPublicKey}),n=new Mn.PublicKeyInfo;n.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.publicKeyAlgorithm.parameters=null,n.publicKey=or.serialize(r),this.data=e.from(or.serialize(n))}}class Ps{static async generateKey(r,n,s){const i=new Ns;i.algorithm=r,i.extractable=n,i.usages=s.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const a=new Us;a.algorithm=r,a.extractable=!0,a.usages=s.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const o=e.concat([e.alloc(4-r.publicExponent.byteLength,0),e.from(r.publicExponent)]).readInt32BE(0),c=t.generateKeyPairSync("rsa",{modulusLength:r.modulusLength,publicExponent:o,publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});i.data=c.privateKey,a.data=c.publicKey;return{privateKey:i,publicKey:a}}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return Kr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;default:throw new Ir("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":if(t.d){const e=xr.fromJSON(t,{targetSchema:Mn.RsaPrivateKey});return this.importPrivateKey(e,r,n,s)}{const e=xr.fromJSON(t,{targetSchema:Mn.RsaPublicKey});return this.importPublicKey(e,r,n,s)}case"spki":{const e=ar.parse(new Uint8Array(t),Mn.PublicKeyInfo),i=ar.parse(e.publicKey,Mn.RsaPublicKey);return this.importPublicKey(i,r,n,s)}case"pkcs8":{const e=ar.parse(new Uint8Array(t),Mn.PrivateKeyInfo),i=ar.parse(e.privateKey,Mn.RsaPrivateKey);return this.importPrivateKey(i,r,n,s)}default:throw new Ir("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async sign(e,t,r){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.signRsa(e,t,r);default:throw new Ir("algorithm: Is not recognized")}}static async verify(e,t,r,n){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.verifySSA(e,t,n,r);default:throw new Ir("algorithm: Is not recognized")}}static async encrypt(e,t,r){if("RSA-OAEP"===e.name.toUpperCase())return this.encryptOAEP(e,t,r);throw new Ir("algorithm: Is not recognized")}static async decrypt(e,t,r){if("RSA-OAEP"===e.name.toUpperCase())return this.decryptOAEP(e,t,r);throw new Ir("algorithm: Is not recognized")}static importPrivateKey(t,r,n,s){const i=new Mn.PrivateKeyInfo;i.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",i.privateKeyAlgorithm.parameters=null,i.privateKey=or.serialize(t);const a=new Ns;return a.data=e.from(or.serialize(i)),a.algorithm=Object.assign({},r),a.algorithm.publicExponent=new Uint8Array(t.publicExponent),a.algorithm.modulusLength=t.modulus.byteLength<<3,a.extractable=n,a.usages=s,a}static importPublicKey(t,r,n,s){const i=new Mn.PublicKeyInfo;i.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",i.publicKeyAlgorithm.parameters=null,i.publicKey=or.serialize(t);const a=new Us;return a.data=e.from(or.serialize(i)),a.algorithm=Object.assign({},r),a.algorithm.publicExponent=new Uint8Array(t.publicExponent),a.algorithm.modulusLength=t.modulus.byteLength<<3,a.extractable=n,a.usages=s,a}static getCryptoAlgorithm(e){switch(e.hash.name.toUpperCase()){case"SHA-1":return"RSA-SHA1";case"SHA-256":return"RSA-SHA256";case"SHA-384":return"RSA-SHA384";case"SHA-512":return"RSA-SHA512";case"SHA3-256":return"RSA-SHA3-256";case"SHA3-384":return"RSA-SHA3-384";case"SHA3-512":return"RSA-SHA3-512";default:throw new Ir("algorithm.hash: Is not recognized")}}static signRsa(r,n,s){const i=this.getCryptoAlgorithm(n.algorithm),a=t.createSign(i);a.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const o={key:n.pem};"RSA-PSS"===r.name.toUpperCase()&&(o.padding=t.constants.RSA_PKCS1_PSS_PADDING,o.saltLength=r.saltLength);const c=a.sign(o);return new Uint8Array(c).buffer}static verifySSA(r,n,s,i){const a=this.getCryptoAlgorithm(n.algorithm),o=t.createVerify(a);o.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const c={key:n.pem};"RSA-PSS"===r.name.toUpperCase()&&(c.padding=t.constants.RSA_PKCS1_PSS_PADDING,c.saltLength=r.saltLength);return o.verify(c,i)}static encryptOAEP(e,r,n){const s={key:`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`,padding:t.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(t.publicEncrypt(s,n)).buffer}static decryptOAEP(e,r,n){const s={key:`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`,padding:t.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(t.privateDecrypt(s,n)).buffer}}Ps.publicKeyUsages=["verify","encrypt","wrapKey"],Ps.privateKeyUsages=["sign","decrypt","unwrapKey"];class Is extends Fr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await Ps.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onSign(e,t,r){return Ps.sign(e,cs(t),new Uint8Array(r))}async onVerify(e,t,r,n){return Ps.verify(e,cs(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return Ps.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await Ps.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Ns||r instanceof Us))throw new TypeError("key: Is not RSA CryptoKey")}}class Os extends Gr{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await Ps.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onSign(e,t,r){return Ps.sign(e,cs(t),new Uint8Array(r))}async onVerify(e,t,r,n){return Ps.verify(e,cs(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return Ps.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await Ps.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Ns||r instanceof Us))throw new TypeError("key: Is not RSA CryptoKey")}}class Hs{static size(e){switch(e.name.toUpperCase()){case"SHA-1":return 160;case"SHA-256":case"SHA3-256":return 256;case"SHA-384":case"SHA3-384":return 384;case"SHA-512":case"SHA3-512":return 512;default:throw new Error("Unrecognized name")}}static getAlgorithmName(e){switch(e.name.toUpperCase()){case"SHA-1":return"sha1";case"SHA-256":return"sha256";case"SHA-384":return"sha384";case"SHA-512":return"sha512";case"SHA3-256":return"sha3-256";case"SHA3-384":return"sha3-384";case"SHA3-512":return"sha3-512";default:throw new Error("Unrecognized name")}}static digest(r,n){const s=this.getAlgorithmName(r),i=t.createHash(s).update(e.from(n)).digest();return new Uint8Array(i).buffer}}class Ts extends _r{async onGenerateKey(e,t,r){const n=await Ps.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onEncrypt(r,n,s){const i=cs(n),a=new Uint8Array(s),o=Math.ceil(i.algorithm.modulusLength>>3),c=Hs.size(i.algorithm.hash)>>3,l=a.byteLength,u=o-l-2*c-2;if(l>o-2*c-2)throw new Error("Data too large");const h=new Uint8Array(o),f=h.subarray(1,c+1),p=h.subarray(c+1);p.set(a,c+u+1);const g=t.createHash(i.algorithm.hash.name.replace("-","")).update(y.toUint8Array(r.label||new Uint8Array(0))).digest();p.set(g,0),p[c+u]=1,t.randomFillSync(f);const m=this.mgf1(i.algorithm.hash,f,p.length);for(let e=0;e<p.length;e++)p[e]^=m[e];const d=this.mgf1(i.algorithm.hash,p,f.length);for(let e=0;e<f.length;e++)f[e]^=d[e];i.pem||(i.pem=`-----BEGIN PUBLIC KEY-----\n${i.data.toString("base64")}\n-----END PUBLIC KEY-----`);const w=t.publicEncrypt({key:i.pem,padding:t.constants.RSA_NO_PADDING},e.from(h));return new Uint8Array(w).buffer}async onDecrypt(r,n,s){const i=cs(n),a=Math.ceil(i.algorithm.modulusLength>>3),o=Hs.size(i.algorithm.hash)>>3;if(s.byteLength!==a)throw new Error("Bad data");i.pem||(i.pem=`-----BEGIN PRIVATE KEY-----\n${i.data.toString("base64")}\n-----END PRIVATE KEY-----`);let c=t.privateDecrypt({key:i.pem,padding:t.constants.RSA_NO_PADDING},e.from(s));const l=c[0],u=c.subarray(1,o+1),h=c.subarray(o+1);if(0!==l)throw new Error("Decryption failed");const f=this.mgf1(i.algorithm.hash,h,u.length);for(let e=0;e<u.length;e++)u[e]^=f[e];const p=this.mgf1(i.algorithm.hash,u,h.length);for(let e=0;e<h.length;e++)h[e]^=p[e];const g=t.createHash(i.algorithm.hash.name.replace("-","")).update(y.toUint8Array(r.label||new Uint8Array(0))).digest();for(let e=0;e<o;e++)if(g[e]!==h[e])throw new Error("Decryption failed");let m=o;for(;m<h.length;m++){const e=h[m];if(1===e)break;if(0!==e)throw new Error("Decryption failed")}if(m===h.length)throw new Error("Decryption failed");return c=h.subarray(m+1),new Uint8Array(c).buffer}async onExportKey(e,t){return Ps.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await Ps.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Ns||r instanceof Us))throw new TypeError("key: Is not RSA CryptoKey")}mgf1(e,r,n=0){const s=Hs.size(e)>>3,i=new Uint8Array(n),a=new Uint8Array(4),o=Math.ceil(n/s);for(let n=0;n<o;n++){a[0]=n>>>24,a[1]=n>>>16&255,a[2]=n>>>8&255,a[3]=255&n;const o=i.subarray(n*s);let c=t.createHash(e.name.replace("-","")).update(r).update(a).digest();c.length>o.length&&(c=c.subarray(0,o.length)),o.set(c)}return i}}class Ls extends Tr{constructor(){super(...arguments),this.name="RSAES-PKCS1-v1_5",this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]}}async onGenerateKey(e,t,r){const n=await Ps.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=f.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}async onEncrypt(e,r,n){const s=this.toCryptoOptions(r),i=t.publicEncrypt(s,new Uint8Array(n));return new Uint8Array(i).buffer}async onDecrypt(e,r,n){const s=this.toCryptoOptions(r),i=t.privateDecrypt(s,new Uint8Array(n));return new Uint8Array(i).buffer}async onExportKey(e,t){return Ps.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await Ps.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Ns||r instanceof Us))throw new TypeError("key: Is not RSA CryptoKey")}toCryptoOptions(e){const r=e.type.toUpperCase();return{key:`-----BEGIN ${r} KEY-----\n${cs(e).data.toString("base64")}\n-----END ${r} KEY-----`,padding:t.constants.RSA_PKCS1_PADDING}}}const Ds={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10",brainpoolP160r1:"1.3.36.3.3.2.8.1.1.1","1.3.36.3.3.2.8.1.1.1":"brainpoolP160r1",brainpoolP160t1:"1.3.36.3.3.2.8.1.1.2","1.3.36.3.3.2.8.1.1.2":"brainpoolP160t1",brainpoolP192r1:"1.3.36.3.3.2.8.1.1.3","1.3.36.3.3.2.8.1.1.3":"brainpoolP192r1",brainpoolP192t1:"1.3.36.3.3.2.8.1.1.4","1.3.36.3.3.2.8.1.1.4":"brainpoolP192t1",brainpoolP224r1:"1.3.36.3.3.2.8.1.1.5","1.3.36.3.3.2.8.1.1.5":"brainpoolP224r1",brainpoolP224t1:"1.3.36.3.3.2.8.1.1.6","1.3.36.3.3.2.8.1.1.6":"brainpoolP224t1",brainpoolP256r1:"1.3.36.3.3.2.8.1.1.7","1.3.36.3.3.2.8.1.1.7":"brainpoolP256r1",brainpoolP256t1:"1.3.36.3.3.2.8.1.1.8","1.3.36.3.3.2.8.1.1.8":"brainpoolP256t1",brainpoolP320r1:"1.3.36.3.3.2.8.1.1.9","1.3.36.3.3.2.8.1.1.9":"brainpoolP320r1",brainpoolP320t1:"1.3.36.3.3.2.8.1.1.10","1.3.36.3.3.2.8.1.1.10":"brainpoolP320t1",brainpoolP384r1:"1.3.36.3.3.2.8.1.1.11","1.3.36.3.3.2.8.1.1.11":"brainpoolP384r1",brainpoolP384t1:"1.3.36.3.3.2.8.1.1.12","1.3.36.3.3.2.8.1.1.12":"brainpoolP384t1",brainpoolP512r1:"1.3.36.3.3.2.8.1.1.13","1.3.36.3.3.2.8.1.1.13":"brainpoolP512r1",brainpoolP512t1:"1.3.36.3.3.2.8.1.1.14","1.3.36.3.3.2.8.1.1.14":"brainpoolP512t1"};function Vs(e){const t=Ds[e];if(!t)throw new Ir(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Rs extends ss{constructor(){super(...arguments),this.type="private"}getKey(){const e=ar.parse(this.data,Mn.PrivateKeyInfo);return ar.parse(e.privateKey,Mn.EcPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,Kr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Ir("Cannot get named curve from JWK. Property 'crv' is required");const r=new Mn.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",r.privateKeyAlgorithm.parameters=or.serialize(new Mn.ObjectIdentifier(Vs(t.crv)));const n=xr.fromJSON(t,{targetSchema:Mn.EcPrivateKey});return r.privateKey=or.serialize(n),this.data=e.from(or.serialize(r)),this}}class Ms extends ss{constructor(){super(...arguments),this.type="public"}getKey(){const e=ar.parse(this.data,Mn.PublicKeyInfo);return new Mn.EcPublicKey(e.publicKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,Kr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Ir("Cannot get named curve from JWK. Property 'crv' is required");const r=xr.fromJSON(t,{targetSchema:Mn.EcPublicKey}),n=new Mn.PublicKeyInfo;return n.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1",n.publicKeyAlgorithm.parameters=or.serialize(new Mn.ObjectIdentifier(Vs(t.crv))),n.publicKey=or.toASN(r).valueHex,this.data=e.from(or.serialize(n)),this}}class $s extends Tr{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class Js extends Tr{constructor(){super(...arguments),this.name="SHA-256",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class js extends Tr{constructor(){super(...arguments),this.name="SHA-384",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class zs extends Tr{constructor(){super(...arguments),this.name="SHA-512",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class Fs extends Tr{constructor(){super(...arguments),this.name="SHA3-256",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class Gs extends Tr{constructor(){super(...arguments),this.name="SHA3-384",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class _s extends Tr{constructor(){super(...arguments),this.name="SHA3-512",this.usages=[]}async onDigest(e,t){return Hs.digest(e,t)}}class qs{static async generateKey(e,r,n){const s=new Rs;s.algorithm=e,s.extractable=r,s.usages=n.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const i=new Ms;i.algorithm=e,i.extractable=!0,i.usages=n.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const a=t.generateKeyPairSync("ec",{namedCurve:this.getOpenSSLNamedCurve(e.namedCurve),publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});s.data=a.privateKey,i.data=a.publicKey;return{privateKey:s,publicKey:i}}static async sign(r,n,s){const i=Hs.getAlgorithmName(r.hash),a=t.createSign(i);a.update(e.from(s)),n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const o={key:n.pem},c=a.sign(o),l=ar.parse(c,Mn.EcDsaSignature);return pn.encodeSignature(l,$n.get(n.algorithm.namedCurve).size).buffer}static async verify(r,n,s,i){const a=Hs.getAlgorithmName(r.hash),o=t.createVerify(a);o.update(e.from(i)),n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const c={key:n.pem},l=new Mn.EcDsaSignature,u=$n.get(n.algorithm.namedCurve),h=pn.decodeSignature(s,u.size);l.r=y.toArrayBuffer(h.r),l.s=y.toArrayBuffer(h.s);const f=e.from(or.serialize(l));return o.verify(c,f)}static async deriveBits(r,n,s){const i=this.getOpenSSLNamedCurve(n.algorithm.namedCurve),a=t.createECDH(i),o=ar.parse(n.data,Mn.PrivateKeyInfo),c=ar.parse(o.privateKey,Mn.EcPrivateKey);a.setPrivateKey(e.from(c.privateKey));const l=ar.parse(r.public.data,Mn.PublicKeyInfo),u=a.computeSecret(e.from(l.publicKey));return null===s?u:new Uint8Array(u).buffer.slice(0,s>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return Kr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return ar.parse(t.data,Mn.PublicKeyInfo).publicKey;default:throw new Ir("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":if(t.d){const e=xr.fromJSON(t,{targetSchema:Mn.EcPrivateKey});return this.importPrivateKey(e,r,n,s)}{const e=xr.fromJSON(t,{targetSchema:Mn.EcPublicKey});return this.importPublicKey(e,r,n,s)}case"raw":{const e=new Mn.EcPublicKey(t);return this.importPublicKey(e,r,n,s)}case"spki":{const e=ar.parse(new Uint8Array(t),Mn.PublicKeyInfo),i=new Mn.EcPublicKey(e.publicKey);return this.assertKeyParameters(e.publicKeyAlgorithm.parameters,r.namedCurve),this.importPublicKey(i,r,n,s)}case"pkcs8":{const e=ar.parse(new Uint8Array(t),Mn.PrivateKeyInfo),i=ar.parse(e.privateKey,Mn.EcPrivateKey);return this.assertKeyParameters(e.privateKeyAlgorithm.parameters,r.namedCurve),this.importPrivateKey(i,r,n,s)}default:throw new Ir("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static assertKeyParameters(e,t){if(!e)throw new Nr("Key info doesn't have required parameters");let r="";try{r=ar.parse(e,Mn.ObjectIdentifier).value}catch(e){throw new Nr("Cannot read key info parameters")}if(Vs(t)!==r)throw new Nr("Key info parameter doesn't match to named curve")}static async importPrivateKey(t,r,n,s){const i=new Mn.PrivateKeyInfo;i.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",i.privateKeyAlgorithm.parameters=or.serialize(new Mn.ObjectIdentifier(Vs(r.namedCurve))),i.privateKey=or.serialize(t);const a=new Rs;return a.data=e.from(or.serialize(i)),a.algorithm=Object.assign({},r),a.extractable=n,a.usages=s,a}static async importPublicKey(t,r,n,s){const i=new Mn.PublicKeyInfo;i.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1";const a=Vs(r.namedCurve);i.publicKeyAlgorithm.parameters=or.serialize(new Mn.ObjectIdentifier(a)),i.publicKey=t.value;const o=new Ms;return o.data=e.from(or.serialize(i)),o.algorithm=Object.assign({},r),o.extractable=n,o.usages=s,o}static getOpenSSLNamedCurve(e){switch(e.toUpperCase()){case"P-256":return"prime256v1";case"K-256":return"secp256k1";case"P-384":return"secp384r1";case"P-521":return"secp521r1";default:return e}}}qs.publicKeyUsages=["verify"],qs.privateKeyUsages=["sign","deriveKey","deriveBits"];class Ws extends Wr{constructor(){super(...arguments),this.namedCurves=$n.names,this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const n=await qs.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onSign(e,t,r){return qs.sign(e,cs(t),new Uint8Array(r))}async onVerify(e,t,r,n){return qs.verify(e,cs(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return qs.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await qs.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Rs||r instanceof Ms))throw new TypeError("key: Is not EC CryptoKey")}}class Ys extends Zr{constructor(){super(...arguments),this.namedCurves=$n.names}async onGenerateKey(e,t,r){const n=await qs.generateKey({...e,name:this.name},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onExportKey(e,t){return qs.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await qs.importKey(e,t,{...r,name:this.name},n,s))}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=cs(e);if(!(r instanceof Rs||r instanceof Ms))throw new TypeError("key: Is not EC CryptoKey")}async onDeriveBits(e,t,r){return await qs.deriveBits({...e,public:cs(e.public)},cs(t),r)}}const Xs={[Mn.idEd448]:"Ed448",ed448:Mn.idEd448,[Mn.idX448]:"X448",x448:Mn.idX448,[Mn.idEd25519]:"Ed25519",ed25519:Mn.idEd25519,[Mn.idX25519]:"X25519",x25519:Mn.idX25519};function Zs(e){const t=Xs[e.toLowerCase()];if(!t)throw new Ir(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Qs extends ss{constructor(){super(...arguments),this.type="private"}getKey(){const e=ar.parse(this.data,Mn.PrivateKeyInfo);return ar.parse(e.privateKey,Mn.CurvePrivateKey)}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,Kr.toJSON(e))}fromJSON(t){if(!t.crv)throw new Ir("Cannot get named curve from JWK. Property 'crv' is required");const r=new Mn.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm=Zs(t.crv);const n=xr.fromJSON(t,{targetSchema:Mn.CurvePrivateKey});return r.privateKey=or.serialize(n),this.data=e.from(or.serialize(r)),this}}class ei extends ss{constructor(){super(...arguments),this.type="public"}getKey(){return ar.parse(this.data,Mn.PublicKeyInfo).publicKey}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,{x:f.ToBase64Url(e)})}fromJSON(t){if(!t.crv)throw new Ir("Cannot get named curve from JWK. Property 'crv' is required");if(!t.x)throw new Ir("Cannot get property from JWK. Property 'x' is required");const r=new Mn.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm=Zs(t.crv),r.publicKey=f.FromBase64Url(t.x),this.data=e.from(or.serialize(r)),this}}class ti{static async generateKey(e,r,n){const s=new Qs;s.algorithm=e,s.extractable=r,s.usages=n.filter((e=>-1!==this.privateKeyUsages.indexOf(e)));const i=new ei;i.algorithm=e,i.extractable=!0,i.usages=n.filter((e=>-1!==this.publicKeyUsages.indexOf(e)));const a=e.namedCurve.toLowerCase(),o=t.generateKeyPairSync(a,{publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});s.data=o.privateKey,i.data=o.publicKey;return{privateKey:s,publicKey:i}}static async sign(r,n,s){n.pem||(n.pem=`-----BEGIN PRIVATE KEY-----\n${n.data.toString("base64")}\n-----END PRIVATE KEY-----`);const i={key:n.pem},a=t.sign(null,e.from(s),i);return y.toArrayBuffer(a)}static async verify(r,n,s,i){n.pem||(n.pem=`-----BEGIN PUBLIC KEY-----\n${n.data.toString("base64")}\n-----END PUBLIC KEY-----`);const a={key:n.pem};return t.verify(null,e.from(i),a,e.from(s))}static async deriveBits(e,r,n){const s=t.createPublicKey({key:e.public.data,format:"der",type:"spki"}),i=t.createPrivateKey({key:r.data,format:"der",type:"pkcs8"}),a=t.diffieHellman({publicKey:s,privateKey:i});return new Uint8Array(a).buffer.slice(0,n>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return Kr.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return ar.parse(t.data,Mn.PublicKeyInfo).publicKey;default:throw new Ir("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,n,s){switch(e.toLowerCase()){case"jwk":{const e=t;if(e.d){const e=xr.fromJSON(t,{targetSchema:Mn.CurvePrivateKey});return this.importPrivateKey(e,r,n,s)}if(!e.x)throw new TypeError("keyData: Cannot get required 'x' filed");return this.importPublicKey(f.FromBase64Url(e.x),r,n,s)}case"raw":return this.importPublicKey(t,r,n,s);case"spki":{const e=ar.parse(new Uint8Array(t),Mn.PublicKeyInfo);return this.importPublicKey(e.publicKey,r,n,s)}case"pkcs8":{const e=ar.parse(new Uint8Array(t),Mn.PrivateKeyInfo),i=ar.parse(e.privateKey,Mn.CurvePrivateKey);return this.importPrivateKey(i,r,n,s)}default:throw new Ir("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static importPrivateKey(e,t,r,n){const s=new Qs;return s.fromJSON({crv:t.namedCurve,d:f.ToBase64Url(e.d)}),s.algorithm=Object.assign({},t),s.extractable=r,s.usages=n,s}static async importPublicKey(e,t,r,n){const s=new ei;return s.fromJSON({crv:t.namedCurve,x:f.ToBase64Url(e)}),s.algorithm=Object.assign({},t),s.extractable=r,s.usages=n,s}}ti.publicKeyUsages=["verify"],ti.privateKeyUsages=["sign","deriveKey","deriveBits"];class ri extends en{async onGenerateKey(e,t,r){const n=await ti.generateKey({name:this.name,namedCurve:e.namedCurve.replace(/^ed/i,"Ed")},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onSign(e,t,r){return ti.sign(e,cs(t),new Uint8Array(r))}async onVerify(e,t,r,n){return ti.verify(e,cs(t),new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){return ti.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await ti.importKey(e,t,{...r,name:this.name},n,s))}}class ni extends Qr{async onGenerateKey(e,t,r){const n=await ti.generateKey({name:this.name,namedCurve:e.namedCurve.toUpperCase()},t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onDeriveBits(e,t,r){return await ti.deriveBits({...e,public:cs(e.public)},cs(t),r)}async onExportKey(e,t){return ti.exportKey(e,cs(t))}async onImportKey(e,t,r,n,s){return ls(await ti.importKey(e,t,{...r,name:this.name},n,s))}}class si extends rs{constructor(t,r,n,s){super(),this.algorithm=t,this.extractable=r,this.usages=n,this.data=e.from(s)}toJWK(){return{kty:"OKP",crv:this.algorithm.name,key_ops:this.usages,ext:this.extractable}}}class ii extends si{constructor(){super(...arguments),this.type="private"}toJWK(){const r=t.createPublicKey({key:this.data,format:"pem"}).export({format:"jwk"}),n=Hr.toUint8Array(this.data.toString()),s=cr.parse(n,Mn.PrivateKeyInfo),i=cr.parse(s.privateKey,Mn.EdPrivateKey).value;return{...super.toJWK(),...r,d:e.from(new Uint8Array(i)).toString("base64url")}}}class ai extends si{constructor(){super(...arguments),this.type="public"}toJWK(){const e=t.createPublicKey({key:this.data,format:"pem"}).export({format:"jwk"});return{...super.toJWK(),...e}}}class oi{static async generateKey(e,r,n){const s=e.name.toLowerCase(),i=t.generateKeyPairSync(s,{publicKeyEncoding:{format:"pem",type:"spki"},privateKeyEncoding:{format:"pem",type:"pkcs8"}}),a={name:"ed25519"===s?"Ed25519":"X25519"},o=n.filter((e=>this.privateKeyUsages.includes(e))),c=n.filter((e=>this.publicKeyUsages.includes(e)));return{privateKey:new ii(a,r,o,i.privateKey),publicKey:new ai(a,!0,c,i.publicKey)}}static async sign(r,n,s){const i=t.sign(null,e.from(s),n.data);return y.toArrayBuffer(i)}static async verify(r,n,s,i){return t.verify(null,e.from(i),n.data,s)}static async exportKey(e,t){switch(e){case"jwk":return t.toJWK();case"pkcs8":case"spki":return Hr.toArrayBuffer(t.data.toString());case"raw":{const e=t.toJWK();return f.FromBase64Url(e.x)}default:return Promise.reject(new Ir("format: Must be 'jwk', 'raw', pkcs8' or 'spki'"))}}static async importKey(r,n,s,i,a){switch(r){case"jwk":{const r=n;if(r.d){const t=new Mn.EdPrivateKey;t.value=y.toArrayBuffer(e.from(r.d,"base64url"));const n=new Mn.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="ed25519"===s.name.toLowerCase()?Mn.idEd25519:Mn.idX25519,n.privateKey=cr.serialize(t);const o=cr.serialize(n),c=Hr.fromBufferSource(o,"PRIVATE KEY");return new ii(s,i,a,c)}if(r.x){const e=t.createPublicKey({format:"jwk",key:r}).export({format:"pem",type:"spki"});return new ai(s,i,a,e)}throw new Ir("keyData: Cannot import JWK. 'd' or 'x' must be presented")}case"pkcs8":{const e=Hr.fromBufferSource(n,"PRIVATE KEY");return new ii(s,i,a,e)}case"spki":{const e=Hr.fromBufferSource(n,"PUBLIC KEY");return new ai(s,i,a,e)}case"raw":{const e=n,r=t.createPublicKey({format:"jwk",key:{kty:"OKP",crv:"ed25519"===s.name.toLowerCase()?"Ed25519":"X25519",x:f.ToBase64Url(e)}}).export({format:"pem",type:"spki"});return new ai(s,i,a,r)}default:return Promise.reject(new Ir("format: Must be 'jwk', 'raw', pkcs8' or 'spki'"))}}}oi.privateKeyUsages=["sign","deriveBits","deriveKey"],oi.publicKeyUsages=["verify"];class ci extends jn{async onGenerateKey(e,t,r){const n=await oi.generateKey(e,t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onSign(e,t,r){const n=cs(t);return oi.sign(e,n,new Uint8Array(r))}onVerify(e,t,r,n){const s=cs(t);return oi.verify(e,s,new Uint8Array(r),new Uint8Array(n))}async onExportKey(e,t){const r=cs(t);return oi.exportKey(e,r)}async onImportKey(e,t,r,n,s){return ls(await oi.importKey(e,t,r,n,s))}}class li extends Jn{async onGenerateKey(e,t,r){const n=await oi.generateKey(e,t,r);return{privateKey:ls(n.privateKey),publicKey:ls(n.publicKey)}}async onDeriveBits(e,r,n){const s=cs(r),i=cs(e.public),a=t.createPublicKey({key:i.data.toString(),format:"pem",type:"spki"}),o=t.createPrivateKey({key:s.data.toString(),format:"pem",type:"pkcs8"}),c=t.diffieHellman({publicKey:a,privateKey:o});return new Uint8Array(c).buffer.slice(0,n>>3)}async onExportKey(e,t){const r=cs(t);return oi.exportKey(e,r)}async onImportKey(e,t,r,n,s){return ls(await oi.importKey(e,t,r,n,s))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof si))throw new TypeError("key: Is not a Ed25519CryptoKey")}}class ui extends rs{}class hi extends Fn{async onDeriveBits(r,n,s){return new Promise(((i,a)=>{const o=y.toArrayBuffer(r.salt),c=r.hash.name.replace("-","");t.pbkdf2(cs(n).data,e.from(o),r.iterations,s>>3,c,((e,t)=>{e?a(e):i(new Uint8Array(t).buffer)}))}))}async onImportKey(t,r,n,s,i){if("raw"===t){const t=new ui;return t.data=e.from(r),t.algorithm={name:this.name},t.extractable=!1,t.usages=i,ls(t)}throw new Ir("format: Must be 'raw'")}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof ui))throw new TypeError("key: Is not PBKDF CryptoKey")}}class yi extends rs{get alg(){return`HS${this.algorithm.hash.name.toUpperCase().replace("SHA-","")}`}set alg(e){}}n([Cr({name:"k",converter:ts})],yi.prototype,"data",void 0);class fi extends zn{async onGenerateKey(e,r,n){const s=(e.length||this.getDefaultLength(e.hash.name))>>3<<3,i=new yi;return i.algorithm={...e,length:s,name:this.name},i.extractable=r,i.usages=n,i.data=t.randomBytes(s>>3),ls(i)}async onSign(r,n,s){const i=Hs.getAlgorithmName(n.algorithm.hash),a=t.createHmac(i,cs(n).data).update(e.from(s)).digest();return new Uint8Array(a).buffer}async onVerify(r,n,s,i){const a=Hs.getAlgorithmName(n.algorithm.hash);return 0===t.createHmac(a,cs(n).data).update(e.from(i)).digest().compare(e.from(s))}async onImportKey(t,r,n,s,i){let a;switch(t.toLowerCase()){case"jwk":a=xr.fromJSON(r,{targetSchema:yi});break;case"raw":a=new yi,a.data=e.from(r);break;default:throw new Ir("format: Must be 'jwk' or 'raw'")}return a.algorithm={hash:{name:n.hash.name},name:this.name,length:a.data.length<<3},a.extractable=s,a.usages=i,ls(a)}async onExportKey(e,t){switch(e.toLowerCase()){case"jwk":return Kr.toJSON(cs(t));case"raw":return new Uint8Array(cs(t).data).buffer;default:throw new Ir("format: Must be 'jwk' or 'raw'")}}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof yi))throw new TypeError("key: Is not HMAC CryptoKey")}}class pi extends rs{}class gi extends Gn{async onImportKey(t,r,n,s,i){if("raw"!==t.toLowerCase())throw new Ir("Operation not supported");const a=new pi;return a.data=e.from(r),a.algorithm={name:this.name},a.extractable=s,a.usages=i,ls(a)}async onDeriveBits(r,n,s){const i=r.hash.name.replace("-",""),a=t.createHash(i).digest().length,o=s/8,c=y.toUint8Array(r.info),l=t.createHmac(i,y.toUint8Array(r.salt)).update(y.toUint8Array(cs(n).data)).digest(),u=[e.alloc(0)],h=Math.ceil(o/a)+1;for(let r=1;r<h;++r)u.push(t.createHmac(i,l).update(e.concat([u[r-1],c,e.from([r])])).digest());return e.concat(u).slice(0,o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(cs(e)instanceof pi))throw new TypeError("key: Is not HKDF CryptoKey")}}class mi{static digest(r,n){const s=t.createHash(r.name.toLowerCase(),{outputLength:r.length}).update(e.from(n)).digest();return new Uint8Array(s).buffer}}class di extends qn{async onDigest(e,t){return mi.digest(e,t)}}class wi extends Wn{async onDigest(e,t){return mi.digest(e,t)}}class vi extends es{constructor(){var e;super(),this.providers.set(new us),this.providers.set(new As),this.providers.set(new bs),this.providers.set(new vs),this.providers.set(new ks),this.providers.set(new Ss);t.getCiphers().includes("des-cbc")&&this.providers.set(new Ks),this.providers.set(new xs),this.providers.set(new Is),this.providers.set(new Os),this.providers.set(new Ts),this.providers.set(new Ls),this.providers.set(new Ws),this.providers.set(new Ys),this.providers.set(new $s),this.providers.set(new Js),this.providers.set(new js),this.providers.set(new zs),this.providers.set(new hi),this.providers.set(new fi),this.providers.set(new gi);const n=null===(e=/^v(\d+)/.exec(r))||void 0===e?void 0:e[1];n&&parseInt(n,10)>=12&&(this.providers.set(new di),this.providers.set(new wi));const s=t.getHashes();s.includes("sha3-256")&&this.providers.set(new Fs),s.includes("sha3-384")&&this.providers.set(new Gs),s.includes("sha3-512")&&this.providers.set(new _s),n&&parseInt(n,10)>=14&&(this.providers.set(new ri),this.providers.set(new ni),this.providers.set(new ci),this.providers.set(new li))}}class Ai extends Yn{constructor(){super(...arguments),this.subtle=new vi}getRandomValues(r){if(!ArrayBuffer.isView(r))throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");const n=e.from(r.buffer,r.byteOffset,r.byteLength);return t.randomFillSync(n),r}}export{Ai as Crypto,Xr as CryptoKey};
