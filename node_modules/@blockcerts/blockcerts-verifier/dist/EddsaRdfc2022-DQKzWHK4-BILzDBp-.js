import{d as e,f as i,V as t}from"./main.js";import{D as o,r}from"./DataIntegrityProof-elCNKq16-DBDuaDNt.js";import{j as n}from"./jsonld-B_Q2jvnp-BJ5uVeOU.js";import{E as s,f as a}from"./ed25519-key-pair.esm-DPOFpdJ2-BrwuS0Ia.js";import{j as c}from"./jsonld-signatures-BbILf-Q7-DTp6__ud.js";import{S as d}from"./Suite-BmP2Qu19-D1ucdMDB.js";import{j as h}from"./keyUtils-ExMI0fmg-NVOmd8LH.js";import"./tslib.es6--gQC4x5c-CmLYFWVC.js";import"./x25519-Kp6t9B5a-Dh8L0KYb.js";import"./elliptic-BYqApR8Y-CKp7atgR.js";import"./index-DZLKRa_V-D_IQzjvG.js";import"./base64url-Cy03LJLt-vkTPfQOh.js";import"./_commonjs-dynamic-modules-COweQ1RR-BHR_E30J.js";import"./elliptic-4aZS_cwf-BpaNaVm0.js";
/*!
 * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */
const f={canonize:async function(e,i){i={algorithm:"RDFC-1.0",format:"application/n-quads",base:null,safe:!0,...i};const t={rdfDirection:"i18n-datatype",...i,produceGeneralizedRdf:!1};delete t.format;const o=await n.toRDF(e,t);return r.canonize(o,i)}
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */,createVerifier:async function({verificationMethod:e}){return(await a(e)).verifier()},name:"eddsa-rdfc-2022",requiredAlgorithm:"Ed25519"},{purposes:{AssertionProofPurpose:u,AuthenticationProofPurpose:p}}=c;
/*!
 * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
 */var l;!function(e){e.retrieveVerificationMethodPublicKey="retrieveVerificationMethodPublicKey",e.ensureVerificationMethodValidity="ensureVerificationMethodValidity",e.checkDocumentSignature="checkDocumentSignature"}(l||(l={}));class y extends d{verificationProcess=[l.retrieveVerificationMethodPublicKey,l.ensureVerificationMethodValidity,l.checkDocumentSignature];documentToVerify;issuer;proof;type="EddsaRdfc2022";cryptosuite="eddsa-rdfc-2022";verificationKey;verificationMethod;publicKey;proofPurpose;challenge;domain;proofPurposeMap;constructor(e){super(e),e.executeStep&&(this.executeStep=e.executeStep),this.documentToVerify=e.document,this.issuer=e.issuer,this.proof=e.proof,this.proofPurpose=e.proofPurpose??"assertionMethod",this.challenge=e.proofChallenge??"",this.domain=e.proofDomain,this.proofPurposeMap={authentication:p,assertionMethod:u},this.validateProofType()}async init(){}async verifyProof(){for(const e of this.verificationProcess){if(!this[e])return void console.error("verification logic for",e,"not implemented");await this[e]()}}async verifyIdentity(){}getProofVerificationSteps(i){return this.verificationProcess.map((t=>e.verifier.convertToVerificationSubsteps(i,t)))}getIdentityVerificationSteps(){return[]}getIssuerPublicKey(){return this.publicKey}getIssuerName(){return this.issuer.name??""}getIssuerProfileDomain(){try{return new URL(this.getIssuerProfileUrl()).hostname??""}catch(e){return""}}getIssuerProfileUrl(){return this.issuer.id??""}getSigningDate(){return this.proof.created}async executeStep(e,i,t){throw new Error("doAction method needs to be overwritten by injecting from CVJS")}async publicKeyJwkToString(e){return await s.fingerprintFromPublicKey(e)}validateProofType(){const e=this.isProofChain()?this.proof.chainedProofType:this.proof.type;if("DataIntegrityProof"!==e){if(e!==this.type)throw new Error(`Incompatible proof type passed. Expected: ${this.type}, Got: ${e}`)}else{const e=this.proof.cryptosuite;if(!e)throw new Error(`Malformed proof passed. With DataIntegrityProof a cryptosuite must be defined. Expected: ${this.cryptosuite}`);if(e!==this.cryptosuite)throw new Error(`Incompatible proof cryptosuite passed. Expected: ${this.cryptosuite}, Got: ${e}`)}}isProofChain(){return"ChainedProof2021"===this.proof.type}generateDocumentLoader(){i[this.documentToVerify.issuer]=this.issuer.didDocument,i[this.proof.verificationMethod]=this.getMultikeyRepresentation();return function(e){return e in i?{contextUrl:null,document:i[e],documentUrl:e}:n.documentLoader(e)}}getErrorMessage(e){return e.error.errors[0].message}getTargetVerificationMethodContainer(){if(this.issuer.didDocument){if(this.findVerificationMethod(this.issuer.didDocument.verificationMethod,this.issuer.didDocument.id))return this.issuer.didDocument}const e={...this.issuer};return delete e.didDocument,e}findVerificationMethod(e,i){return e.find((e=>e.id===this.proof.verificationMethod||i+e.id===this.proof.verificationMethod))??null}getMultikeyRepresentation(){return{"@context":"https://w3id.org/security/multikey/v1",type:"Multikey",publicKeyMultibase:h(this.verificationMethod.publicKeyJwk),id:"string"==typeof this.verificationMethod.id?this.verificationMethod.id:void 0,controller:"string"==typeof this.verificationMethod.controller?this.verificationMethod.controller:void 0}}async retrieveVerificationMethodPublicKey(){this.verificationKey=await this.executeStep(l.retrieveVerificationMethodPublicKey,(async()=>{const e=this.getTargetVerificationMethodContainer();if(!e)throw new t(l.retrieveVerificationMethodPublicKey,"The verification method of the document does not match the provided issuer.");if(this.verificationMethod=this.findVerificationMethod(e.verificationMethod,e.id),!this.verificationMethod)throw new t(l.retrieveVerificationMethodPublicKey,"The verification method of the document does not match the provided issuer.");try{this.publicKey=this.verificationMethod.publicKeyMultibase??await this.publicKeyJwkToString(this.verificationMethod)}catch(e){console.error("ERROR retrieving Ed25519Signature2020 public key",e)}const i=await a({...this.verificationMethod});if(!i)throw new t(l.retrieveVerificationMethodPublicKey,"Could not derive the verification key");if(i.revoked)throw new t(l.retrieveVerificationMethodPublicKey,"The verification key has been revoked");return i}),this.type)}async ensureVerificationMethodValidity(){await this.executeStep(l.ensureVerificationMethodValidity,(async()=>{if(this.verificationMethod.expires){if(new Date(this.verificationMethod.expires).getTime()<Date.now())throw new t(l.ensureVerificationMethodValidity,"The verification key has expired")}if(this.verificationMethod.revoked)throw new t(l.ensureVerificationMethodValidity,"The verification key has been revoked")}),this.type)}async checkDocumentSignature(){await this.executeStep(l.checkDocumentSignature,(async()=>{const e=new o({cryptosuite:f}),i=await c.verify(this.documentToVerify,{suite:e,purpose:new this.proofPurposeMap[this.proofPurpose]({controller:this.getTargetVerificationMethodContainer(),challenge:this.challenge,domain:this.domain}),documentLoader:this.generateDocumentLoader()});if(!i.verified)throw console.error(JSON.stringify(i,null,2)),new t(l.checkDocumentSignature,`The document's ${this.type} signature could not be confirmed: ${this.getErrorMessage(i)}`);console.log("Credential EddsaRdfc2022 signature successfully verified")}),this.type)}}export{y as default};
