{"version":3,"sources":["webpack://credentialHandlerPolyfill/webpack/universalModuleDefinition","webpack://credentialHandlerPolyfill/webpack/bootstrap","webpack://credentialHandlerPolyfill/./CredentialHandler.js","webpack://credentialHandlerPolyfill/./CredentialHandlerRegistration.js","webpack://credentialHandlerPolyfill/./CredentialHandlerService.js","webpack://credentialHandlerPolyfill/./CredentialHandlers.js","webpack://credentialHandlerPolyfill/./CredentialHints.js","webpack://credentialHandlerPolyfill/./CredentialManager.js","webpack://credentialHandlerPolyfill/./CredentialRequestEvent.js","webpack://credentialHandlerPolyfill/./CredentialStoreEvent.js","webpack://credentialHandlerPolyfill/./CredentialsContainer.js","webpack://credentialHandlerPolyfill/./PermissionManager.js","webpack://credentialHandlerPolyfill/./WebCredential.js","webpack://credentialHandlerPolyfill/./index.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/Client.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/EventEmitter.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/Server.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebApp.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebAppContext.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebAppWindow.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebAppWindowDialog.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebAppWindowInlineDialog.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/WebAppWindowPopupDialog.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/index.js","webpack://credentialHandlerPolyfill/./node_modules/web-request-rpc/utils.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEwC;;AAEkB;;AAEvE;;AAEO,gCAAgC,sDAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,gDAAgD,qFAAwB;;AAExE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACa;;AAE4C;;AAElD;AACP;AACA;AACA;AACA;AACA,iCAAiC,uEAAiB;AAClD;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmE;AACJ;;AAE/D;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,iFAAsB;AAChC,SAAS,2CAA2C;AACpD;;AAEA;AACA;AACA;AACA,UAAU,6EAAoB;AAC9B,SAAS,2CAA2C;AACpD;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AACA;AACA;AAE4C;;AAErC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+FAA6B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+FAA6B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACqD;;AAErD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,qBAAqB,mEAAe;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,0BAA0B;AACjC;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEgC;;AAE7C,+BAA+B;AAC/B,qDAAqD;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEgC;;AAE7C,+BAA+B;AAC/B,qDAAqD;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEoC;;AAEjD;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB,iCAAiC;AACnE,WAAW,yBAAyB;AACpC;AACA,OAAO;AACP,KAAK;AACL;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,+DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B,qCAAqC;AAC3E;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,+BAA+B,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAC8C;;AAEW;AACE;AACF;AACM;AACN;AACR;;AAEjD;;AAEA;AAKE;;AAEF;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB,uBAAuB;AAC5C,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,6DAAa;AACtC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,6BAA6B,uEAAiB;AAC9C,oCAAoC,yEAAkB;AACtD,+BAA+B,uEAAiB;AAChD,+BAA+B,uEAAiB;AAChD,6BAA6B,6EAAoB;;AAEjD,2BAA2B,+DAAa;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,uEAAiB;AAC9C,yBAAyB,+DAAa;;AAEtC;AACA;;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAAA;AACA;AACA;AACa;;AAEuB;;AAEpC;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,kDAAc;AAChC;;AAEA;AACA,qBAAqB,+DAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA,eAAe,0DAAsB;AACrC;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,gDAAY;AACtB;AACA;AACA;;AAEA;AACA;AACA,OAAO,yDAAqB;AAC5B;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAkD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;;;;;;;;;;;;;AC3NA;AAAA;AAAA;AACA;AACA;AACa;;AAEN;AACP,eAAe,iDAAiD,KAAK;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AACA;AACA;AACa;;AAEuB;;AAE7B;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,kDAAc;AAChC;;AAEA;;AAEA,qBAAqB,+DAA2B;AAChD;AACA;AACA;AACA;AACA,eAAe,aAAa,GAAG,+DAA2B;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,6BAA6B,wDAAoB;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAqB;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,oDAAgB;AAC7C;AACA;AACA;AACA,KAAK,yDAAqB;AAC1B;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AC9IA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACa;;AAEsB;AACA;AACC;;AAE7B;AACP;AACA;AACA;AACA,yBAAyB,0DAAQ;AACjC;AACA;AACA,sBAAsB,iDAAM;AAC5B,sBAAsB,iDAAM;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmC;AACA;AACY;AACX;;AAEpC;AACA;;AAEO;AACP;AACA,sBAAsB,iDAAM;AAC5B,sBAAsB,iDAAM;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,6DAA6D,WAAW;;AAExE,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA,mBAAmB,0DAAQ;AAC3B;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACuE;AACF;;AAErE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mFAAuB,EAAE,oBAAoB;AACvE,OAAO;AACP,0BAA0B,qFAAwB,EAAE,uBAAuB;AAC3E;AACA,KAAK;AACL;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AACA;AACA;AAC2D;;AAEpD,uCAAuC,yEAAkB;AAChE,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AACA;AACA;AAC2D;;AAEpD,sCAAsC,yEAAkB;AAC/D,eAAe,uBAAuB,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC,WAAW,KAAK;AAChB,SAAS,0BAA0B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM,UAAU,OAAO,QAAQ,KAAK,OAAO,IAAI;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,WAAW;;AAEvE,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACa;;AAEsB;AACY;AACZ;AACA;AACc;AACF;;AAEX;AACrB;;;;;;;;;;;;;ACff;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEN;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACO;AACP,aAAa,OAAO,kEAAkE;AACtF;;AAEO;AACP;AACA;AACA,+BAA+B,IAAI,gCAAgC,OAAO;AAC1E;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,GAAG,wCAAwC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA","file":"credential-handler-polyfill.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"credentialHandlerPolyfill\"] = factory();\n\telse\n\t\troot[\"credentialHandlerPolyfill\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","/*!\n * The core CredentialHandler class.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n/* global DOMException */\n'use strict';\n\nimport {EventEmitter, WebApp} from 'web-request-rpc';\n\nimport {CredentialHandlerService} from './CredentialHandlerService.js';\n\nconst EVENT_TYPES = ['credentialrequest', 'credentialstore'];\n\nexport class CredentialHandler extends WebApp {\n  constructor(mediatorOrigin, inline = false) {\n    if(typeof mediatorOrigin !== 'string') {\n      throw new TypeError('\"mediatorOrigin\" must be a string.');\n    }\n    super(mediatorOrigin, inline);\n    this._emitter = new EventEmitter({\n      async waitUntil(event) {\n        // TODO: may need to do `this.hide()` after this promise resolves\n        //   to handle case where e.openWindow() was called\n        return event._promise || Promise.reject(\n          new DOMException(\n            'No \"credentialrequest\" event handler found.', 'NotFoundError'));\n      }\n    });\n  }\n\n  async connect() {\n    const injector = await super.connect();\n\n    // define API that CredentialMediator can call on this credential handler\n    this.server.define('credentialHandler', new CredentialHandlerService(this));\n\n    // auto-call `ready`\n    await this.ready();\n\n    return injector;\n  }\n\n  addEventListener(eventType, fn) {\n    if(!EVENT_TYPES.includes(eventType)) {\n      throw new DOMException(\n        `Unsupported event type \"${eventType}\"`, 'NotSupportedError');\n    }\n    return this._emitter.addEventListener(eventType, fn);\n  }\n\n  removeEventListener(eventType, fn) {\n    if(!EVENT_TYPES.includes(eventType)) {\n      throw new DOMException(\n        `Unsupported event type \"${eventType}\"`, 'NotSupportedError');\n    }\n    return this._emitter.removeEventListener(eventType, fn);\n  }\n}\n","/*!\n * A CredentialHandlerRegistration provides a CredentialManager to enable Web\n * apps to register Profiles that can be presented to websites.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport {CredentialManager} from './CredentialManager.js';\n\nexport class CredentialHandlerRegistration {\n  constructor(url, injector) {\n    if(!(url && typeof url === 'string')) {\n      throw new TypeError('\"url\" must be a non-empty string.');\n    }\n    this.credentialManager = new CredentialManager(url, injector);\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {CredentialRequestEvent} from './CredentialRequestEvent.js';\nimport {CredentialStoreEvent} from './CredentialStoreEvent.js';\n\n/* A CredentialHandlerService handles remote calls to a CredentialHandler. */\nexport class CredentialHandlerService {\n  constructor(credentialHandler) {\n    this._credentialHandler = credentialHandler;\n  }\n\n  async request(credentialRequestEvent) {\n    // TODO: validate credentialRequestEvent\n    return await this._credentialHandler._emitter.emit(\n      new CredentialRequestEvent(Object.assign(\n        {credentialHandler: this._credentialHandler}, credentialRequestEvent)));\n  }\n\n  async store(credentialStoreEvent) {\n    // TODO: validate credentialStoreEvent\n    return await this._credentialHandler._emitter.emit(\n      new CredentialStoreEvent(Object.assign(\n        {credentialHandler: this._credentialHandler}, credentialStoreEvent)));\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {CredentialHandlerRegistration}\n  from './CredentialHandlerRegistration.js';\n\nexport class CredentialHandlers {\n  constructor(injector) {\n    this._init = (async () => {\n      this._injector = await injector;\n      this._remote = this._injector.get('credentialHandlers', {\n        functions: [\n          'register', 'unregister', 'getRegistration', 'hasRegistration']\n      });\n    })();\n  }\n\n  /**\n   * Creates a credential handler registration.\n   *\n   * @param url the unique URL for the credential handler.\n   *\n   * @return a Promise that resolves to the CredentialHandlerRegistration.\n   */\n  async register(url) {\n    this._deprecateNotice();\n    await this._init;\n    // register with credential mediator\n    url = await this._remote.register('credential', url);\n    return new CredentialHandlerRegistration(url, this._injector);\n  }\n\n  /**\n   * Unregisters a credential handler, destroying its registration.\n   *\n   * @param url the unique URL for the credential handler.\n   *\n   * @return a Promise that resolves to `true` if the handler was registered\n   *           and `false` if not.\n   */\n  async unregister(url) {\n    this._deprecateNotice();\n    await this._init;\n    // unregister with credential mediator\n    return this._remote.unregister('credential', url);\n  }\n\n  /**\n   * Gets an existing credential handler registration.\n   *\n   * @param url the URL for the credential handler.\n   *\n   * @return a Promise that resolves to the CredentialHandlerRegistration or\n   *           `null` if no such registration exists.\n   */\n  async getRegistration(url) {\n    this._deprecateNotice();\n    await this._init;\n    url = await this._remote.getRegistration('credential', url);\n    if(!url) {\n      return null;\n    }\n    return new CredentialHandlerRegistration(url, this._injector);\n  }\n\n  /**\n   * Returns true if the given credential handler has been registered and\n   * false if not.\n   *\n   * @param url the URL for the credential handler.\n   *\n   * @return a Promise that resolves to `true` if the registration exists and\n   *           `false` if not.\n   */\n  async hasRegistration(url) {\n    this._deprecateNotice();\n    await this._init;\n    return await this._remote.hasRegistration('credential', url);\n  }\n\n  _deprecateNotice() {\n    console.warn(\n      'Credential handler registration APIs are deprecated. The credential ' +\n      'handler specified in \"manifest.json\" is now automatically registered ' +\n      'when a user grants permission to install a credential handler via ' +\n      '\"CredentialManager.requestPermission()\".');\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\n/* global Image */\nexport class CredentialHints {\n  constructor(url, injector) {\n    const remote = injector.get('credentialHints', {\n      functions: ['delete', 'get', 'keys', 'has', 'set', 'clear']\n    });\n    for(let methodName in remote) {\n      if(methodName !== 'set') {\n        const method = remote[methodName].bind(this, url);\n        this[methodName] = function(...args) {\n          this._deprecateNotice();\n          return method(...args);\n        };\n      }\n    }\n    this._remoteSet = remote.set.bind(this, url);\n  }\n\n  async set(hintKey, credentialHint) {\n    this._deprecateNotice();\n\n    // ensure images are prefetched so that they will not leak information\n    // when fetched later\n    credentialHint.icons = credentialHint.icons || [];\n    const promises = credentialHint.icons.map(icon =>\n      imageToDataUrl(icon.src).then(fetchedImage => {\n        icon.fetchedImage = fetchedImage;\n      }));\n    await Promise.all(promises);\n    return this._remoteSet(hintKey, credentialHint);\n  }\n\n  _deprecateNotice() {\n    console.warn('Credential hints are deprecated and no longer used.');\n  }\n}\n\nfunction imageToDataUrl(url) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = () => {\n      let canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.height = img.height;\n      canvas.width = img.width;\n      ctx.drawImage(img, 0, 0);\n      const dataUrl = canvas.toDataURL();\n      resolve(dataUrl);\n      canvas = null;\n    };\n    // TODO: `reject` as an error and fail `.set`?\n    img.onerror = () => resolve(null);\n    img.src = url;\n  });\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\n/* global navigator */\nimport {CredentialHints} from './CredentialHints.js';\n\n/* A CredentialManager for a Web Credential Mediator. */\nexport class CredentialManager {\n  constructor(url, injector) {\n    if(!(url && typeof url === 'string')) {\n      throw new TypeError('\"url\" must be a non-empty string.');\n    }\n    // FIXME: deprecate `.hints` -- make each method a no-op with a\n    // console.warn(); all that is needed is a permission request which will\n    // auto-register the credential handler based on what is in `manifest.json`\n    this.hints = new CredentialHints(url, injector);\n  }\n\n  /**\n   * Requests that the user grant 'credentialhandler' permission to the current\n   * origin.\n   *\n   * @return a Promise that resolves to the new PermissionState of the\n   *           permission (e.g. 'granted'/'denied').\n   */\n  static async requestPermission() {\n    const status = await navigator.credentialsPolyfill.permissions.request(\n      {name: 'credentialhandler'});\n    return status.state;\n  }\n}\n","/*!\n * A CredentialRequestEvent is emitted when a request has been made for\n * credentials.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n/* global Event */\n'use strict';\n\nimport {WebAppWindow} from 'web-request-rpc';\n\n// can't use \"ExtendableEvent\"; only accessible from Workers\n// TODO: may not be able to even extend `Event` here; could produce \"incorrect\"\n//   core attributes\nexport class CredentialRequestEvent /*extends Event*/ {\n  constructor({\n    credentialHandler,\n    credentialRequestOrigin,\n    credentialRequestOptions,\n    hintKey\n  }) {\n    //super('credentialrequest');\n    this.type = 'credentialrequest';\n    this._credentialHandler = credentialHandler;\n    this.credentialRequestOrigin = credentialRequestOrigin;\n    this.credentialRequestOptions = credentialRequestOptions;\n    this.hintKey = hintKey;\n  }\n\n  async openWindow(url) {\n    // TODO: disallow more than one call\n\n    // TODO: ensure `url` is to the same origin\n    await this._credentialHandler.show();\n    const appWindow = new WebAppWindow(url, {\n      className: 'credential-handler'\n    });\n    appWindow.ready();\n    appWindow.show();\n    // TODO: note that `appWindow.handle` is not a ServiceWorker\n    //   `WindowClient` polyfill... could be confusing here, should we\n    //   implement one to wrap it? -- there is, for example, a\n    //   `navigate` call on `WindowClient` that enforces same origin, would\n    //   need to attempt to add or approximate that\n    appWindow.handle._dialog = appWindow.dialog;\n    return appWindow.handle;\n  }\n\n  respondWith(handlerResponse) {\n    // TODO: throw exception if `_promise` is already set\n\n    // TODO: validate handlerResponse\n    this._promise = handlerResponse;\n  }\n}\n","/*!\n * A CredentialStoreEvent is emitted when a request has been made to\n * store a credential.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n/* global Event */\n'use strict';\n\nimport {WebAppWindow} from 'web-request-rpc';\n\n// can't use \"ExtendableEvent\"; only accessible from Workers\n// TODO: may not be able to even extend `Event` here; could produce \"incorrect\"\n//   core attributes\nexport class CredentialStoreEvent /*extends Event*/ {\n  constructor({\n    credentialHandler,\n    credentialRequestOrigin,\n    credential,\n    hintKey\n  }) {\n    //super('credentialstore');\n    this.type = 'credentialstore';\n    this._credentialHandler = credentialHandler;\n    this.credentialRequestOrigin = credentialRequestOrigin;\n    this.credential = credential;\n    this.hintKey = hintKey;\n  }\n\n  async openWindow(url) {\n    // TODO: disallow more than one call\n\n    // TODO: ensure `url` is to the same origin\n    await this._credentialHandler.show();\n    const appWindow = new WebAppWindow(url);\n    appWindow.ready();\n    appWindow.show();\n    // TODO: note that `appWindow.handle` is not a ServiceWorker\n    //   `WindowClient` polyfill... could be confusing here, should we\n    //   implement one to wrap it? -- there is, for example, a\n    //   `navigate` call on `WindowClient` that enforces same origin, would\n    //   need to attempt to add or approximate that\n    appWindow.handle._dialog = appWindow.dialog;\n    return appWindow.handle;\n  }\n\n  respondWith(handlerResponse) {\n    // TODO: throw exception if `_promise` is already set\n\n    // TODO: validate handlerResponse\n    this._promise = handlerResponse;\n  }\n}\n","/*!\n * Wrapper for native CredentialsContainer that uses remote Credential Mediator\n * for WebCredential-related operations.\n *\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n/* global navigator, DOMException */\n'use strict';\n\nimport {WebCredential} from './WebCredential.js';\n\n// RPC timeouts, 0 = indefinite\nconst CREDENTIAL_GET_TIMEOUT = 0;\nconst CREDENTIAL_STORE_TIMEOUT = 0;\n\nexport class CredentialsContainer {\n  constructor(injector) {\n    this._nativeCredentialsContainer = {\n      get: navigator.credentials && navigator.credentials.get &&\n        navigator.credentials.get.bind(navigator.credentials),\n      store: navigator.credentials && navigator.credentials.store &&\n        navigator.credentials.store.bind(navigator.credentials),\n    };\n\n    this._init = (async () => {\n      this._remote = (await injector).get('credentialsContainer', {\n        functions: [\n          {name: 'get', options: {timeout: CREDENTIAL_GET_TIMEOUT}},\n          {name: 'store', options: {timeout: CREDENTIAL_STORE_TIMEOUT}}\n        ]\n      });\n    })();\n  }\n\n  async get(/*CredentialRequestOptions*/ options = {}) {\n    if(options.web) {\n      await this._init;\n      const credential = await this._remote.get(options);\n      if(!credential) {\n        // no credential selected\n        return null;\n      }\n      // TODO: validate credential\n      return new WebCredential(credential.dataType, credential.data);\n    }\n    if(this._nativeCredentialsContainer.get) {\n      return this._nativeCredentialsContainer.get(options);\n    }\n    throw new DOMException('Not implemented.', 'NotSupportedError');\n  }\n\n  async store(credential) {\n    if(credential instanceof WebCredential) {\n      await this._init;\n      const result = await this._remote.store(credential);\n      if(!result) {\n        // nothing stored\n        return null;\n      }\n      // TODO: validate result\n      return new WebCredential(result.dataType, result.data);\n    }\n    if(this._nativeCredentialsContainer.store) {\n      return this._nativeCredentialsContainer.store(credential);\n    }\n    throw new DOMException('Not implemented.', 'NotSupportedError');\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\n// RPC timeouts, 0 = indefinite\nconst PERMISSION_REQUEST_TIMEOUT = 0;\n\n/* Provides an API for working with permissions. */\nexport class PermissionManager {\n  constructor(injector) {\n    this._init = (async () => {\n      this._remote = (await injector).get('permissionManager', {\n        functions: [\n          'query',\n          {name: 'request', options: {timeout: PERMISSION_REQUEST_TIMEOUT}},\n          'revoke']\n      });\n    })();\n  }\n\n  async query(permissionDesc) {\n    await this._init;\n    return await this._remote.query(permissionDesc);\n  }\n\n  async request(permissionDesc) {\n    await this._init;\n    return await this._remote.request(permissionDesc);\n  }\n\n  async revoke(permissionDesc) {\n    await this._init;\n    return await this._remote.revoke(permissionDesc);\n  }\n}\n","/*!\n * A WebCredential is a Credential that can be retrieved from or stored by a\n * \"credential handler\" that runs in a third party Web application.\n *\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\nexport class WebCredential {\n  constructor(dataType, data, {recommendedHandlerOrigins = []} = {}) {\n    if(typeof dataType !== 'string') {\n      throw new TypeError('\"dataType\" must be a string.');\n    }\n    this.type = 'web';\n    this.dataType = dataType;\n    this.data = data;\n    this.options = {recommendedHandlerOrigins};\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\n/* global navigator, window */\nimport {WebAppContext} from 'web-request-rpc';\n\nimport {CredentialHandler} from './CredentialHandler.js';\nimport {CredentialHandlers} from './CredentialHandlers.js';\nimport {CredentialManager} from './CredentialManager.js';\nimport {CredentialsContainer} from './CredentialsContainer.js';\nimport {PermissionManager} from './PermissionManager.js';\nimport {WebCredential} from './WebCredential.js';\n\nconst DEFAULT_MEDIATOR_ORIGIN = 'https://authn.io';\n\n// export classes for testing/TypeScript\nexport {\n  CredentialHandler,\n  CredentialManager,\n  WebCredential\n};\n\nlet loaded;\nexport async function loadOnce(options) {\n  if(loaded) {\n    return loaded;\n  }\n\n  loaded = true;\n  return load(options);\n}\n\nexport async function load(options = {\n  mediatorOrigin: DEFAULT_MEDIATOR_ORIGIN\n}) {\n  // backwards compatibility (`options` used to be a string for expressing\n  // the full mediator URL)\n  let mediatorUrl;\n  if(typeof options === 'string') {\n    mediatorUrl = options;\n  } else if(options && typeof options === 'object' &&\n    typeof options.mediatorOrigin === 'string') {\n    mediatorUrl = `${options.mediatorOrigin}/mediator`;\n  } else {\n    throw new Error(\n      '\"options.mediatorOrigin\" must be a string expressing the ' +\n      'origin of the mediator.');\n  }\n\n  // temporarily still using this for setting permissions and other\n  // non-get/store APIs\n  const appContext = new WebAppContext();\n  const injector = appContext.createWindow(mediatorUrl, {\n    className: 'credential-mediator',\n    // 30 second timeout for loading the mediator\n    timeout: 30000\n  });\n\n  // ensure backdrop is transparent by default\n  const style = document.createElement('style');\n  style.appendChild(document.createTextNode(\n    `dialog.web-app-window.credential-mediator > .web-app-window-backdrop {\n      background-color: rgba(0, 0, 0, 0.25);\n    }`));\n  document.body.appendChild(style);\n\n  const polyfill = {};\n\n  // TODO: only expose certain APIs when appropriate\n  polyfill.permissions = new PermissionManager(injector);\n  polyfill.CredentialHandlers = new CredentialHandlers(injector);\n  polyfill.CredentialHandler = CredentialHandler;\n  polyfill.CredentialManager = CredentialManager;\n  polyfill.credentials = new CredentialsContainer(injector);\n\n  polyfill.WebCredential = WebCredential;\n\n  // expose polyfill\n  navigator.credentialsPolyfill = polyfill;\n\n  // polyfill\n  if('credentials' in navigator) {\n    navigator.credentials.get = polyfill.credentials.get.bind(\n      polyfill.credentials);\n    navigator.credentials.store = polyfill.credentials.store.bind(\n      polyfill.credentials);\n  } else {\n    navigator.credentials = polyfill.credentials;\n  }\n  window.CredentialManager = CredentialManager;\n  window.WebCredential = WebCredential;\n\n  return polyfill;\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as utils from './utils.js';\n\n// 30 second default timeout\nconst RPC_CLIENT_CALL_TIMEOUT = 30000;\n\nexport class Client {\n  constructor() {\n    this.origin = null;\n    this._handle = null;\n    this._listener = null;\n    // all pending requests\n    this._pending = new Map();\n  }\n\n  /**\n   * Connects to a Web Request RPC server.\n   *\n   * The Promise will resolve to an RPC injector that can be used to get or\n   * define APIs to enable communication with the server.\n   *\n   * @param origin the origin to send messages to.\n   * @param options the options to use:\n   *          [handle] a handle to the window (or a Promise that resolves to\n   *            a handle) to send messages to\n   *            (defaults to `window.opener || window.parent`).\n   *\n   * @return a Promise that resolves to an RPC injector once connected.\n   */\n  async connect(origin, options) {\n    if(this._listener) {\n      throw new Error('Already connected.');\n    }\n\n    options = options || {};\n\n    // TODO: validate `origin` and `options.handle`\n    const self = this;\n    self.origin = utils.parseUrl(origin).origin;\n    self._handle = options.handle || window.opener || window.parent;\n\n    const pending = self._pending;\n    self._listener = utils.createMessageListener({\n      origin: self.origin,\n      handle: self._handle,\n      expectRequest: false,\n      listener: message => {\n        // ignore messages that have no matching, pending request\n        if(!pending.has(message.id)) {\n          return;\n        }\n\n        // resolve or reject Promise associated with message\n        const {resolve, reject, cancelTimeout} = pending.get(message.id);\n        cancelTimeout();\n        if('result' in message) {\n          return resolve(message.result);\n        }\n        reject(utils.deserializeError(message.error));\n      }\n    });\n    window.addEventListener('message', self._listener);\n\n    return new Injector(self);\n  }\n\n  /**\n   * Performs a RPC by sending a message to the Web Request RPC server and\n   * awaiting a response.\n   *\n   * @param qualifiedMethodName the fully-qualified name of the method to call.\n   * @param parameters the parameters for the method.\n   * @param options the options to use:\n   *          [timeout] a timeout, in milliseconds, for awaiting a response;\n   *            a non-positive timeout (<= 0) will cause an indefinite wait.\n   *\n   * @return a Promise that resolves to the result (or error) of the call.\n   */\n  async send(qualifiedMethodName, parameters, {\n    timeout = RPC_CLIENT_CALL_TIMEOUT\n  }) {\n    if(!this._listener) {\n      throw new Error('RPC client not connected.');\n    }\n\n    const self = this;\n\n    const message = {\n      jsonrpc: '2.0',\n      id: utils.uuidv4(),\n      method: qualifiedMethodName,\n      params: parameters\n    };\n\n    // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n    // a bug that throws an exception if the handle is cross domain\n    if(utils.isHandlePromise(self._handle)) {\n      const handle = await self._handle;\n      handle.postMessage(message, self.origin);\n    } else {\n      self._handle.postMessage(message, self.origin);\n    }\n\n    // return Promise that will resolve once a response message has been\n    // received or once a timeout occurs\n    return new Promise((resolve, reject) => {\n      const pending = self._pending;\n      let cancelTimeout;\n      if(timeout > 0) {\n        const timeoutId = setTimeout(() => {\n          pending.delete(message.id);\n          reject(new Error('RPC call timed out.'));\n        }, timeout);\n        cancelTimeout = () => {\n          pending.delete(message.id);\n          clearTimeout(timeoutId);\n        };\n      } else {\n        cancelTimeout = () => {\n          pending.delete(message.id);\n        };\n      }\n      pending.set(message.id, {resolve, reject, cancelTimeout});\n    });\n  }\n\n  /**\n   * Disconnects from the remote Web Request RPC server and closes down this\n   * client.\n   */\n  close() {\n    if(this._listener) {\n      window.removeEventListener('message', this._listener);\n      this._handle = this.origin = this._listener = null;\n      // reject all pending calls\n      for(const value of this._pending.values()) {\n        value.reject(new Error('RPC client closed.'));\n      }\n      this._pending = new Map();\n    }\n  }\n}\n\nclass Injector {\n  constructor(client) {\n    this.client = client;\n    this._apis = new Map();\n  }\n\n  /**\n   * Defines a named API that will use an RPC client to implement its\n   * functions. Each of these functions will be asynchronous and return a\n   * Promise with the result from the RPC server.\n   *\n   * This function will return an interface with functions defined according\n   * to those provided in the given `definition`. The `name` parameter can be\n   * used to obtain this cached interface via `.get(name)`.\n   *\n   * @param name the name of the API.\n   * @param definition the definition for the API, including:\n   *          functions: an array of function names (as strings) or objects\n   *            containing: {name: <functionName>, options: <rpcClientOptions>}.\n   *\n   * @return an interface with the functions provided via `definition` that\n   *           will make RPC calls to an RPC server to provide their\n   *           implementation.\n   */\n  define(name, definition) {\n    if(!(name && typeof name === 'string')) {\n      throw new TypeError('`name` must be a non-empty string.');\n    }\n    // TODO: support Web IDL as a definition format?\n    if(!(definition && typeof definition === 'object' &&\n      Array.isArray(definition.functions))) {\n      throw new TypeError(\n        '`definition.function` must be an array of function names or ' +\n        'function definition objects to be defined.');\n    }\n\n    const self = this;\n    const api = {};\n\n    definition.functions.forEach(fn => {\n      if(typeof fn === 'string') {\n        fn = {name: fn, options: {}};\n      }\n      api[fn.name] = async function() {\n        return self.client.send(\n          name + '.' + fn.name, [...arguments], fn.options);\n      };\n    });\n\n    self._apis[name] = api;\n    return api;\n  }\n\n  /**\n   * Get a named API, defining it if necessary when a definition is provided.\n   *\n   * @param name the name of the API.\n   * @param [definition] the definition for the API; if the API is already\n   *          defined, this definition is ignored.\n   *\n   * @return the interface.\n   */\n  get(name, definition) {\n    const api = this._apis[name];\n    if(!api) {\n      if(definition) {\n        return this.define(name, definition);\n      }\n      throw new Error(`API \"${name}\" has not been defined.`);\n    }\n    return this._apis[name];\n  }\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nexport class EventEmitter {\n  constructor({deserialize = e => e, waitUntil = async () => {}} = {}) {\n    this._listeners = [];\n    this._deserialize = deserialize;\n    this._waitUntil = waitUntil;\n  }\n\n  async emit(event) {\n    event = this._deserialize(event);\n    (this._listeners[event.type] || []).forEach(l => l(event));\n    return this._waitUntil(event);\n  }\n\n  addEventListener(eventType, fn) {\n    if(!this._listeners[eventType]) {\n      this._listeners[eventType] = [fn];\n    } else {\n      this._listeners[eventType].push(fn);\n    }\n  }\n\n  removeEventListener(eventType, fn) {\n    const listeners = this._listeners[eventType];\n    if(!listeners) {\n      return;\n    }\n    const idx = listeners.indexOf(fn);\n    if(idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as utils from './utils.js';\n\nexport class Server {\n  constructor() {\n    this.origin = null;\n    this._handle = null;\n    this._apis = new Map();\n  }\n\n  /**\n   * Provides an implementation for a named API. All functions in the given\n   * API will be made callable via RPC clients connected to this server.\n   *\n   * @param name the name of the API.\n   * @param api the API to add.\n   */\n  define(name, api) {\n    if(!(name && typeof name === 'string')) {\n      throw new TypeError('`name` must be a non-empty string.');\n    }\n    if(!(api && api !== 'object')) {\n      throw new TypeError('`api` must be an object.');\n    }\n    if(name in this._apis) {\n      throw new Error(`The \"${name}\" API is already defined.`);\n    }\n\n    this._apis[name] = api;\n  }\n\n  /**\n   * Listens for RPC messages from clients from a particular origin and\n   * window handle and uses them to execute API calls based on predefined\n   * APIs.\n   *\n   * If messages are not from the given origin or window handle, they are\n   * ignored. If the messages refer to named APIs that have not been defined\n   * then an error message is sent in response. These error messages can\n   * be suppressed by using the `ignoreUnknownApi` option.\n   *\n   * If a message refers to an unknown method on a known named API, then an\n   * error message is sent in response.\n   *\n   * @param origin the origin to listen for.\n   * @param options the options to use:\n   *          [handle] a handle to the window (or a Promise that resolves to\n   *            a handle) to listen for messages from\n   *            (defaults to `window.opener || window.parent`).\n   *          [ignoreUnknownApi] `true` to ignore unknown API messages.\n   */\n  async listen(origin, options) {\n    if(this._listener) {\n      throw new Error('Already listening.');\n    }\n\n    options = options || {};\n\n    // TODO: validate `origin` and `options.handle`\n    const self = this;\n    self.origin = utils.parseUrl(origin).origin;\n    self._handle = options.handle || window.opener || window.parent;\n\n    const ignoreUnknownApi = (options.ignoreUnknownApi === 'true') || false;\n\n    self._listener = utils.createMessageListener({\n      origin: self.origin,\n      handle: self._handle,\n      expectRequest: true,\n      listener: message => {\n        const {name, method} = utils.destructureMethodName(message.method);\n        const api = self._apis[name];\n\n        // do not allow calling \"private\" methods (starts with `_`)\n        if(method && method.startsWith('_')) {\n          return sendMethodNotFound(self._handle, self.origin, message);\n        }\n\n        // API not found but ignore flag is on\n        if(!api && ignoreUnknownApi) {\n          // API not registered, ignore the message rather than raise error\n          return;\n        }\n\n        // no ignore flag and unknown API or unknown specific method\n        if(!api || typeof api[method] !== 'function') {\n          return sendMethodNotFound(self._handle, self.origin, message);\n        }\n\n        // API and specific function found\n        const fn = api[method];\n        (async () => {\n          const response = {\n            jsonrpc: '2.0',\n            id: message.id\n          };\n          try {\n            response.result = await fn.apply(api, message.params);\n          } catch(e) {\n            response.error = utils.serializeError(e);\n          }\n          // if server did not `close` while we waited for a response\n          if(self._handle) {\n            // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n            // a bug that throws an exception if the handle is cross domain\n            if(utils.isHandlePromise(self._handle)) {\n              self._handle.then(h => h.postMessage(response, self.origin));\n            } else {\n              self._handle.postMessage(response, self.origin);\n            }\n          }\n        })();\n      }\n    });\n    window.addEventListener('message', self._listener);\n  }\n\n  close() {\n    if(this._listener) {\n      window.removeEventListener('message', this._listener);\n      this._handle = this.origin = this._listener = null;\n    }\n  }\n}\n\nfunction sendMethodNotFound(handle, origin, message) {\n  const response = {\n    jsonrpc: '2.0',\n    id: message.id,\n    error: Object.assign({}, utils.RPC_ERRORS.MethodNotFound)\n  };\n  // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n  // a bug that throws an exception if the handle is cross domain\n  if(utils.isHandlePromise(handle)) {\n    return handle.then(h => h.postMessage(response, origin));\n  } else {\n    return handle.postMessage(response, origin);\n  }\n}\n","/*!\n * A WebApp is a remote application that runs in a WebAppContext.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport {Client} from './Client.js';\nimport {Server} from './Server.js';\nimport {parseUrl} from './utils.js';\n\nexport class WebApp {\n  constructor(relyingOrigin) {\n    // this is the origin that created the WebAppContext to run it in\n    // TODO: better name? `contextOrigin`?\n    this.relyingOrigin = parseUrl(relyingOrigin).origin;\n    this.client = null;\n    this.injector = null;\n    this.client = new Client();\n    this.server = new Server();\n\n    this._control = null;\n    this._connected = false;\n  }\n\n  /**\n   * Connects this WebApp to the relying origin that instantiated it. Once\n   * connected, the WebApp can start servicing calls from that origin.\n   *\n   * @return a Promise that resolves to an injector for creating custom client\n   *           APIs once the connection is ready.\n   */\n  async connect() {\n    this.injector = await this.client.connect(this.relyingOrigin);\n    this._connected = true;\n    this._control = this.injector.define('core.control', {\n      functions: ['ready', 'show', 'hide']\n    });\n    this.server.listen(this.relyingOrigin);\n    return this.injector;\n  }\n\n  /**\n   * Must be called after `connect` when this WebApp is ready to start\n   * receiving calls from the remote end.\n   */\n  async ready() {\n    if(!this._connected) {\n      throw new Error('WebApp not connected. Did you call \".connect()\"?');\n    }\n    await this._control.ready();\n    return this;\n  }\n\n  /**\n   * Closes this WebApp's connection to the relying origin.\n   */\n  close() {\n    if(this._connected) {\n      this.server.close();\n      this.client.close();\n      this._connected = false;\n    }\n  }\n\n  /**\n   * Shows the UI for this WebApp on the relying origin.\n   */\n  async show() {\n    if(!this._connected) {\n      throw new Error(\n        'Cannot \"show\" yet; not connected. Did you call \".connect()\"?');\n    }\n    return this._control.show();\n  }\n\n  /**\n   * Hides the UI for this WebApp on the relying origin.\n   */\n  async hide() {\n    if(!this._connected) {\n      throw new Error(\n        'Cannot \"hide\" yet; not connected. Did you call \".connect()?\"');\n    }\n    return this._control.hide();\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {Client} from './Client.js';\nimport {Server} from './Server.js';\nimport {WebAppWindow} from './WebAppWindow.js';\nimport {parseUrl} from './utils.js';\n\n// 10 seconds\nconst WEB_APP_CONTEXT_LOAD_TIMEOUT = 10000;\n\nexport class WebAppContext {\n  constructor() {\n    this.client = new Client();\n    this.server = new Server();\n    this.injector = null;\n    this.control = null;\n    this.loaded = false;\n    this.closed = false;\n  }\n\n  /**\n   * Creates a window (or attaches to an existing one) that loads a page that\n   * is expected to understand the web request RPC protocol. This method\n   * returns a Promise that will resolve once the page uses RPC to indicate\n   * that it is ready to be communicated with or once a timeout occurs.\n   *\n   * The Promise will resolve to an RPC injector that can be used to get or\n   * define APIs to enable communication with the WebApp running in the\n   * WebAppContext.\n   *\n   * @param url the URL to the page to connect to.\n   * @param options the options to use:\n   *          [timeout] the timeout for waiting for the client to be ready.\n   *          [handle] a window handle to connect to; may be a Promise that\n   *            that resolves to a handle.\n   *          [iframe] an iframe element to connect to.\n   *          [windowControl] a window control interface to connect to.\n   *          [className] a className to assign to the window for CSS purposes.\n   *          [customize(options)] a function to customize the dialog that\n   *            loads the window after its construction.\n   *          [bounds] a bounding rectangle (top, left, width, height) to\n   *            use when creating a popup window.\n   *\n   * @return a Promise that resolves to an RPC injector once the window is\n   *           ready.\n   */\n  async createWindow(\n    url, {\n      timeout = WEB_APP_CONTEXT_LOAD_TIMEOUT,\n      iframe,\n      dialog = null,\n      popup = false,\n      handle,\n      windowControl,\n      className,\n      customize,\n      // top, left, width, height\n      bounds\n    } = {}) {\n    // disallow loading the same WebAppContext more than once\n    if(this.loaded) {\n      throw new Error('AppContext already loaded.');\n    }\n    this.loaded = true;\n\n    // create control API for WebApp to call via its own RPC client\n    this.control = new WebAppWindow(url, {\n      timeout,\n      dialog,\n      iframe,\n      popup,\n      handle,\n      windowControl,\n      className,\n      customize,\n      bounds\n    });\n\n    // if the local window closes, close the control window as well\n    window.addEventListener('pagehide', () => this.close(), {once: true});\n\n    // define control class; this enables the WebApp that is running in the\n    // WebAppContext to control its UI or close itself down\n    this.server.define('core.control', this.control);\n\n    // listen for calls from the window, ignoring calls to unknown APIs\n    // to allow those to be handled by other servers\n    const origin = parseUrl(url).origin;\n    this.server.listen(origin, {\n      handle: this.control.handle,\n      ignoreUnknownApi: true\n    });\n\n    // wait for control to be ready\n    await this.control._private.isReady();\n\n    // connect to the WebAppContext and return the injector\n    this.injector = await this.client.connect(origin, {\n      handle: this.control.handle\n    });\n    return this.injector;\n  }\n\n  close() {\n    if(!this.closed) {\n      this.closed = true;\n      this.control._private.destroy();\n      this.server.close();\n      this.client.close();\n    }\n  }\n}\n","/*!\n * Copyright (c) 2017-2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {WebAppWindowInlineDialog} from './WebAppWindowInlineDialog.js';\nimport {WebAppWindowPopupDialog} from './WebAppWindowPopupDialog.js';\n\n// default timeout is 60 seconds\nconst LOAD_WINDOW_TIMEOUT = 60000;\n\n/**\n * Provides a window and API for remote Web applications. This API is typically\n * used by RPC WebApps that run in a WebAppContext to indicate when they are\n * ready and to show/hide their UI.\n */\nexport class WebAppWindow {\n  constructor(\n    url, {\n      timeout = LOAD_WINDOW_TIMEOUT,\n      dialog = null,\n      handle,\n      popup = false,\n      className = null,\n      customize = null,\n      // top, left, width, height\n      bounds\n    } = {}) {\n    this.visible = false;\n    this.dialog = dialog;\n    this.handle = null;\n    this.popup = popup;\n    this.windowControl = null;\n    this._destroyed = false;\n    this._ready = false;\n    this._private = {};\n    this._timeoutId = null;\n\n    if(handle && handle._dialog) {\n      this.dialog = dialog = handle._dialog;\n    }\n    // private to allow caller to track readiness\n    this._private._readyPromise = new Promise((resolve, reject) => {\n      // reject if timeout reached\n      this._timeoutId = setTimeout(\n        () => reject(new DOMException(\n          'Loading Web application window timed out.', 'TimeoutError')),\n        timeout);\n      this._private._resolveReady = value => {\n        clearTimeout(this.timeoutId);\n        this._timeoutId = null;\n        resolve(value);\n      };\n      this._private._rejectReady = err => {\n        clearTimeout(this.timeoutId);\n        this._timeoutId = null;\n        reject(err);\n      };\n    });\n    this._private.isReady = async () => {\n      return this._private._readyPromise;\n    };\n\n    // private to disallow destruction via client\n    this._private.destroy = () => {\n      // window not ready yet, but destroyed\n      if(this._timeoutId) {\n        this._private._rejectReady(new DOMException(\n          'Web application window closed before ready.', 'AbortError'));\n      }\n      if(!this._destroyed) {\n        this.dialog.destroy();\n        this.dialog = null;\n        this._destroyed = true;\n      }\n    };\n\n    if(customize) {\n      if(!typeof customize === 'function') {\n        throw new TypeError('`options.customize` must be a function.');\n      }\n    }\n\n    if(!this.dialog) {\n      if(this.popup) {\n        this.dialog = new WebAppWindowPopupDialog({url, handle, bounds});\n      } else {\n        this.dialog = new WebAppWindowInlineDialog({url, handle, className});\n      }\n    } else if(this.popup && bounds) {\n      // resize / re-position popup window as requested\n      if(bounds) {\n        const {top: y, left: x, width, height} = bounds;\n        if(x !== undefined && y !== undefined) {\n          this.dialog.handle.moveTo(x, y);\n        }\n        if(width !== undefined && height !== undefined) {\n          this.dialog.handle.resizeTo(width, height);\n        }\n      }\n    }\n\n    this.handle = this.dialog.handle;\n    if(customize) {\n      try {\n        customize({\n          dialog: this.dialog.dialog,\n          container: this.dialog.container,\n          iframe: this.dialog.iframe,\n          webAppWindow: this\n        });\n      } catch(e) {\n        console.error(e);\n      }\n    }\n  }\n\n  /**\n   * Called by the client when it is ready to receive messages.\n   */\n  ready() {\n    this._ready = true;\n    this._private._resolveReady(true);\n  }\n\n  /**\n   * Called by the client when it wants to show UI.\n   */\n  show() {\n    if(!this.visible) {\n      this.visible = true;\n      // disable scrolling on body\n      const body = document.querySelector('body');\n      this._bodyOverflowStyle = body.style.overflow;\n      body.style.overflow = 'hidden';\n      if(!this._destroyed) {\n        this.dialog.show();\n      } else if(this.windowControl.show) {\n        this.windowControl.show();\n      }\n    }\n  }\n\n  /**\n   * Called by the client when it wants to hide UI.\n   */\n  hide() {\n    if(this.visible) {\n      this.visible = false;\n      // restore `overflow` style on body\n      const body = document.querySelector('body');\n      if(this._bodyOverflowStyle) {\n        body.style.overflow = this._bodyOverflowStyle;\n      } else {\n        body.style.overflow = '';\n      }\n      if(!this._destroyed) {\n        this.dialog.close();\n      } else if(this.windowControl.hide) {\n        this.windowControl.hide();\n      }\n    }\n  }\n}\n","/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\nexport class WebAppWindowDialog {\n  constructor() {\n    this._closeEventListeners = new Set();\n  }\n\n  addEventListener(name, listener) {\n    if(name !== 'close') {\n      throw new Error(`Unknown event \"${name}\".`);\n    }\n    if(typeof listener !== 'function') {\n      throw new TypeError('\"listener\" must be a function.');\n    }\n    this._closeEventListeners.add(listener);\n  }\n\n  removeEventListener(name, listener) {\n    if(name !== 'close') {\n      throw new Error(`Unknown event \"${name}\".`);\n    }\n    if(typeof listener !== 'function') {\n      throw new TypeError('\"listener\" must be a function.');\n    }\n    this._closeEventListeners.delete(listener);\n  }\n\n  show() {}\n\n  close() {\n    // emit event to all `close` event listeners\n    for(const listener of this._closeEventListeners) {\n      listener({});\n    }\n  }\n\n  destroy() {\n    this._closeEventListeners.clear();\n  }\n}\n","/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {WebAppWindowDialog} from './WebAppWindowDialog.js';\n\nexport class WebAppWindowInlineDialog extends WebAppWindowDialog {\n  constructor({url, handle, className}) {\n    super();\n    this.url = url;\n    this.handle = handle;\n    // create a top-level dialog overlay\n    this.dialog = document.createElement('dialog');\n    applyStyle(this.dialog, {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      'max-width': '100%',\n      'max-height': '100%',\n      display: 'none',\n      margin: 0,\n      padding: 0,\n      border: 'none',\n      background: 'transparent',\n      color: 'black',\n      'box-sizing': 'border-box',\n      overflow: 'hidden',\n      'z-index': 1000000\n    });\n    this.dialog.className = 'web-app-window';\n    if(typeof className === 'string') {\n      this.dialog.className = this.dialog.className + ' ' + className;\n    }\n\n    // ensure backdrop is transparent by default\n    const style = document.createElement('style');\n    style.appendChild(\n      document.createTextNode(`dialog.web-app-window::backdrop {\n        background-color: transparent;\n      }`));\n\n    // create flex container for iframe\n    this.container = document.createElement('div');\n    applyStyle(this.container, {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      margin: 0,\n      padding: 0,\n      display: 'flex',\n      'flex-direction': 'column'\n    });\n    this.container.className = 'web-app-window-backdrop';\n\n    // create iframe\n    this.iframe = document.createElement('iframe');\n    this.iframe.src = url;\n    this.iframe.scrolling = 'auto';\n    applyStyle(this.iframe, {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      border: 'none',\n      background: 'transparent',\n      overflow: 'hidden',\n      margin: 0,\n      padding: 0,\n      'flex-grow': 1\n    });\n\n    // assemble dialog\n    this.dialog.appendChild(style);\n    this.container.appendChild(this.iframe);\n    this.dialog.appendChild(this.container);\n\n    // a.document.appendChild(this.iframe);\n    // handle cancel (user pressed escape)\n    this.dialog.addEventListener('cancel', e => {\n      e.preventDefault();\n      this.hide();\n    });\n\n    // attach to DOM\n    document.body.appendChild(this.dialog);\n    this.handle = this.iframe.contentWindow;\n  }\n\n  show() {\n    this.dialog.style.display = 'block';\n    if(this.dialog.showModal) {\n      this.dialog.showModal();\n    }\n  }\n\n  close() {\n    this.dialog.style.display = 'none';\n    if(this.dialog.close) {\n      try {\n        this.dialog.close();\n      } catch(e) {\n        console.error(e);\n      }\n    }\n    super.close();\n  }\n\n  destroy() {\n    this.dialog.parentNode.removeChild(this.dialog);\n    super.destroy();\n  }\n}\n\nfunction applyStyle(element, style) {\n  for(const name in style) {\n    element.style[name] = style[name];\n  }\n}\n","/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\nimport {WebAppWindowDialog} from './WebAppWindowDialog.js';\n\nexport class WebAppWindowPopupDialog extends WebAppWindowDialog {\n  constructor({url, handle, bounds = {width: 500, height: 400}}) {\n    super();\n    this.url = url;\n    this.handle = handle;\n    this._locationChanging = false;\n    if(!handle) {\n      this._openWindow({url, name: 'web-app-window', bounds});\n    }\n    this.destroyed = false;\n    this._removeListeners = () => {};\n  }\n\n  show() {}\n\n  close() {\n    this.destroy();\n  }\n\n  destroy() {\n    if(this.handle && !this.destroyed) {\n      this.handle.close();\n      super.close();\n      this.handle = null;\n      this.destroyed = true;\n      this._removeListeners();\n      super.destroy();\n    }\n  }\n\n  isClosed() {\n    return !this.handle || this.handle.closed;\n  }\n\n  _openWindow({url, name, bounds}) {\n    const {x, y} = bounds;\n    let {width = 500, height = 400} = bounds;\n    width = Math.min(width, window.innerWidth);\n    height = Math.min(height, window.innerHeight);\n    const left = x !== undefined ?\n      x : window.screenX + (window.innerWidth - width) / 2;\n    const top = y !== undefined ?\n      y : window.screenY + (window.innerHeight - height) / 2;\n    const features =\n      'popup=yes,menubar=no,location=no,resizable=no,scrollbars=no,status=no,' +\n      `width=${width},height=${height},left=${left},top=${top}`;\n    this._locationChanging = true;\n    this.handle = window.open(url, name, features);\n\n    this._addListeners();\n  }\n\n  setLocation(url) {\n    this.url = url;\n    this._locationChanging = true;\n    this.handle.location.replace(url);\n  }\n\n  _addListeners() {\n    const destroyDialog = () => this.destroy();\n\n    // when a new URL loads in the dialog, clear the location changing flag\n    const loadDialog = () => {\n      this._locationChanging = false;\n    };\n\n    // when the dialog URL changes...\n    const unloadDialog = () => {\n      if(this._locationChanging) {\n        // a location change was expected, return\n        return;\n      }\n\n      // a location change was NOT expected, destroy the dialog\n      this.destroy();\n    };\n\n    this.handle.addEventListener('unload', unloadDialog);\n    this.handle.addEventListener('load', loadDialog);\n\n    // before the current window unloads, destroy the child dialog\n    window.addEventListener('beforeUnload', destroyDialog, {once: true});\n\n    // poll to check for closed window handle; necessary because cross domain\n    // windows will not emit any close-related events we can use here\n    const intervalId = setInterval(() => {\n      if(this.isClosed()) {\n        this.destroy();\n        clearInterval(intervalId);\n      }\n    }, 250);\n\n    // create listener clean up function\n    this._removeListeners = () => {\n      clearInterval(intervalId);\n      this.handle.removeListener('unload', unloadDialog);\n      this.handle.removeListener('load', loadDialog);\n      window.removeEventListener('beforeUnload', destroyDialog);\n    }\n  }\n}\n","/*!\n * JSON-RPC for Web Request Polyfills.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nexport {Client} from './Client.js';\nexport {EventEmitter} from './EventEmitter.js';\nexport {Server} from './Server.js';\nexport {WebApp} from './WebApp.js';\nexport {WebAppContext} from './WebAppContext.js';\nexport {WebAppWindow} from './WebAppWindow.js';\n\nimport * as utils from './utils.js';\nexport {utils};\n","/*!\n * Utilities for Web Request RPC.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n/* global URL */\n'use strict';\n\nexport const RPC_ERRORS = {\n  ParseError: {\n    message: 'Parse error',\n    code: -32700\n  },\n  InvalidRequest: {\n    message: 'Invalid Request',\n    code: -32600\n  },\n  MethodNotFound: {\n    message: 'Method not found',\n    code: -32601\n  },\n  InvalidParams: {\n    message: 'Invalid params',\n    code: -32602\n  },\n  InternalError: {\n    message: 'Internal Error',\n    code: -32603\n  },\n  ServerError: {\n    message: 'Server error',\n    code: -32000\n  }\n};\n\nexport function parseUrl(url, base) {\n  if(base === undefined) {\n    base = window.location.href;\n  }\n\n  if(typeof URL === 'function') {\n    return new URL(url, base);\n  }\n\n  if(typeof url !== 'string') {\n    throw new TypeError('\"url\" must be a string.');\n  }\n\n  // FIXME: rudimentary relative URL resolution\n  if(!url.includes(':')) {\n    if(base.startsWith('http') && !url.startsWith('/')) {\n      url = base + '/' + url;\n    } else {\n      url = base + url;\n    }\n  }\n\n  // `URL` API not supported, use DOM to parse URL\n  const parser = document.createElement('a');\n  parser.href = url;\n  let origin = (parser.protocol || window.location.protocol) + '//';\n  if(parser.host) {\n    // use hostname when using default ports\n    // (IE adds always adds port to `parser.host`)\n    if((parser.protocol === 'http:' && parser.port === '80') ||\n      (parser.protocol === 'https:' && parser.port === '443')) {\n      origin += parser.hostname;\n    } else {\n      origin += parser.host;\n    }\n  } else {\n    origin += window.location.host;\n  }\n\n  // ensure pathname begins with `/`\n  let pathname = parser.pathname;\n  if(!pathname.startsWith('/')) {\n    pathname = '/' + pathname;\n  }\n\n  return {\n    // TODO: is this safe for general use on every browser that doesn't\n    //   support WHATWG URL?\n    host: parser.host || window.location.host,\n    hostname: parser.hostname,\n    origin: origin,\n    protocol: parser.protocol,\n    pathname: pathname\n  };\n}\n\nexport function originMatches(url, origin) {\n  return parseUrl(url, origin).origin === origin;\n}\n\n// https://gist.github.com/LeverOne/1308368\nexport function uuidv4(a,b) {\n  for(b=a='';a++<36;b+=a*51&52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');return b;\n}\n\nexport function isValidOrigin(url, origin) {\n  if(!originMatches(url, origin)) {\n    throw new Error(\n      `Origin mismatch. Url \"${url}\" does not have an origin of \"${origin}\".`);\n  }\n}\n\nexport function isValidMessage(message) {\n  return (\n    message && typeof message === 'object' &&\n    message.jsonrpc === '2.0' &&\n    message.id && typeof message.id === 'string');\n}\n\nexport function isValidRequest(message) {\n  return isValidMessage(message) && Array.isArray(message.params);\n}\n\nexport function isValidResponse(message) {\n  return (\n    isValidMessage(message) &&\n    !!('result' in message ^ 'error' in message) &&\n    (!('error' in message) || isValidError(message.error)));\n}\n\nexport function isValidError(error) {\n  return (\n    error && typeof error === 'object' &&\n    typeof error.code === 'number' &&\n    typeof error.message === 'string');\n}\n\nexport function serializeError(error) {\n  const err = {\n    message: error.message\n  };\n  if(error.constructor.name !== 'Error') {\n    err.constructor = error.constructor.name;\n  }\n  if('name' in error) {\n    err.name = error.name;\n  }\n  if('code' in error) {\n    err.code = error.code;\n  } else {\n    err.code = RPC_ERRORS.ServerError.code;\n  }\n  if('details' in error) {\n    err.details = error.details;\n  }\n  return err;\n}\n\nexport function deserializeError(error) {\n  let err;\n  // special case known types, otherwise use generic Error\n  if(error.constructor === 'DOMException') {\n    err = new DOMException(error.message, error.name)\n    // ignore code, name will set it\n  } else {\n    err = new Error(error.message);\n    if('code' in error) {\n      err.code = error.code;\n    }\n  }\n  if(error.details) {\n    err.details = error.details;\n  }\n  return err;\n}\n\nexport function createMessageListener(\n  {listener, origin, handle, expectRequest}) {\n  // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n  // a bug that throws an exception if the handle is cross domain\n  if(isHandlePromise(handle)) {\n    const promise = handle;\n    handle = false;\n    promise.then(h => handle = h);\n  }\n  return e => {\n    // ignore messages from a non-matching handle or origin\n    // or that don't follow the protocol\n    if(!(e.source === handle && e.origin === origin &&\n      ((expectRequest && isValidRequest(e.data)) ||\n        (!expectRequest && isValidResponse(e.data))))) {\n      return;\n    }\n    listener(e.data, e);\n  };\n}\n\nexport function destructureMethodName(fqMethodName) {\n  // fully-qualified method name is: `<api-name>.<method-name>`\n  // where `<api-name>` is all but the last dot-delimited segment and\n  // `<method-name>` is the last dot-delimited segment\n  let [name, ...rest] = fqMethodName.split('.');\n  const method = rest.pop();\n  name = [name, ...rest].join('.');\n  return {name, method};\n}\n\nexport function isHandlePromise(handle) {\n  try {\n    // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n    // a bug that throws an exception if the handle is cross domain\n    return typeof handle.then === 'function';\n  } catch(e) {}\n  return false;\n}\n"],"sourceRoot":""}